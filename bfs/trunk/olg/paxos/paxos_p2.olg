program multipaxos;
	
import java.lang.String;
import java.lang.Integer;
	
import java.lang.System;
import jol.core.Runtime;

//timer(periodic,logical,1,1,1);
	
define(acceptRequest,keys(0,1),{String,Integer, Integer,String,Integer});
define(sendBeginRound,keys(0,1,2),{String, Integer,Integer,String,String});
//define(sendBeginRound,{String, Integer,Integer,String,String});
define(accept,keys(0,1),{String, Integer,Integer,String,String});
define(sendAccept,keys(0,1,4),{String, Integer,Integer,String,String});
define(decree,keys(0,1),{String, Integer,Integer,String});
define(success,keys(0,1),{String,Integer, Integer,String,String});
	
define(acceptCnt,keys(0,1),{String,Integer,Integer,Integer});
	
define(tick,keys(0,1),{String,String,Integer});


/**************************************************************************************
3.  After receiving a LastVote (b, v) message from every priest in some majority
set Q, where b = lastTried [p], priest p initiates a new ballot with number b,
quorum Q, and decree d, where d is chosen to satisfy B3. He then sends a
BeginBallot (b, d) message to every priest in Q.
***************************************************************************************/


public
r3_b
acceptRequest(Master,Instance,Round,OldDecree,MaxB) :- 
  paxos::quorum(Master,Round),
	paxos::maxPrevRound(Master,Instance,MaxB),
	paxos::prepare(Master,Round,Decree),
  paxos::instance(Master,I),
  I >= Instance,
	paxos::sendPromise(Master,Instance,Round,MaxB,OldDecree,Agent),
	MaxB != -1;

public
r3_c	
acceptRequest(Master,Instance,Round,Decree,-1) :- 
  paxos::quorum(Master,Round),
	paxos::maxPrevRound(Master,Instance,MaxB),
  paxos::instance(Master,Instance),
	paxos::sendPromise(Master,Instance,Round,MaxB,OldDecree,Agent),
	MaxB == -1,
	paxos::prepare(Master,Round,Decree);
	
// MULTIPAXOS!

//watch(storedDecreeRequest,aed);

public
r3_d
acceptRequest(Master,I,Round,Decree,-2) :-
  paxos::storedDecreeRequest(Master,Decree,From,_),
  paxos::quorum(Master,Round),
  paxos::instance(Master,I),
  notin success(Master,I,_,_,_),
  I > 0;

public
r3_e
sendBeginRound(@Agent,Instance,Round,Decree,Master) :- 
  acceptRequest(@Master,Instance,Round,Decree,Kind),
	paxos::parliament(@Master,Agent);

/**************************************************************************************
r4. Upon receipt of a BeginBallot (b,d) message with b = nextBal [q], priest q casts
his vote in ballot number b, sets prevVote [q] to this vote, and sends a Voted (b, q)
message to p. (A BeginBallot (b, d) message is ignored if b = nextBal [q].)
***************************************************************************************/
public
r4_a
accept(Agent,Instance,Round,Decree,Master) :-
  sendBeginRound(Agent,Instance,Round,Decree,Master),
	paxos::nextBal(Agent,OldB),
  paxos::instance(Agent,Instance),
	Round == OldB;

/*
repair
accept(Agent,Instance,Round,Decree) :-
  sendBeginRound(Agent,Instance,Round,Decree,Master),
	nextBal(Agent,OldB),
  instance(Agent,I),
	Instance < I
  accept(Agent,Instance,Round,Decree)
*/

public
r4_b	
paxos::prevVote(Agent,Instance,Round,Decree) :- 
  paxos::prevVote(Agent,OI,Old,OD),
	paxos::lastPromise(Agent,IO2,Round,OldRound,OldDecree),
	accept#insert(Agent,Instance,Round,Decree),
	Round >= Old;

r4_c	
sendAccept(@Master,Instance,Round,Decree,Agent) :- 
  accept(@Agent,Instance,Round,Decree,Master);
	
votes
acceptCnt(Master,Instance,Round,count<Agent>) :- 
  sendAccept(Master,Instance,Round,Decree,Agent);

/**************************************************************************************
r5. If p has received a Voted (b, q) message from every priest q in Q (the quorum
for ballot number b), where b = lastTried [p], then he writes d (the decree of
that ballot) in his ledger and sends a Success (d) message to every priest.
***************************************************************************************/
public
r5_a	
decree(Master,Instance,Round,Decree) :- 
  paxos::lastTried(Master,Round),
	acceptCnt(Master,Instance,Round,Votes),
  paxos::priestCnt(Master,Priests),
  Votes > (Priests / 2), 
	acceptRequest(Master,Instance,Round,Decree);

public
r5_b	
success(@Agent,Instance,Round,Decree,From) :-
  decree(@Master,Instance,Round,Decree),
	paxos::storedDecreeRequest(@Master,Decree,From,_),
	// we interpret "every" to mean a broadcast.
	paxos::parliament(@Master,Agent);

public
r5_c
success(@Agent,Instance,Round,Decree,From) :-
  decree(@Master,Instance,Round,Decree),
	// this might be a mistake. 
	paxos_global::decreeRequestBuffer(@Master,Decree,From),
	// we interpret "every" to mean a broadcast.
	paxos::parliament(@Master,Agent);


/*
// breakout.
public
r5_d
success(Agent,Instance,Round,Decree,From) :-
  paxos::storedDecreeRequest(Agent,Decree,From,_),
  paxos::priestCnt(Agent,1),
  Round := -1,
  paxos::instance(Agent,Instance);
*/  
	
// any learner can reply to the client, or set-wise, they all can...
public
response
paxos_global::requestStatus(Master,From,Decree,Instance,"passed") :- 
  success(Master,Instance,Round,Decree,From);


public
arrr
delete
paxos::quorum(Master,Round) :-
  paxos::quorum(Master,Round),
  sendBeginRound(Master,Instance,NewRound,Decree,Other),
  Master != Other,
  NewRound > Round;

/*
watch(paxos::instance,ae);
watch(paxos::sendPrepare,ae);
watch(paxos::nextBal,ae);
watch(paxos::sendPromise,ae);
watch(decree,ae);
watch(acceptCnt,ae);
watch(sendAccept,ae);
watch(sendBeginRound,ae);
watch(accept,ae);
watch(success,ae);
//watch(decreeRequest,ae);
	
watch(paxos_global::requestStatus,ae);	
//watch(maxPrevRound,ae);
watch(acceptRequest,ae);
//watch(receivedPromise,ae);
	
//watch(prevVote,ae);	
//watch(instance,ae);

//watch(quorum,ae);
watch(decree,ae);
watch(sendAccept,ae);
watch(success,ae);

watch(success,ae);
watch(paxos::quorum,ae);
watch(paxos::sendPromise,ae);
*/
