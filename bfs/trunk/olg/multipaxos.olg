program paxos;
	
import java.lang.String;
import java.lang.Integer;
	
import java.lang.System;
import jol.core.Runtime;


// name,type,period,ttl, delay
timer(periodic,logical,1,1,1);

//define(decreeRequest,keys(0,1,2),{String,String,String});
define(decreeRequest,{String,String,String});
define(storedDecreeRequest,keys(0,1,2,3),{String,String,String,Long});
define(lastTried,keys(0,1),{String,Integer,Integer});
define(prevVote,keys(0,1),{String,Integer,Integer,String});
define(nextBal,keys(0,1),{String,Integer,Integer});
define(node,keys(0),{String});
define(parliament,keys(0,1),{String,String});
//define(prepare,keys(0,1,2),{String,Integer,Integer,String});
define(prepare,{String,Integer,Integer,String});
define(sendPrepare,keys(0,1,2,4),{String,Integer,Integer,String,String});
define(lastPromise,keys(0,1,2,5),{String,Integer,Integer,Integer,String,String});
//define(sendPromise,keys(1,1,2,5),{String,Integer,Integer,Integer,String,String});
define(sendPromise,{String,Integer,Integer,Integer,String,String});
define(receivedPromise,keys(0,1,2,5),{String,Integer,Integer,Integer,String,String});
//define(sendBeginRound,keys(0,1,2),{String,Integer, Integer,String,String});
define(sendBeginRound,{String,Integer, Integer,String,String});
define(accept,keys(0,1,2),{String,Integer, Integer,String,String});
//define(accept,{String,Integer, Integer,String});
define(sendAccept,keys(0,1,2,4),{String,Integer, Integer,String,String});
define(decree,keys(0,1,2),{String, Integer,Integer,String});
define(success,keys(0,1,2),{String,Integer, Integer,String,String});
	
define(maxPrevRound,keys(0,1),{String,Integer,Integer});
define(priestCnt,keys(0),{String,Integer});
define(lastPromiseCnt,keys(0,1,2),{String,Integer,Integer,Integer});
define(acceptCnt,keys(0,1,2),{String,Integer,Integer,Integer});
	
define(reply,keys(0,1),{String,String,String});
//define(tick,keys(0,1),{String,String,Integer});
define(instance,keys(0),{String,Integer});

//define(timeError,keys(0,1,2,3),{String,String,String,Long});
//watch(timeError,aedir);

public
paxos_global::decreeRequest(A,B,C) :-
  decreeRequest(A,B,C);

public
parliament(A,B) :- getopt::parliament(A,B),periodic(_,_,_);
	
lastTried(Master,-1,-1) :- parliament(Master,Agent);
prevVote(Master,-1,-1,"none") :- parliament(Master,Agent);
nextBal(Master,-1,-1) :- parliament(Master,Agent);
instance(Master,0) :- parliament(Master,Agent);

/**************************************************************************************
r1. Priest p chooses a new ballot number b greater than lastTried [p], sets lastTried[p]
to b, and sends a NextBallot (b) message to some set of priests.
***************************************************************************************/

r1_a
lastTried(Agent,Instance,Bnum) :- lastTried(Agent,I,Old),
	prepare#insert(Agent,Instance,Bnum,Decree),
	//prepare(Agent,Instance,Bnum,Decree),
	Bnum > Old,
  Instance > I;

watch(storedDecreeRequest,ae);

public	
storedDecreeRequest(Master,Decree,From,Id) :- 
  paxos_global::decreeRequest#insert(Master,Decree,From), 
  Id := Runtime.idgen();


define(maxS,keys(0),{String,Integer});
maxS(Master,max<Instance>) :-
  success(Master,Instance,Round,Decree,From);

instance(Master,I) :-
  maxS(Master,M),
  I := M + 1;

/*
instance(Master,I+1) :- 
  instance(Master,I), 
  storedDecreeRequest#insert(Master,Decree,From,_);
  success(
*/

define(newBallot,keys(0,1),{String,Integer,Integer});
watch(newBallot,ae);
newBallot(Master,Instance,Round) :-
  lastTried(Master,I,Old),
  Round := Old + 1,
  instance(Master,Instance),
  //perioidic(_,_,_),
  Instance >= I;
	
prepare(Master,Instance,Round,Decree) :-
  newBallot(Master,Instance,Round),
  storedDecreeRequest#insert(Master,Decree,From,Id);

/*
public
prepare(Agent,Instance,Round,Decree) :- 
  //paxos_global::decreeRequest#insert(Agent,Decree,From),
  storedDecreeRequest(Agent,Decree,From,Id),
	lastTried(Agent,I,Old),
  Instance >= I,
  instance#insert(Agent,Instance),
	Round := Old + 1;
*/
// 
/* uncomment for liveness!
public r1_b2
prepare(Agent,Instance,Round,Decree) :- 
  // current instance
	lastTried(Agent,Instance,Old),
  paxos_global::decreeRequestBuffer#insert(Master,Decree,Client),
	Round := Old + 1;
*/
	
r1_c
sendPrepare(@Peer,Instance,Round,Decree,Agent) :-
  prepare(@Agent,Instance,Round,Decree),
	parliament(@Agent,Peer);

/**************************************************************************************
2. Upon receipt of a NextBallot (b) message from p with b > nextBal [q], priest q
sets nextBal [q] to b and sends a LastVote (b, v) message to p, where v equals
prevVote [q]. (A NextBallot (b) message is ignored if b Â² nextBal [q].)
***************************************************************************************/


r2_a
nextBal(Agent,Instance,Round) :-
  nextBal(Agent,I,Old),
	lastPromise#insert(Agent,Instance,Round,OldRound,Decree),
  Instance >= I,
	Round > Old;


r2_b
lastPromise(Agent,Instance,Round,OldRound,OldDecree,Peer) :- 
  sendPrepare#insert(Agent,Instance,Round,Decree,Peer),
	prevVote(Agent,I,OldRound,OldDecree),
  Instance == I,
	Round >= OldRound;

lastPromise(Agent,Instance,Round,-1,"none",Peer) :- 
  sendPrepare#insert(Agent,Instance,Round,Decree,Peer),
	prevVote(Agent,I,OldRound,OldDecree),
  Instance > I,
	Round >= OldRound;


r2_c	
sendPromise(@Master,Instance,Round,OldRound,Decree,Agent) :-
	lastPromise(@Agent,Instance,Round,OldRound,Decree,Master);	


/* for quorum handling, aggregates are difficult to avoid... */
priestCnt(Master,count<*>) :- parliament(Master,Agent);
lastPromiseCnt(Master,Instance,Round,count<Agent>) :- sendPromise#insert(Master,Instance,Round,Foo,Bar,Agent);
maxPrevRound(Master,Instance,max<OldRound>) :- sendPromise(Master,Instance,Round,OldRound,Decree,Agent);
	
/**************************************************************************************
3.  After receiving a LastVote (b, v) message from every priest in some majority
set Q, where b = lastTried [p], priest p initiates a new ballot with number b,
quorum Q, and decree d, where d is chosen to satisfy B3. He then sends a
BeginBallot (b, d) message to every priest in Q.
***************************************************************************************/

//define(quorum,keys(0,1,2),{String,Integer,Integer});
define(quorum,{String,Integer,Integer});
r3_a	
quorum(Master,Instance,Round) :- 
  priestCnt(Master,Pcnt),
	lastPromiseCnt(Master,Instance,Round,Vcnt),
	Vcnt > ( Pcnt / 2 );

//quorum(M,I,R) :- quorumEvent#insert(M,I,R);
	
define(acceptRequest,keys(0,1,2),{String,Integer, Integer,String,Integer,String});

acceptRequest(Master,Instance,Round,Decree,MaxB,From) :- 
  quorum(Master,Instance,Round),
	maxPrevRound(Master,Instance,MaxB),
	lastTried(Master,Instance,Round),
  MaxB == -1,
  storedDecreeRequest(Master,Decree,From,Id),
  topOfQueue(Master,Instance,Round,Id);

/**********
r3_b
acceptRequest(Master,Instance,Round,OldDecree,MaxB,From) :- 
  quorum(Master,Instance,Round),
	maxPrevRound(Master,Instance,MaxB),
	//prepare(Master,Instace,Round,Decree),
  storedDecreeRequest(Master,Decree,From,_),
  OldDecree := "who cares?",
	//sendPromise(Master,Instance,Round,MaxB,OldDecree,Agent),
	MaxB != -1;


r3_c	
acceptRequest(Master,Instance,Round,Decree,-1,From) :- 
  quorum(Master,Instance,Round),
	maxPrevRound(Master,Instance,MaxB),
  //MaxB == Round,
	//sendPromise(Master,Instance,Round,MaxB,OldDecree,Agent),
	MaxB == -1,
  storedDecreeRequest(Master,Decree,From,Id),
  topOfQueue(Master,Id);
	//prepare(Master,Instance,Round,Decree);
******/

define(topOfQueue,keys(0),{String,Integer,Integer,Long});
watch(topOfQueue,aei);
define(tOq,keys(0),{String,Long});
define(tOs,keys(0),{String,Integer,Integer});
tOq(Master,min<Id>) :- storedDecreeRequest(Master,Decree,From,Id);
tOs(Master,Instance, max<Round>) :- sendPromise(Master,Instance,Round,MaxB,OldDecree,Agent);
topOfQueue(Master,Instance,Round,Id) :- tOq(Master,Id), tOs(Master,Instance,Round);


delete
storedDecreeRequest(Master,Decree,X,Y) :-
  acceptRequest(Master,Instance,Round,Decree,MaxB),
  storedDecreeRequest(Master,Decree,X,Y);
	
	// or in the multi-paxos case:
	/*
acceptRequest(Master,OldB+1,Decree,OldB) :- 
	storedDecreeRequest(Master,Decree,From,_),
	quorum(Master,OldB);
	*/

/*
acceptRequest(Master,Instance,-1,Decree,-1,From) :-
  storedDecreeRequest(Master,Decree,From,_),
  quorum(Master,Instance,OldB),
  //instance(Master,Instance),
  Instance > -1;
*/

watch(sendBeginRound,ae);

r3_e
sendBeginRound(@Agent,Instance,Round,Decree,Master) :- 
  acceptRequest(@Master,Instance,Round,Decree,Kind),
	parliament(@Master,Agent);

/**************************************************************************************
r4. Upon receipt of a BeginBallot (b,d) message with b = nextBal [q], priest q casts
his vote in ballot number b, sets prevVote [q] to this vote, and sends a Voted (b, q)
message to p. (A BeginBallot (b, d) message is ignored if b = nextBal [q].)
***************************************************************************************/
watch(nextBal,ae);
r4_a
accept(Agent,Instance,Round,Decree,Master) :- 
  sendBeginRound(Agent,Instance,Round,Decree,Master),
	nextBal(Agent,Instance,OldB),
	Round == OldB;

// we are locked in quorum
//accept(Agent,Instance,Round,Decree) :- 
//  sendBeginRound(Agent,Round,Decree,Master),
//  Round == -1;
	
r4_b	
prevVote(Agent,Instance,Round,Decree) :- 
  prevVote(Agent,I,Old,OD),
	lastPromise(Agent,Instance,Round,OldRound,OldDecree),
	accept#insert(Agent,Instance,Round,Decree,Master),
	Round >= Old,
  Instance >= I;

r4_c
sendAccept(@Master,Instance,Round,Decree,Agent) :- 
  accept(@Agent,Instance,Round,Decree,Master);//,
	//sendBeginRound(@Agent,Instance,Round,Decree,Master);
	
acceptCnt(Master,Instance,Round,count<Agent>) :- 
  sendAccept(Master,Instance,Round,Decree,Agent);

/**************************************************************************************
r5. If p has received a Voted (b, q) message from every priest q in Q (the quorum
for ballot number b), where b = lastTried [p], then he writes d (the decree of
that ballot) in his ledger and sends a Success (d) message to every priest.
***************************************************************************************/
r5_a	
decree(Master,Instance,Round,Decree) :- 
  lastTried(Master,Instance,Round),
	acceptCnt#insert(Master,Instance,Round,Votes),
	// this is |quorum| 
	lastPromiseCnt(Master,Instance,Round,Votes),
	acceptRequest(Master,Instance,Round,Decree);

r5_b	
success(@Agent,Instance,Round,Decree,From) :-
  decree#insert(@Master,Instance,Round,Decree),
	// this might be a mistake. 
	//storedDecreeRequest(@Master,Decree,From,_),
  acceptRequest(@Master,Instance,Round,Decree,Kind,From),
	// we interpret "every" to mean a broadcast.
	parliament(@Master,Agent);
	
	// any learner can reply to the client.or set-wise, they all can...
watch(reply,aid);
reply(@Client,Decree,"passed") :- 
  success(@Me,Instance,Round,Decree,Client);

public
paxos_global::requestStatus(Me,Client,Decree,"passed") :-
  success(Me,Instance,Round,Decree,Client);
  

//public
//paxos_global::reply(@Client,Decree,Message) :-
//  paxos_global::requestStatus(@Master,Client,Decree,Message);


/*
reply(@Client,Decree,"timed out") :-
  timeError(@Master,Client,Decree,Id);
*/
	




	/**/
//watch(tick,ie);
watch(prepare,ae);
watch(sendPrepare,ae);
watch(lastTried,ae);
watch(parliament,ae);
watch(sendPromise,ae);
watch(priestCnt,ar);
watch(lastPromiseCnt,ae);
watch(lastPromise,ae);
	/**/
watch(quorum,ae);
watch(decree,ae);
watch(acceptCnt,ae);
watch(sendAccept,ae);
watch(accept,ae);
watch(success,ae);
//watch(decreeRequest,ae);
	
watch(maxPrevRound,ae);
watch(acceptRequest,ae);
//watch(receivedPromise,ae);
	
watch(prevVote,ae);	
watch(instance,ae);
	
	
