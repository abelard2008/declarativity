program glue;

import java.util.ArrayList;
import java.util.Arrays;

watch(bfs::file,ae);
watch(bfs::fchunk,ae);

public
paxos_global::decreeRequest(Master, Decree, From) :-
    paxos_global::id(Master),
    // err
    From := Master,
    bfs::create_request_pending(Master, Id, FName, IsDir, true),
    DirStr := (IsDir ? ",d" : ",f"),
    Decree := FName + DirStr + ",i," + Id.toString();

public
paxos_global::decreeRequest(Master, Decree, From) :-
    paxos_global::id(Master),
    From := Master,
    bfs::rm_request_pending(Master, Id, FName, true),
    DirStr := ",f",
    Decree := FName + DirStr + ",d," + Id.toString();

// An insert op in the log induces a new metadata entry for a file.
// XXX: file IDs are assigned from a hash of the filename right now;
// this is obviously broken
public
bfs::file(Master, FileId, null, FName, IsDir) :-
    appView#insert(Master, _, _, _, FName, IsDir, Op, _, _),
    Op == "i",
    FileId := FName.hashCode();

// to ensure that we account for the chunkIds proposed
// by other masters
public
bfs::chunkHWM(Master, max<I>) :-
    appView(Master, _, _, _, _, _, _, I);

// or, if we are adding a chunk to a file's chunklist, we likewise need
// to pass it through paxos. (and indeed, should block the requestor, but
// this is not implemented yet XXX)
public
paxos_global::decreeRequest(Master, Decree, From) :-
    paxos_global::id(Master),
    From := Master,
    bfs_chunks::candidate_datanode#insert(Master, Id, _, FName, I, _),
    Decree := FName + ",f,u," + Id.toString() + "," + I.toString();


// Add a new chunk to the file
public
bfs::fchunk(Master, ChunkId, FileId) :-
    bfs::file(Master, FileId, _, FName, false),
    appView#insert(Master, _, _, _, FName, _, Op, _, ChunkId),
    Op == "u";

timer(periodic,physical,3000,3000,3000);

define(appView,keys(0,1,3,4),{String,String,String,Integer,String,Boolean,String,Integer,Integer});
watch(appView,ae);
public
appView(Master, From, Decree, Instance, Name, IsDir, Op, Id, I) :-
    paxos_global::requestStatus(Master, From, Decree, Instance, "passed"),
    periodic(_, _, _),
    NVL := Arrays.asList(Decree.split(",")),
    Name := (String) NVL.get(0),
    DirStr := (String) NVL.get(1),
    Op := (String) NVL.get(2),
    Id := Integer.valueOf((String) NVL.get(3)),
    I := NVL.size() < 5 ? -1 : Integer.valueOf((String) NVL.get(4)),
    IsDir := (DirStr.equals("d") ? true : false);
// XXX: array version disabled because of JOL bug
//   NVL := Decree.split(","),
//   Name := NVL[0],
//   DirStr := NVL[1],
//   Op := NVL[2],
//   Id := Integer.valueOf(NVL[3]),
//   I := NVL.length < 5 ? -1 : Integer.valueOf(NVL[4]);

public
delete
bfs::file(Master, FileId, FParent, FName, IsDir) :-
    canDelete(Master, _, _, FName),
    bfs::file(Master, FileId, FParent, FName, IsDir);

watch(bfs::create_request_done,aeid);

define(canDelete,keys(),{String,Integer,Boolean,String});
watch(canDelete,ae);

public
canDelete(Master, Id, Status, FName) :-
    bfs::rm_request_pending(Master, Id, FName, Status),
    periodic(_, _, _),
    appView(Master, _, _, _, FName, _, Op, Id),
    Op == "d";


public
green
bfs::create_request_done(Master, Id, Status) :-
    bfs::create_request_pending(Master, Id, FName, _, Status),
    appView(Master, _, _, _, FName, _, "i", Id);

public
red1
bfs::create_request_done(Master, Id, false) :-
    bfs::create_request_pending(Master, Id, FName, _, _),
    appView(Master, _, _, _, FName, _, "i", Id2),
    Id != Id2;


public
bfs::rm_request_done(Master, Id, Status) :-
    canDelete(Master, Id, Status, _);

public
red
bfs::create_request_done(Master, Id, Status) :-
    bfs::create_request_pending(Master, Id, _, _, Status),
    Status == false;

public
bfs::rm_request_done(Master, Id, Status) :-
    bfs::rm_request_pending(Master, Id, _, Status),
    Status == false;
