program glue;

import java.util.ArrayList;
import java.util.Arrays;

watch(bfs::file,ae);
watch(bfs::fchunk,ae);
watch(bfs::fpath,ae);
watch(bfs::fsize,ae);

public
paxos_global::decreeRequest(Master, Decree, From) :-
    paxos_global::id(Master),
    // err
    From := Master,
    bfs::create_request_pending(Master, Id, ParentId, FName, IsDir, true),
    DirStr := (IsDir ? ",d" : ",f"),
    Decree := FName + DirStr + ",i," + Id.toString() + ",-1," + ParentId.toString();

public
paxos_global::decreeRequest(Master, Decree, From) :-
    paxos_global::id(Master),
    From := Master,
    bfs::rm_request_pending(Master, Id, FPath),
    DirStr := ",f",
    Decree := FPath + DirStr + ",d," + Id.toString() + ",-1,-1";

// If we are adding a chunk to a file's chunklist, we likewise need to
// pass it through paxos. (and indeed, should block the requestor, but
// this is not implemented yet XXX)
public
paxos_global::decreeRequest(Master, Decree, From) :-
    paxos_global::id(Master),
    From := Master,
    bfs_chunks::candidate_datanode#insert(Master, Id, FPath, _),
    Decree := FPath + ",f,u," + Id.toString() + ",-1,-1";

define(appView,keys(0,1,2,3),{String,String,Integer,String,Boolean,Integer,String,Integer,Integer});
watch(appView,ae);
public
appView(Master, From, Instance, Name, IsDir, ParentId, Op, Id, I) :-
    paxos_global::requestStatus#insert(Master, From, Decree, Instance, "passed"),
    NVL := Arrays.asList(Decree.split(",")),
    Name := (String) NVL.get(0),
    DirStr := (String) NVL.get(1),
    Op := (String) NVL.get(2),
    Id := Integer.valueOf((String) NVL.get(3)),
    I := Integer.valueOf((String) NVL.get(4)),
    ParentId := Integer.valueOf((String) NVL.get(5)),
    IsDir := (DirStr.equals("d") ? true : false);

// An insert op in the log induces a new metadata entry for a file. We use
// the Paxos instance # as the file ID, since that will be unique and consistent
// among all the masters.
public
bfs::file(Master, FileId, ParentId, FName, IsDir) :-
    appView#insert(Master, _, Instance, FName, IsDir, ParentId, Op, _, _),
    Op == "i",
    FileId := Instance;

// Add a new chunk to the file. Use the Paxos instance # as the chunk ID.
public
bfs::fchunk(Master, ChunkId, FileId) :-
    bfs::fpath(Master, FPath, FileId),
    bfs::file(Master, FileId, _, _, false),
    appView#insert(Master, _, Instance, FPath, _, _, Op, _, _),
    Op == "u",
    ChunkId := Instance;

public
bfs::newchunk_request_done(Master, Id, NewChunkId, NodeSet) :-
    bfs_chunks::candidate_datanode(Master, Id, _, NodeSet),
    appView(Master, _, Instance, _, _, _, "u", Id, _),
    NewChunkId := Instance;


// Delete the file
// XXX: We should use FileId, not FPath
public
delete
bfs::file(Master, FileId, FParent, FName, IsDir) :-
    canDelete(Master, _, FPath),
    bfs::fpath(Master, FPath, FileId),
    bfs::file(Master, FileId, FParent, FName, IsDir);

define(canDelete,keys(),{String,Integer,String});
watch(canDelete,ae);

public
canDelete(Master, Id, FPath) :-
    appView#insert(Master, _, _, FPath, _, _, Op, Id, _),
    Op == "d";

// Use the "file" relation to construct the "fpath" relation. Note
// that these rules do NOT belong here, but we need them to be in
// the same program that deletes from bfs::file to workaround a
// JOL bug.

// Base case: root directory
public
bfs::fpath(@Master, FName, FileId) :-
    bfs::file(@Master, FileId, null, FName, true),
    FName == "/";

public
bfs::fpath(@Master, Path, FileId) :-
    bfs::file(@Master, FileId, FParent, FName, _),
    bfs::fpath(@Master, ParentPath, FParent),
    PathSep := (ParentPath == "/" ? "" : "/"),
    Path := ParentPath + PathSep + FName;

// Directories are considered to have size 0
public
bfs::fsize(@Master, FileId, FSize) :-
    bfs::file(@Master, FileId, _, _, true),
    FSize := 0L;

// Files with no chunks have size 0
public
bfs::fsize(@Master, FileId, FSize) :-
    bfs::file(@Master, FileId, _, _, false),
    notin compute_file_size(@Master, FileId, _),
    FSize := 0L;

public
bfs::fsize(@Master, FileId, FSize) :-
    bfs::file(@Master, FileId, _, _, false),
    compute_file_size(@Master, FileId, FSizeF),
    FSize := FSizeF.longValue();

define(compute_file_size, keys(0, 1), {String, Integer, Float});
public
compute_file_size(@Master, FileId, sum<LongChunkLen>) :-
    bfs::fchunk(@Master, ChunkId, FileId),
    bfs_heartbeat::chunks(@Master, _, ChunkId, ChunkLen, _),
    LongChunkLen := new Long(ChunkLen.longValue());


watch(bfs::create_request_done,aeid);

public
green
bfs::create_request_done(Master, Id, Status) :-
    bfs::create_request_pending(Master, Id, _, FName, _, Status),
    appView(Master, _, _, FName, _, _, "i", Id, _);

public
red1
bfs::create_request_done(Master, Id, false) :-
    bfs::create_request_pending(Master, Id, _, FName, _, _),
    appView(Master, _, _, FName, _, _, "i", Id2, _),
    Id != Id2;


public
bfs::rm_request_done(Master, Id) :-
    bfs::rm_request_pending(Master, Id, FPath),
    canDelete(Master, Id, FPath);

public
red
bfs::create_request_done(Master, Id, Status) :-
    bfs::create_request_pending(Master, Id, _, _, _, Status),
    Status == false;
