program bfs_heartbeat;

import bfs.Conf;
import java.lang.System;
import java.util.Set;

define(sendHeartBeat, keys(0, 1, 2), {String, String, Integer, Integer, Long, Long});


timer(clock, physical, 1000, infinity, 0);

define(ackHeartBeat, keys(0, 1, 2), {String, String, Long});
ackHeartBeat(@Dnode, Master, Id) :-
    sendHeartBeat(@Master, Dnode, _, _, _, Id),
    Id != -1L;

define(dataNodes, keys(0, 1), {String, String, Long});
dataNodes(Master, Addr, max<Tstamp>) :-
    sendHeartBeat(Master, Addr, _, _, Tstamp, _);


// we need this to ensure we become aware of truant datanodes.
delete
sendHeartBeat(Master, Host, ChunkId, Length, Tstamp, Id) :-
    sendHeartBeat(Master, Host, ChunkId, Length, Tstamp, Id),
    (System.currentTimeMillis() - Tstamp) > Conf.getHeartbeatRetention();


// Master node, Data node, ChunkId, Actual length of chunk, Timestamp
// of last update from data node
define(chunks, keys(0, 1, 2), {String, String, Integer, Integer, Long});

define(chunksEvent,  {String, String, Integer, Integer, Long});
chunks(Master, DataNode, ChunkId, Length, MaxTstamp) :-
    clock#insert(),
    sendHeartBeat(Master, DataNode, ChunkId, Length, _, _),
    (System.currentTimeMillis() - MaxTstamp) < Conf.getHeartbeatRetention(),
    dataNodes(Master, DataNode, MaxTstamp);

delete
chunks(Master, DataNode, ChunkId, Length, Ts) :-
    chunks(Master, DataNode, ChunkId, Length, Ts),
    clock#insert(),
    (System.currentTimeMillis() - Ts) > Conf.getHeartbeatRetention();

delete
dataNodes(Master, DataNode, Ts) :-
    dataNodes(Master, DataNode, Ts),
    clock#insert(),
    (System.currentTimeMillis() - Ts) > Conf.getHeartbeatRetention();

/**************************/
// maintenance functions

define(rep_factor, keys(0,1), {String, Integer, Integer});
rep_factor(Master, ChunkId, count<DataNode>) :-
    chunks(Master, DataNode, ChunkId, _, _);

define(w_rep_factor, {String, Integer, Integer});
//watch(w_rep_factor, a);
w_rep_factor(M, C, Cnt) :-
  clock#insert(),
  rep_factor(M, C, Cnt);


define(representative_datanode, keys(0,1), {String, Integer, String, Long});
//watch(representative_datanode, ae);
representative_datanode(Master, ChunkId, max<DataNode>, min<Ts>) :-
    //clock#insert(),
    chunks(Master, DataNode, ChunkId, _, Ts);

define(back_of_list, keys(0,1), {String,Integer,String});
back_of_list(Master, ChunkId, min<DataNode>) :-
    chunks(Master, DataNode, ChunkId, _, _);

timer(long_period, physical, 10000, infinity, 0);

define(to_delete, keys(0,2), {String,String,Integer});
to_delete(Master, DataNode, ChunkId) :-
    rep_factor(Master, ChunkId, Cnt),
    back_of_list(Master, ChunkId, DataNode),
    long_period(_, _, _),
    Cnt > Conf.getRepFactor();

define(newReplicaRequest, keys(0,1,4), {String, Integer, String, Integer, Long});
watch(newReplicaRequest, ae);
newReplicaRequest(Master, ChunkId, Dn, Cnt, Time) :-
    rep_factor(Master, ChunkId, Cnt),
    Time := new Long(System.currentTimeMillis()),
    representative_datanode(Master, ChunkId, Dn),
    ChunkId > 0,
    long_period#insert(_, _, _),
    Cnt < Conf.getRepFactor();

delete
newReplicaRequest(Master, ChunkId, Dn, Cnt1, Time) :-
    newReplicaRequest(Master, ChunkId, Dn, Cnt1, Time),
    clock#insert(),
    rep_factor(Master, ChunkId, Cnt2),
    Cnt2 >= Conf.getRepFactor();

define(newReplica, {String, Integer, String, Integer, Long});
newReplica(Master, ChunkId, Dn, Cnt, Time) :-
    newReplicaRequest(Master, ChunkId, Dn, Cnt, Time),
    clock#insert(),
    (System.currentTimeMillis() - Time) > new Integer(6000).longValue();

define(catch_migrate, {String, String, Integer, Integer, Set});
watch(catch_migrate,ae);
watch(bfs_global::send_migrate, ae);
public
catch_migrate(@DnWithReplica, Master, ChunkId, CurrRepCnt, Dns) :-
	bfs_global::send_migrate(DnWithReplica, @Master, ChunkId, CurrRepCnt, Dns);

// hacky constraint: one message per tick
define(send_delete, keys(0), {String, Integer, String});
send_delete(@DataNode, ChunkId, Master) :-
    to_delete(@Master, DataNode, ChunkId);

// not correct.
/*
delete
chunks(Master, DataNode, ChunkId, Length, MTS) :-
    chunks(Master, DataNode, ChunkId, Length, MTS),
    to_delete(Master, DataNode, ChunkId);
*/

