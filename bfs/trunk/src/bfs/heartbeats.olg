program bfs_heartbeat;

import bfs.Conf;
import java.lang.System;

/*****************************/
define(sendHeartBeat, keys(0, 1, 2), {String, String, Integer, Long, Long});
watch(dataNodes, ae);
watch(sendHeartBeat, ae);

timer(clock, physical, 5000, 5000, 1000);

define(ackHeartBeat,  {String, String, Long});
ackHeartBeat(@Dnode, Master, Id) :-
    sendHeartBeat(@Master, Dnode, _, _, Id),
    Id != -1L;

define(dataNodes, keys(0, 1), {String, String, Long});
public
dataNodes(Master, Host, max<Tstamp>) :-
    sendHeartBeat#insert(Master, Host, _, Tstamp, _);

// we need this to ensure we become aware of truant datanodes.
delete
sendHeartBeat(Master, Host, ChunkId, Tstamp, Id) :-
    sendHeartBeat(Master, Host, ChunkId, Tstamp, Id),
    (System.currentTimeMillis() - Tstamp) > 10000L;


// Master node, Data node, ChunkId, Timestamp of last
// update from data node
define(chunks, keys(0, 1, 2), {String, String, Integer, Long});
watch(chunks, ae);
chunks(Master, DataNode, ChunkId, MaxTstamp) :-
    sendHeartBeat(Master, DataNode, ChunkId, _, _),
    clock(_, _, _),
    dataNodes(Master, DataNode, MaxTstamp);

/*
delete
chunks(Master, DataNode, ChunkId, Ts) :-
    chunks(Master, DataNode, ChunkId, Ts),
    clock(_, _, _),
    (System.currentTimeMillis() - Ts) > 10000L;
*/


/**************************/
// maintenance functions

define(rep_factor, keys(0,1), {String, Integer, Integer});
watch(rep_factor, ae);
rep_factor(Master, ChunkId, count<DataNode>) :-
    long_period(_, _, _),
    chunks(Master, DataNode, ChunkId, _);

define(representative_datanode, keys(0,1), {String, Integer, String});
watch(representative_datanode, ae);
representative_datanode(Master, ChunkId, max<DataNode>) :-
    long_period(_, _, _),
    chunks(Master, DataNode, ChunkId, _);

define(back_of_list, keys(0,1), {String,Integer,String});
back_of_list(Master, ChunkId, min<DataNode>) :-
    long_period(_, _, _),
    chunks(Master, DataNode, ChunkId, _);

timer(long_period, physical, 10000, 100000, 0);

define(to_delete, keys(0,2), {String,String,Integer});
to_delete(Master, DataNode, ChunkId) :-
    rep_factor(Master, ChunkId, Cnt),
    back_of_list(Master, ChunkId, DataNode),
    ChunkId > 1,
    long_period(_, _, _),
    Cnt > Conf.getRepFactor();


define(newReplica, keys(0,1), {String, Integer, String});
watch(newReplica, ae);
newReplica(Master, ChunkId, Dn) :-
    rep_factor(Master, ChunkId, Cnt),
    representative_datanode(Master, ChunkId, Dn),
    ChunkId > 0,
    // explain this one: why are there zeroes in rep_factor??
    Cnt > 0,
    Dn != null,
    long_period(_, _, _),
    Cnt < Conf.getRepFactor();

// hacky constraint: one message per tick
define(send_delete, keys(0), {String, Integer, String});
send_delete(@DataNode, ChunkId, Master) :-
    to_delete(@Master, DataNode, ChunkId);

// not correct.
/*
delete
chunks(Master, DataNode, ChunkId, MTS) :-
    chunks(Master, DataNode, ChunkId, MTS),
    to_delete(Master, DataNode, ChunkId);
*/
