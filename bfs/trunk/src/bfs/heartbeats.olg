program bfs_heartbeat;

import bfs.Conf;
import java.lang.System;
import java.util.Set;

timer(clock, physical, 1000, infinity, 0);
timer(long_period, physical, 10000, infinity, 0);

define(sendHeartBeat, keys(0, 1, 2), {String, String, Integer, Integer, Long, Long});

define(ackHeartBeat, {String, String, Long});
ackHeartBeat(@Dnode, Master, Id) :-
    sendHeartBeat(@Master, Dnode, _, _, _, Id),
    Id != -1L;

delete
sendHeartBeat(Master, Host, ChunkId, Length, Tstamp, Id) :-
    long_period#insert(),
    sendHeartBeat(Master, Host, ChunkId, Length, Tstamp, Id),
    (System.currentTimeMillis() - Tstamp) > Conf.getHeartbeatRetention();

define(dataNodes, keys(0, 1), {String, String, Long});
dataNodes(Master, Addr, max<Tstamp>) :-
    sendHeartBeat(Master, Addr, _, _, Tstamp, _);

delete
dataNodes(Master, DataNode, Ts) :-
    dataNodes(Master, DataNode, Ts),
    long_period#insert(),
    (System.currentTimeMillis() - Ts) > Conf.getHeartbeatRetention();

// Master node, Data node, ChunkId, Actual length of chunk, Timestamp
// of last update from data node
define(chunks, keys(0, 1, 2), {String, String, Integer, Integer, Long});
chunks(Master, DataNode, ChunkId, Length, MaxTstamp) :-
    clock#insert(),
    ChunkId != -1,
    sendHeartBeat(Master, DataNode, ChunkId, Length, _, _),
    (System.currentTimeMillis() - MaxTstamp) <= Conf.getHeartbeatRetention(),
    dataNodes(Master, DataNode, MaxTstamp);

delete
chunks(Master, DataNode, ChunkId, Length, Ts) :-
    chunks(Master, DataNode, ChunkId, Length, Ts),
    clock#insert(),
    (System.currentTimeMillis() - Ts) > Conf.getHeartbeatRetention();

/**************************/
// maintenance functions

define(rep_factor, keys(0,1), {String, Integer, Integer});
rep_factor(Master, ChunkId, count<DataNode>) :-
    chunks(Master, DataNode, ChunkId, _, _);

define(representative_datanode, keys(0,1), {String, Integer, String});
//watch(representative_datanode, ae);
representative_datanode(Master, ChunkId, max<DataNode>) :-
    chunks(Master, DataNode, ChunkId, _, _);

define(to_delete, keys(0,1), {String, Integer, String});
to_delete(Master, ChunkId, DataNode) :-
    rep_factor(Master, ChunkId, Cnt),
    representative_datanode(Master, ChunkId, DataNode),
    long_period(_, _, _),
    Cnt > Conf.getRepFactor();

define(newReplicaRequest, keys(0,1,3), {String, Integer, Integer, Long});
watch(newReplicaRequest, ae);
newReplicaRequest(Master, ChunkId, Cnt, Time) :-
    rep_factor(Master, ChunkId, Cnt),
    Time := new Long(System.currentTimeMillis()),
    long_period#insert(_, _, _),
    Cnt < Conf.getRepFactor();

delete
newReplicaRequest(Master, ChunkId, Cnt1, Time) :-
    newReplicaRequest(Master, ChunkId, Cnt1, Time),
    clock#insert(),
    rep_factor(Master, ChunkId, Cnt2),
    Cnt2 >= Conf.getRepFactor();

define(newReplica, {String, Integer, String, Integer, Long});
newReplica(Master, ChunkId, Dn, Cnt, Time) :-
    newReplicaRequest(Master, ChunkId, Cnt, Time),
    representative_datanode(Master, ChunkId, Dn),
    clock#insert(),
    (System.currentTimeMillis() - Time) > Conf.getPropagationDelay();

define(catch_migrate, {String, String, Integer, Integer, Set});
watch(catch_migrate,ae);
watch(bfs_global::send_migrate, ae);
public
catch_migrate(@DnWithReplica, Master, ChunkId, CurrRepCnt, Dns) :-
	bfs_global::send_migrate(DnWithReplica, @Master, ChunkId, CurrRepCnt, Dns);

// hacky constraint: one message per tick
define(send_delete, keys(0), {String, Integer, String});
send_delete(@DataNode, ChunkId, Master) :-
    to_delete(@Master, ChunkId, DataNode);

// not correct.
/*
delete
chunks(Master, DataNode, ChunkId, Length, MTS) :-
    chunks(Master, DataNode, ChunkId, Length, MTS),
    to_delete(Master, ChunkId, DataNode);
*/

