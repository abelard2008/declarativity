program bfs_chunks;

import java.util.ArrayList;

define(chunkSeq, keys(0), {String, Integer});
watch(chunkSeq, ae);

/*
public
chunkSeq(Master, Top+1) :-
    bfs::self(Master),
    notin chunkSeq(Master, _),
    bfs::chunkHWM(Master, Top);
*/

// XXX: this "timer" is a hack
timer(per, physical, 1000, 1000, 1000);
public
chunkSeq(Master, 1) :-
    bfs::self(Master),
    per(_, _, _),
    notin chunkSeq(Master, _);//,
    //notin bfs::chunkHWM(Master, Top);

// if we get a "NewChunk" request for a file, create a new chunk id
public
chunkSeq(Master, I+1) :-
    chunkSeq(Master, I),
    //bfs::request#insert(Master, Id, Source, "NewChunk", _);
    newListHolder#insert(Master, Source, Id, _, I, _);


define(newListHolder,keys(0,2),{String,String,Integer,ArrayList,Integer,String});
watch(newListHolder, ae);

// We need to clone the list; otherwise the downstream list insert
// causes a cycle through candidate_datanodes
newListHolder(Master, Source, Id, NewList, NewChunkId, FName) :-
    NewList := List == null ? null : new ArrayList(List),
    candidate_datanode(Master, Id, Source, FName, NewChunkId, List),
    bfs::request(Master, Id, Source, "NewChunk", FName);

define(candidate_datanode, keys(0, 2), {String, Integer, String, String, Integer, ArrayList});
watch(candidate_datanode, ae);
public
candidate_datanode(Master, Id, Source, FName, I, generic<(new ArrayList()).add(DataNode)>) :-
    bfs::request(Master, Id, Source, "NewChunk", FName),
    chunkSeq(Master, I),
    bfs::possible_choices(Master, Cnt, DataNode, Id2),
    bfs::file(Master, _, FName),
    notin candidate_datanode(Master, Id, Source, FName, _, _);

// reuse the newchunk request dataflow to migrate bfs_heartbeat::chunks
// from one datanode to another
/*
public
candidate_datanode(Master, -1, DnWithReplica, "none", ChunkId, generic<(new ArrayList()).add(DataNode)>) :-
    bfs_heartbeat::newReplica(Master, ChunkId, DnWithReplica),
    bfs::possible_choices(Master, Cnt, DataNode, Id2),
    notin candidate_datanode(Master, Id, Source, FName, _, _);
*/
