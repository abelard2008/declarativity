program bfs;

import bfs.Conf;
import bfs.Master;
import bfs.Shell;
import java.lang.System;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import jol.types.basic.ValueList;

file(Self, "Foo", Chunks) :-
    self(Self),
    Chunks := new ArrayList(Arrays.asList({1,2,3}));

request(@Master, ReqId, Source, ReqType, Args) :-
    self(@Source),
    master_for_node(@Source, Master),
    // XXX PA
    start_request(@Source, ReqId, ReqType, Args);

public
response(@Source, Id, Master, true, Result) :-
    //request(@Master, Id, Source, "NewChunk", FName),
    // this needs to be tied into a paxos decree to enforce the ordering.
    bfs_chunks::newListHolder(@Master, Source, Id, Result, NewChunkId, FName),
    // Hack: add the new chunk id to the end of the result list
    Result.add(NewChunkId.toString());

delete
request(Master, Id, Source, "NewChunk", FName) :-
    bfs_chunks::newListHolder(Master, Source, Id, List, I, FName);


// a "NewChunk" request for a nonexistent file causes an error.
response(@Source, Id, Master, false, null) :-
    request(@Master, Id, Source, "NewChunk", FName),
    notin file(@Master, FName, _);


// If we get a "ChunkList" request for an extant file, send back its
// chunks
response(@Source, Id, Master, true, Chunks) :-
    request(@Master, Id, Source, "ChunkList", FName),
    file(@Master, FName, Chunks);

response(@Source, Id, Master, false, null) :-
    request(@Master, Id, Source, "ChunkList", FName),
    notin file(@Master, FName, _);


// this is an alias of request, for "ChunkLocation" request types, with ChunkId cast as an Integer
// I was having problems with overlog math on Longs....
define(clRequest, {String, Integer, String, String, Integer});
//watch(clRequest, ae);
clRequest(Master, ReqId, Source, "ChunkLocations", CId) :-
    request(Master, ReqId, Source, "ChunkLocations", ChunkId),
    CId := Integer.valueOf(ChunkId);

// If we get a "ChunkLocations" request for a chunk that we have knowledge
// of, return a list of the nodes holding that chunk. Otherwise, return
// an error.
define(compute_chunk_locs, keys(0, 1, 2), {String, Integer, String, ArrayList});
//watch(compute_chunk_locs, ae);
compute_chunk_locs(@Master, ReqId, Source, generic<(new ArrayList()).add(NodeAddr)>) :-
    clRequest(@Master, ReqId, Source, "ChunkLocations", ChunkId),
    bfs_heartbeat::chunks(@Master, NodeAddr, ChunkId, _);

response(@Source, Id, Master, true, NodeList) :-
    request(@Master, Id, Source, "ChunkLocations", _),
    compute_chunk_locs(@Master, Id, Source, NodeList);

response(@Source, ReqId, Master, false, null) :-
    clRequest(@Master, ReqId, Source, "ChunkLocations", ChunkId),
    notin bfs_heartbeat::chunks(@Master, _, ChunkId, _);


// If we get a "cat" request for a file that exists, send back the
// contents of the file
response(@Source, Id, Master, Success, Chunks) :-
    request(@Master, Id, Source, "Cat", FName),
    file(@Master, FName, Chunks),
    Success := true;

// If the file doesn't exist, return an error message
response(@Source, Id, Master, Success, Result) :-
    request(@Master, Id, Source, "Cat", FName),
    notin file(@Master, FName, _),
    Success := false,
    Result := new ArrayList();//"File does not exist";

define(create_request_pending, keys(0, 1), {String, Integer, String, Boolean});
watch(create_request_pending, ae);

// If we got a "create" request for a file that didn't exist,
// we need to wait until we get consensus from Paxos; then we
// can send back a positive ack.
// XXX: the use of "#insert" here is a hack
create_request_pending(@Master, Id, Source, true) :-
    request#insert(@Master, Id, Source, "Create", FName),
    notin file(@Master, FName, _);

// If we get a "create" request for a file that exists, we
// need to wait until we get consensus from Paxos; then we
// can send back a negative ack
create_request_pending(@Master, Id, Source, false) :-
    request#insert(@Master, Id, Source, "Create", FName),
    file(@Master, FName, _);

public
response(@Source, Id, Master, Success, null) :-
    create_request_done(@Master, Id, Source, Success);

// If we get an "ls" request, send back the names of all the files in
// the file system. If the file system is empty, send back an empty
// list. Note that we need to do the aggregation in a sub-rule.
define(compute_ls, keys(0, 1), {String, Integer, String, ArrayList});
watch(compute_ls, ae);
compute_ls(@Master, Id, Source, generic<(new ArrayList()).add(FName)>) :-
    request(@Master, Id, Source, "Ls", _),
    file(@Master, FName, _);

response(@Source, Id, Master, true, FileList) :-
    request(@Master, Id, Source, "Ls", _),
    compute_ls(@Master, Id, Source, FileList);

response(@Source, Id, Master, true, FileList) :-
    request(@Master, Id, Source, "Ls", _),
    notin file(@Master, _, _),
    FileList := new ArrayList();

// If we get a "FileInfo" request for an extant file, send back info
// describing the file. Otherwise, send back a nack.
response(@Source, Id, Master, true, Result) :-
    request(@Master, Id, Source, "FileInfo", FName),
    file(@Master, FName, _),
    Info := new BFSFileInfo(FName),
    Result := new ArrayList(),
    Result.add(Info);

response(@Source, Id, Master, false, Result) :-
    request(@Master, Id, Source, "FileInfo", FName),
    notin file(@Master, FName, _),
    Result := new ArrayList();


define(rm_request_pending, keys(0, 1), {String, Integer, String, Boolean});

// If we got an "rm" request and the file exists, remove it and send
// back a positive ack.
public
rm_request_pending(@Master, Id, Source, true) :-
    request(@Master, Id, Source, "Rm", FName),
    file(@Master, FName, _);

public
response(@Source, Id, Master, Success, null) :-
    rm_request_done(@Master, Id, Source, Success);

// If we got an "rm" request and the file doesn't exist, return a
// negative ack. NB: unlike in the "create" case, we don't need the
// "#insert" hack, since deletions are postponed the end of the
// fixpoint.
// XXX: we should probably synchronize with Paxos here
response(@Source, Id, Master, false, null) :-
    request(@Master, Id, Source, "Rm", FName),
    notin file(@Master, FName, _);


