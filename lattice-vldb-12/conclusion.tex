\section{Conclusion}

In this paper, we proposed \lang, a variant of Datalog that allows programs to
be written using arbitrary lattices. \lang is particularly valuable for
confluent distributed programming---by expanding the space of monotonic
programs, \lang enables more programs to be verified as confluent by the CALM
analysis.

\begin{comment}
\jmh{Some thoughts here to start.  More work this afternoon.}

Looking back:
\begin{itemize}
  \item \textbf{CALM Chills Out, and Distributed Programming wins!} The ability to prove confluence for a much broader range of constructs cracks one of the big remaining nuts in the Bloom agenda.  By marrying logic and lattices, it significantly advances the agenda delivering powerful, safe next-generation distributed languages.
  
  \item \textbf{Bloom programming is real nice now}:  The idea of using logic was to give us ``disorderly'' distributed programming a la MapReduce and SQL.  The convergent module approach went after the same goal from a more imperative perspective---``safe'' objects.  Both have their merits.  \lang's roots in logic still encourage set-wise, disorderly thinking, and the core construct of joining streams of events/messages with collections of stored facts is a nice way to capture asynchronous programming.  But stuff like counters are so very natural...
\end{itemize}

Looking forward:
\begin{itemize}
  \item \textbf{What more can we prove?}  Confluence is great when you can get it.  Checking for barrier-monotonicity is one nice thing for non-confluent designs.  But what more might we be able to do?
  \item \textbf{Efficiency and Optimization.}  Shopping carts still come in multiple flavors, but lattices start to smear the difference.  Is there hope for automatic program transformations in the \lang context that can tune an implementation optimally to workloads and elastic conditions?  What do the constraints of \lang provide that makes this question easier to tackle than a traditional imperative language?
  \item \textbf{Transactions.}  What about transactions, anyway?  If we want to provide transactional guarantees, how can \lang help---in terms of program specification, checking and optimization.
  \item \textbf{Your agenda goes here.}
\end{itemize}
\end{comment}
