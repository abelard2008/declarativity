\section{Case Study: Vector Clocks and Causal Delivery}
\label{sec:causal}
Understanding the causal relationship between events in a distributed system has
many applications.

A causal delivery protocol ensures that messages are delivered in an order that
is consistent with the ``happens before'' relation between
events~\cite{Lamport1978}. Providing a causal order over events has been
identified as a useful building block for loosely consistent distributed
applications~\cite{Lloyd2011}.

In this section, we first show how \lang can be used to build vector
clocks~\cite{Fidge1988,Mattern1989}, a common tool for tracking causal
relationships in a distributed system. We then use \lang to implement a
classical algorithm for point-to-point causal delivery~\cite{Schiper1989}. The
implementation of both protocols in \lang is concise and readable; perhaps more
significantly, both protocols are monotonic. Since this agrees with the
intuitive notion that both protocols make ``progress'' over time, this gives us
more confidence in the correctness of our designs.

\subsection{Vector clocks}
\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
class VectorClock
  include Bud

  state do
    lmap :my_vc
    lmap :next_vc
    interface input, :in_msg, [:addr, :payload, :clock]
    interface input, :out_msg, [:addr, :payload]
    interface output, :out_msg_vc, [:addr, :payload, :clock]
  end

  bootstrap do
    my_vc <= [ {ip_port => Bud::MaxLattice.new(0)} ]
  end

  bloom do
    next_vc <= my_vc
    next_vc <= out_msg { {ip_port => my_vc.at(ip_port) + 1} } (*\label{line:vc-out-increment}*)
    next_vc <= in_msg  { {ip_port => my_vc.at(ip_port) + 1} } (*\label{line:vc-in-increment}*)
    next_vc <= in_msg  {|m| m.clock} (*\label{line:vc-in-merge}*)
    my_vc <+ next_vc

    out_msg_vc <= out_msg {|m| [m.addr, m.payload, next_vc]} (*\label{line:vc-out-stamp}*)
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{Vector clocks in \lang.}
\label{fig:vector-clock-src}
\end{figure}

A \emph{vector clock} is an array containing a logical clock for each node in
the distributed system. Each node keeps a local vector clock and updates it as
it processes events; the node's vector clock reflects how up-to-date its local
knowledge is with respect to the other nodes in the system. Vector clocks can be
used to assign a partial order over the events in the system that agrees with
the causal relationship between events.

Each node $n$ initializes its vector clock to $\{n \rightarrow 0\}$. A node can
update their vector clock $v$ by following three simple rules when sending and
receiving events:
\begin{enumerate}
\item
  Before sending a message, $n$ increments $v[n]$ and includes $v$ in the
  outgoing message.
\item
  Upon receipt of a message, $n$ increments $v[n]$.
\item
  Upon receipt of a message, $n$ merges the vector clock in the message with its
  own vector clock by taking the element-wise max of the logical clock values.
\end{enumerate}

Figure~\ref{fig:vector-clock-src} contains a complete implementation of vector
clocks in \lang. A vector clock is represented as a map lattice that associates
node IDs with \texttt{lmax} values. Each \texttt{lmax} value represents a single
logical clock, which can only increase over time. \texttt{ip\_port} returns the
IP address and port number of the current \lang instance, which is used as a
node ID. Incoming messages appear in the \texttt{in\_msg} collection. Messages
that are intended to be sent begin as tuples in \texttt{out\_msg}; once a
message has been stamped with the local vector clock, it appears in
\texttt{out\_msg\_vc}.

The key vector clock logic appears in lines \ref{line:vc-out-increment},
\ref{line:vc-in-increment}, and \ref{line:vc-in-merge}: these three statements
are a direct translation of the three rules for updating a vector clock given
above. Line~\ref{line:vc-out-stamp} stamps outgoing messages with the updated
vector clock value.  Note that if multiple outgoing messages are sent in the
same timestep, they will contain the same embedded vector clock (and
\texttt{my\_vc} will only be incremented once). This is reasonable, since those
messages are concurrent.

Note that Figure~\ref{fig:vector-clock-src} is a monotonic program. Hence, its
statements can be executed in any order. The ``lattice embedding'' feature
ensures that the \texttt{out\_msg\_vc} tuple contains a single vector clock that
reflects all the updates made during the current timestep. The monotonicity of
the vector clock protocol reflects our intuition that the vector clock at a node
grows over time.% Although vector clocks could be implemented in Bloom, they
%would not be monotonic, because ...

\subsection{Causal delivery}

\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
module CausalDelivery
  state do
    channel :chn, [:@dst, :src, :ident] => [:payload, :clock, :ord_buf]

    # Local vector clock: map from node_id => lmax
    lmap :my_vc
    lmap :next_vc

    # Our knowledge of the vector clocks at other nodes:
    # map from node_id => {map from node_id => lmax}
    lmap :ord_buf

    # Received messages that haven't yet been delivered
    table :recv_buf, chn.schema
    scratch :buf_chosen, recv_buf.schema
  end

  bootstrap do
    my_vc <= [ {ip_port => Bud::MaxLattice.new(0)} ]
  end

  bloom :update_vc do
    my_vc <+ next_vc
    next_vc <= my_vc

    # On outgoing messages:
    next_vc <= pipe_in { {ip_port => my_vc.at(ip_port) + 1} }
    # On incoming messages:
    next_vc <= buf_chosen { {ip_port => my_vc.at(ip_port) + 1} }
    next_vc <= buf_chosen {|m| m.clock}
  end

  bloom :outbound_msg do
    chn <~ pipe_in {|p| [p.dst, p.src, p.ident, p.payload, next_vc, ord_buf]}
    ord_buf <+ pipe_in {|p| {p.dst => next_vc} }
  end

  bloom :inbound_msg do
    recv_buf <= chn
    buf_chosen <= recv_buf {|m| m.ord_buf.at(ip_port, Bud::MapLattice).lt_eq(my_vc).when_true { m } }
    recv_buf <- buf_chosen

    pipe_out <= buf_chosen {|m| [m.dst, m.src, m.ident, m.payload]}
    ord_buf <+ buf_chosen {|m| m.ord_buf}
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{Point-to-point causal delivery in \lang.}
\label{fig:causal-delivery-src}
\end{figure}
