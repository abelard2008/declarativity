\section{Case Study: Causal Delivery}
\label{sec:causal}

Vector clocks are a classical mechanism for recording the causal relationships
between events in a distributed system~\cite{Fidge1988,Mattern1989}. In this
section, we first show how vector clocks can be implemented in a monotonic
fashion using \lang. We then use \lang to implement a classical algorithm for
point-to-point causal message delivery~\cite{Schiper1989}. The implementation of
both protocols in \lang is concise and readable---this suggests that \lang is
suitable for typical distributed programming tasks. Perhaps more significantly,
both protocols are monotonic. This agrees with our intuition that these
protocols make ``progress'' over time, and hence gives us more confidence in the
correctness of our designs.

% Concede that confluence is not an appropriate correctness criteria

\subsection{Vector clocks}
\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
class VectorClock
  include Bud

  state do
    lmap :my_vc
    lmap :next_vc
    interface input, :in_msg, [:addr, :payload] => [:clock]
    interface input, :out_msg, [:addr, :payload]
    interface output, :out_msg_vc, [:addr, :payload] => [:clock]
  end

  bootstrap do
    my_vc <= {ip_port => Bud::MaxLattice.new(0)}
  end

  bloom do
    next_vc <= my_vc
    next_vc <= out_msg { {ip_port => my_vc.at(ip_port) + 1} } (*\label{line:vc-out-increment}*)
    next_vc <= in_msg  { {ip_port => my_vc.at(ip_port) + 1} } (*\label{line:vc-in-increment}*)
    next_vc <= in_msg  {|m| m.clock} (*\label{line:vc-in-merge}*)
    my_vc <+ next_vc

    out_msg_vc <= out_msg {|m| [m.addr, m.payload, next_vc]} (*\label{line:vc-out-stamp}*)
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{Vector clocks in \lang.}
\label{fig:vector-clock-src}
\end{figure}

A \emph{vector clock} is an array containing a logical clock for each node in
the distributed system. Each node keeps a local vector clock that it updates
when it sends and receives messages; the node's vector clock reflects how
up-to-date its local knowledge is with respect to the other nodes in the
system. Vector clocks can be used to assign a partial order over the events in
the system that agrees with the causal relationship between events.

Each node $n$ initializes its vector clock to $\{n \rightarrow 0\}$. A node
updates its vector clock $v$ by following three rules when sending and receiving
events:
\begin{compactenum}
\item
  Before sending a message, $n$ increments $v[n]$ and includes $v$ in the
  outgoing message.
\item
  Upon receipt of a message, $n$ increments $v[n]$.
\item
  Upon receipt of a message, $n$ merges the vector clock in the message with its
  own vector clock by taking the element-wise max of the logical clock values.
\end{compactenum}
Figure~\ref{fig:vector-clock-src} contains a complete implementation of vector
clocks in \lang. A vector clock is represented as a map lattice that associates
node IDs with \texttt{lmax} values. Each \texttt{lmax} represents a single
logical clock, which can only increase over time. \texttt{ip\_port} returns the
IP address and port number of the current \lang instance, which is used as a
node ID. Incoming messages appear in the \texttt{in\_msg} collection. Messages
that are intended to be sent begin as tuples in \texttt{out\_msg}; once a
message has been stamped with the local node's vector clock, it appears in
\texttt{out\_msg\_vc}.

The key logic appears in lines \ref{line:vc-out-increment},
\ref{line:vc-in-increment}, and \ref{line:vc-in-merge}: these three statements
are a direct translation of the three rules for updating a vector clock given
above. Line~\ref{line:vc-out-stamp} stamps outgoing messages with the updated
vector clock value.  Note that if multiple outgoing messages are sent in the
same \lang timestep, they will contain the same embedded vector clock (and
\texttt{my\_vc} will only be incremented once). This is reasonable, since those
messages are concurrent.

Figure~\ref{fig:vector-clock-src} is both concise and readable, and requires
only six \lang statements. This compares favorably with implementations of
vector clocks in traditional programming languages. For example, the
\texttt{VectorClock} class included with the Voldemort key-value store consists
of 216 lines of Java source code, not including whitespace or
comments~\cite{voldemort-vector-clock}.

Note that Figure~\ref{fig:vector-clock-src} is a monotonic program. Hence, its
statements can be executed in any order. The ``lattice embedding'' feature
described in Section~\ref{sec:lattice-embedding} ensures that the
\texttt{out\_msg\_vc} tuple contains a single vector clock that reflects all the
updates made during the current timestep. The monotonicity of the vector clock
protocol reflects our intuition that the vector clock at a node grows over
time.% Although vector clocks could be implemented in Bloom, they
%would not be monotonic, because ...

\subsection{Causal delivery}
A causal delivery protocol ensures that messages are delivered in an order that
is consistent with the ``happens before'' relation between
events~\cite{Lamport1978}. Providing a causal order over events has been
identified as a useful building block for loosely consistent distributed
applications~\cite{Lloyd2011}.

\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
module CausalDelivery
  state do
    channel :chn, [:@dst, :src, :ident] => [:payload, :clock, :ord_buf]

    # Local vector clock: map from node_id => lmax
    lmap :my_vc
    lmap :next_vc

    # Our knowledge of the vector clocks at other nodes:
    # map from node_id => {map from node_id => lmax}
    lmap :ord_buf

    # Received messages that haven't yet been delivered
    table :recv_buf, chn.schema
    scratch :buf_chosen, recv_buf.schema
  end

  bootstrap do
    my_vc <= {ip_port => Bud::MaxLattice.new(0)}
  end

  bloom :update_vc do
    my_vc <+ next_vc
    next_vc <= my_vc

    # On outgoing messages:
    next_vc <= pipe_in { {ip_port => my_vc.at(ip_port) + 1} }
    # On incoming messages:
    next_vc <= buf_chosen { {ip_port => my_vc.at(ip_port) + 1} }
    next_vc <= buf_chosen {|m| m.clock}
  end

  bloom :outbound_msg do
    chn <~ pipe_in {|p| [p.dst, p.src, p.ident, p.payload, next_vc, ord_buf]}
    ord_buf <+ pipe_in {|p| {p.dst => next_vc} }
  end

  bloom :inbound_msg do
    recv_buf <= chn
    buf_chosen <= recv_buf {|m| m.ord_buf.at(ip_port, Bud::MapLattice).lt_eq(my_vc).when_true { m } }
    recv_buf <- buf_chosen

    pipe_out <= buf_chosen {|m| [m.dst, m.src, m.ident, m.payload]}
    ord_buf <+ buf_chosen {|m| m.ord_buf}
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{Point-to-point causal delivery in \lang.}
\label{fig:causal-delivery-src}
\end{figure}
