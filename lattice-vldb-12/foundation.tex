\section{Adding Lattices to Datalog}
\label{sec:foundation}

\subsection{Definitions}
\label{sec:found-defn}
A \emph{join semi-lattice} is a pair $\langle S, \lor \rangle$, where $S$ is a
poset and $\lor$ is a binary operator (called the ``join'' or ``least upper
bound'') that is associative, commutative, and idempotent. For all $x, y \in S$,
$x \lor y = z$, where $x \leq_S z, y \leq_S z$, and there is no $z' \in S$ such
that $z' <_S z$. For brevity, we use the term ``lattice'' to mean ``join
semi-lattice'' in the rest of this paper.
% XXX: talk about least element?

% XXX: note that algebraic properties that must be satisfied by morphisms and
% monotone functions
% XXX: mention that morphisms must be distributive with respect to the lub of
% their domain, whereas monotone functions don't need to be?
A \emph{morphism} from lattice $\langle X, \lor_X\rangle$ to lattice $\langle Y,
\lor_Y\rangle$ is a function $f$ such that, $\forall a,b \in X: f(a \lor_X b) =
f(a) \lor_Y f(b)$. That is, $f$ allows $X$ lattice elements to be converted into
$Y$ lattice elements in a way that preserves the lattice properties.

An \emph{order-preserving map} (OPM) from poset $S$ to poset $T$ is a function
$g$ such that $\forall a,b \in S: a \leq_S b \Rightarrow g(a) \leq_T
g(b)$.\footnote{Order-preserving maps are also called \emph{monotone functions}.
  We avoid that term in this paper to avoid confusion with the normal meaning of
  monotonicity in Datalog.} That is, $g$ maps elements of $S$ to elements of $T$
in a manner that is consistent with the partial orders of both sets. Note that
morphisms are OPMs but the converse is not true in general.

\subsection{Fixed point and minimal model}

\subsection{Evaluation}

TODO: delta-driven evaluation. Intuitively, you can evaluate programs involving
morphisms more efficiently than those involving order-preserving maps, because
the latter don't admit delta-driven evaluation. Need to work out the details; if
we don't have anything interesting to say here, skip it.

\subsection{Confluence in \baselang}

TODO: presumably this would be too complicated, since it would require
introducing Dedalus?
