\section{Adding Lattices to Datalog}
\label{sec:foundation}

\subsection{Definitions}
\label{sec:found-defn}
A \emph{join semi-lattice} is a pair $\langle S, \lor \rangle$, where $S$ is a
poset and $\lor$ is a binary operator (called the ``join'' or ``least upper
bound'') that is associative, commutative, and idempotent. For all $x, y \in S$,
$x \lor y = z$, where $x \leq_S z, y \leq_S z$, and there is no $z' \in S$ such
that $z' <_S z$. For brevity, we use the term ``lattice'' to mean ``join
semi-lattice'' in the rest of this paper.
% XXX: talk about least element?

A \emph{morphism} from lattice $\langle X, \lor_X\rangle$ to lattice $\langle Y,
\lor_Y\rangle$ is a function $f$ such that, $\forall a,b \in X: f(a \lor_X b) =
f(a) \lor_Y f(b)$. That is, $f$ allows $X$ lattice values to be converted into
$Y$ lattice values in a way that preserves the lattice properties.

A \emph{monotone function} (also called an ``order-preserving map'') from poset
$S$ to poset $T$ is a function $g$ such that $\forall a,b \in S: a \leq_S b
\Rightarrow g(a) \leq_T g(b)$. That is, $g$ maps elements of $S$ to elements of
$T$ in a manner that is consistent with the partial orders of both sets. Note
that morphisms are monotone functions but the converse is not true in general.

\subsection{Fixed point and minimal model}

TODO: introduce \baselang, and give a model-theoretic semantics for it ($\to$
``what does it mean to compute a fixpoint of a \baselang program?'')

\subsection{\baselang generalizes Dedalus}

TODO: show that \baselang generalizes Datalog (worth doing?)

\subsection{Evaluation}

TODO: delta-driven evaluation. Intuitively, you can evaluate programs involving
morphisms more efficiently than those involving order-preserving maps, because
the latter don't admit delta-driven evaluation. Need to work out the details; if
we don't have anything interesting to say here, skip it.

\subsection{Confluence in \baselang}

TODO: presumably this would be too complicated, since it would require
introducing Dedalus?
