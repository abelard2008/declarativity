\section{Related Work}
\label{sec:relwork}

% XXX: intro?

\subsection{Semantics-based concurrency control}
In the absence of semantic knowledge about transactions, serializability is the
main correctness criteria for concurrency control schemes. However, ensuring
serializability can be prohibitively expensive, for instance when transactions
are long-running or the nodes of a distributed database are connected via an
unreliable network. Thus, many schemes have been proposed to allow
non-serializable transaction schedules that preserve some \emph{semantic} notion
of correctness. In particular, several schemes have been proposed to allow users
to specify that certain operations can safely be commuted with other operations;
this enlarges the space of allowed transaction schedules, increasing the
potential for concurrency~\cite{Farrag1989,Garcia-Molina1983,Weihl1988}.

% TODO: do we need to cite all 3 papers?
%       the weihl paper claims to explicitly only allow serializable schedules
%       do we need to say why our stuff is different?

O'Neil describes a method for supporting for ``escrow'' transactions, which
designate certain operations that can be commuted subject to a resource
bound~\cite{O'Neil1986}. For example, credits and debits to a bank account might
only commute with one another if the bank account balance can be guaranteed to
be non-negative.

% XXX: do we need to say how our stuff compares to escrow?

% TODO: cite Helland and Campbell on the value of ACID 2.0 operations

\subsection{Commutativity in distributed systems}

% CRDTs, Wuu & Bernstein
% Operational transformations
% Merge functions in KVS

\subsection{Non-monotonicity in deductive databases}
Adding non-monotonic operators (e.g., aggregation and negation) to Datalog
increases the expressiveness of the language but introduces significant
complexities: care must be taken to ensure that the resulting language has a
semantics that is well-defined, intuitive to the user, and amenable to efficient
evaluation. A straightforward approach is to disallow recursion through
aggregation or negation, which admits only the class of so-called ``stratified
programs''~\cite{Apt1988}. Many attempts have been made to assign a semantics to
larger classes of programs (e.g.,~\cite{Gelfond1988,Ross1990,VanGelder1991}).

% XXX: cite Van Gelder's "foundations of agg" paper
The observation that many uses of aggregation and negation have a ``monotonic''
flavor has been made before. Ross and Sagiv study a class of programs that
include ``monotonic'' aggregates~\cite{Ross1992}. They propose a model theoretic
semantics for this class of programs that is similar to our semantics for
\baselang in Section~\ref{sec:foundation}. Our work differs from Ross and
Sagiv's in several respects: most notably, they use lattices as a way to
characterize the monotonicity of classes of Datalog programs, whereas we propose
\lang as a practical programming language. Accordingly, Ross and Sagiv restrict
the usage of monotone aggregates to a single ``cost'' argument in certain
predicates, do not allow user-defined aggregates, and do not propose a framework
for arbitrary lattices to be composed safely.

K\"{o}stler et al.\ consider Datalog extended with subsumption relations, which
allows the user to indicate that certain deductions should be ``preferred'' over
others~\cite{Kostler1995}. These preferences must form a lattice; K\"{o}stler et
al.\ then propose a model-theoretic semantics and evaluation scheme based on the
partial order of the lattice. Like Ross and Sagiv, this work shares some
technical similarities with this paper, but differs in its goals and problem
domain: K\"{o}stler et al.\ use subsumption to add semantic knowledge to graph
traversal and heuristic search programs, but do not propose a general-purpose
programming framework.

Zaniolo and Wang identify a class of ``monotone aggregates'' as part of their
work on supporting advanced user-defined aggregates in the $\mathcal{LDL}$++
system~\cite{Zaniolo1999}. Like us, they observe that aggregates with monotone
behavior can easily be supported without restriction in a traditional Datalog
system based on semi-naive fixpoint. Their characterization of monotone
aggregates is different than ours, they do not distinguish between morphisms and
order-preserving maps, and do not consider distribution or confluence---in fact,
supporting order-dependent aggregates is an explicit goal of their work, whereas
we seek to ensure that programs are confluent in the face of message reordering.
