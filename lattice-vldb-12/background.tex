\section{Background}
\label{sec:background}

% XXX: should this be a distributed example?
\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
class ShortestPaths
  include Bud

  state do
    table :link, [:from, :to] => [:cost] (*\label{line:spaths-ddl}*)
    scratch :path, [:from, :to, :next_hop, :cost]
    scratch :min_cost, [:from, :to] => [:cost]
  end

  bloom do
    path <= link {|l| [l.from, l.to, l.to, l.cost]} (*\label{line:spaths-proj}*)
    path <= (link*path).pairs(:to => :from) do |l,p| (*\label{line:spaths-join-start}*)
      [l.from, p.to, l.to, l.cost + p.cost]
    end (*\label{line:spaths-join-end}*)

    min_cost <= path.group([:from, :to], min(:cost)) (*\label{line:spaths-group}*)
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{All-pairs shortest paths of a directed graph in Bloom.}
\label{fig:bloom-spaths}
\end{figure}

In this section, we briefly review the Bloom programming language and the CALM
program analysis technique.  We highlight a simple distributed protocol for
which the CALM analysis produces unsatisfactory results.

\subsection{Bloom}
\label{sec:bg-bloom}

Bloom is a Datalog-based domain-specific language (DSL) designed for distributed
programming~\cite{Alvaro2011,bloom}. The state of a Bloom program is represented
using \emph{collections}---unordered sets of tuples, akin to relations in
Datalog. Computation is expressed as a bundle of declarative \emph{statements}.
An instance of a Bloom program performs computation by evaluating its statements
over the contents of its local database. Bloom instances communicate via
asynchronous messaging, as described further below.

An instance of a Bloom program proceeds through a series of
\emph{timesteps}.\footnote{Note that there is a precise declarative semantics
  for the interpretation of Bloom programs~\cite{dedalus}, but we describe
  Bloom's semantics operationally for the sake of exposition.} At the beginning
of a timestep, inbound events (e.g., network messages) are received and
represented as facts in collections. The program's statements are evaluated over
local state to compute all the additional facts that can be derived from the
current collection contents. In some cases (described below), deriving a fact
into a collection results in emitting an outbound event such as a network
message for another Bloom instance; those outbound events are emitted at the end
of the timestep.

The initial implementation of Bloom, called \emph{Bud}, allows Bloom logic to
be embedded inside Ruby programs: observe that Figure~\ref{fig:bloom-spaths} is
an annotated Ruby class. A small amount of imperative Ruby code is needed to
instantiate the Bloom program and begin executing it; more details are available
on the Bloom language website~\cite{bloom}.

\subsubsection{Collections}
\begin{table}[t]
\begin{tabular}{|l|p{2.32in}|}
\hline
\textbf{Name} & \textbf{Behavior }\\
\hline
\texttt{table} & Persistent storage.\\
\texttt{scratch} & Transient storage.\\
\texttt{channel} & Asynchronous communication. A fact derived into a \texttt{channel} appears in the
database of a remote Bloom instance at a non-deterministic future time.\\
\texttt{periodic} & Interface to the system clock.\\
\texttt{interface} & Interface point between software modules.\\
\hline
\end{tabular}
\caption{Bloom collection types.}
\label{tbl:bloom-collections}
\end{table}

The state of a Bloom program is represented using \emph{collections}: unordered
sets of tuples, akin to relations in Datalog. Bloom adopts the Ruby type system
rather than inventing its own; hence, Bloom tuples are just Ruby arrays that
contain Ruby values (e.g., strings, integers and booleans). Each collection has
a \emph{schema}, which declares the structure (column names) of the tuples in
the collection. A subset of the columns in a collection form its \emph{key}: as
in SQL, the key columns functionally determine the remaining columns. For
example, line~\ref{line:spaths-ddl} of Figure~\ref{fig:bloom-spaths} declares a
collection named \texttt{link} with three columns, two of which form the
collection's key.

Bloom provides five collection types to represent different kinds of state
(Table~\ref{tbl:bloom-collections}). A \texttt{table} stores persistent data: if
a fact appears in a table, it remains in the table in future timesteps (until it
is explicitly removed). A \texttt{scratch} contains transient data---the content
of scratch collections is emptied at the start of each timestep. Scratches are
akin to SQL views: they are often useful as a way to name intermediate results
or as a ``macro'' construct to enable code reuse. The \texttt{channel}
collection type enables communication between Bloom instances. The schema of a
channel has a distinguished \emph{location specifier} column (prefixed with
``\texttt{@}''); when a fact is derived for a channel collection, it appears in
the database of the Bloom instance at the address given by the location
specifier. The \texttt{periodic} and \texttt{interface} collection types are not
relevant for this paper.

\subsubsection{Statements}
\begin{table}
\begin{tabular}{|c|l|p{1.85in}|}
\hline
\textbf{Op} & \textbf{Name} & \textbf{Meaning} \\
\hline
\verb|<=| & \emph{merge} & lhs includes the content of rhs in the
current timestep \\
\hline
\verb|<+| & \emph{deferred merge} & lhs will include the content of rhs in the
next timestep \\
\hline
\verb|<-| & \emph{deferred delete} & lhs will not include the content of the rhs
in the next timestep \\
\hline
\verb|<|$\sim$ & \emph{async merge} & (remote) lhs will include the content of the
rhs at some non-deterministic future timestep\\
\hline
\end{tabular}
\caption{Bloom merge operators.}
\label{tbl:bloom-ops}
\end{table}

Each statement has one or more input collections and a single output
collection. A statement defines how the contents of the input collections should
be transformed before being included (via set union) in the output
collection. Each statement takes the form: \\ \noindent
\mbox{\hspace{0.25in}\emph{$<$collection-variable$>$ $<$merge-op$>$
    $<$collection-expression$>$}}\\ \noindent The left-hand side (lhs) of the
statement is the name of the output collection and the right-hand side (rhs) is
an expression that produces a collection. Bloom allows the usual relational
operators to be used on the rhs (selection, projection, join, grouping,
aggregation, and negation), although it adopts a syntax intended to be more
familiar to imperative programmers. In Figure~\ref{fig:bloom-spaths},
line~\ref{line:spaths-proj} contains projection,
lines~\ref{line:spaths-join-start}--\ref{line:spaths-join-end} perform a join
between \texttt{link} and \texttt{path} using the join predicate
\verb+link.to = path.from+, and line~\ref{line:spaths-group} demonstrates
grouping and aggregation.

The ``merge operator'' defines \emph{when} the rhs will be merged into the lhs
(Table~\ref{tbl:bloom-ops}). The \verb|<=| operator performs normal logical
deduction: that is, the lhs and rhs are true at the ``same'' timestep. The
\verb|<+| and \verb|<-| operators indicate that facts will be added or removed,
respectively, from the lhs collection at the beginning of the next timestep. The
\verb+<~+ operator specifies that the rhs will be merged into the lhs collection
at some non-deterministic future time. The lhs of a \verb+<~+ rule must be a
channel; the \verb+<~+ operator models asynchronous messaging.

% XXX: does this need to be said?
Bloom allows recursive statements---i.e., the rhs of a statement can reference
the statement's lhs collection, either directly or indirectly. As in Datalog,
certain constraints must be adopted to ensure that programs with recursive
statements have a sensible interpretation. For deductive rules (\verb+<=+
operator), we require that programs be \emph{syntactically
  stratified}~\cite{Apt1988}: cycles through negation or aggregation are not
allowed~\cite{dedalus}.

\subsection{CALM Analysis}
\label{sec:bg-calm}

Work on deductive databases has long drawn a distinction between
\emph{monotonic} and \emph{non-monotonic} logic programs. Intuitively, a
monotonic program only computes more results over time---that is, it will never
``retract'' a previous conclusion in the face of new information. A simple
conservative test for monotonicity is based on the syntax of the program: the
selection, projection, and join operators are monotonic, while aggregation and
negation are not.

The CALM analysis connects the theory of monotonic logic with the practical
problem of distributed consistency~\cite{Alvaro2011}. In particular, it has been
proven that all monotonic programs are \emph{confluent}: that is, given the same
input, XXX~\cite{Ameloot2011}. Hence, monotonic programs are a useful building
block for loosely consistent distributed programming.

This result naturally suggests a program analysis technique that we have
implemented in Bloom. According to the CALM principle, distributed inconsistency
may occur when the output of an asynchronously derived value is consumed by a
non-monotonic operator. This is problematic, because asynchronous messaging
results in non-deterministic arrival order, and a non-monotonic operator may be
order sensitive. Our analysis tool flags these program locations as \emph{points
  of order}. To achieve consistency, the programmer either needs to rewrite
their program to introduce more monotonic logic, or introduce a coordination
protocol to ensure that a consistent ordering is agreed upon.

\subsubsection{Limitations of set monotonicity}
Unfortunately, the original formulation of the CALM principle considered only
programs that compute more facts over time---that is, programs whose output
\emph{sets} grow over time. Many distributed protocols make \emph{progress} over
time but this notion of progress is often difficult to represent as a growing
set of facts. For example, consider the program in
Figure~\ref{fig:bloom-nm-quorum}. This program receives votes from a client
program (not shown) via the \texttt{vote\_chn} channel. Once at least
\texttt{QUORUM\_SIZE} votes have been received, a message is sent to another
remote node to indicate that a quorum has been reached. This program resembles a
``quorum vote'' subroutine that might be required for an implementation of
Paxos~\cite{Lamport1998} or a quorum replication protocol~\cite{Gifford1979}.

It is easy to see that this program makes progress in a monotonic fashion: the
set of received votes grows and the count of the \texttt{votes} collection can
only increase, so once a quorum has been reached it will never be
retracted. Unfortunately, the current CALM analysis would regard this program as
non-monotonic because it contains aggregation (the grouping operation on
line~\ref{line:bloom-nm-quorum}).

To solve this problem, we need to introduce a notion of program outputs that
``grow over time'' according to a partial order that is not set containment. We
do this via lattices, as we describe in the next section.

\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
QUORUM_SIZE = 5
RESULT_ADDR = "example.org"

class QuorumVote
  include Bud

  state do
    channel :vote_chn, [:@addr, :voter_id]
    channel :result_chn, [:@addr]
    table   :votes, [:voter_id]
    scratch :cnt, [] => [:cnt]
  end

  bloom do
    votes      <= vote_chn {|v| v.voter_id}
    cnt        <= votes.group(nil, count(:voter_id)) (*\label{line:bloom-nm-quorum}*)
    result_chn <~ cnt {|c| [RESULT_ADDR] if c >= QUORUM_SIZE}
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{A non-monotonic Bloom program that waits for a quorum of votes to be received.}
\label{fig:bloom-nm-quorum}
\end{figure}
