\section{Background}
\label{sec:background}

\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
class AllPaths
  include Bud

  state do
    table :link, [:from, :to] => [:cost]
    scratch :path, [:from, :to, :next_hop, :cost]
    scratch :min_cost, [:from, :to] => [:next, :cost]
  end

  bloom do
    path <= link {|l| [l.from, l.to, l.to, l.cost]} (*\label{line:spaths-proj}*)
    path <= (link*path).pairs(:to => :from) do |l,p| (*\label{line:spaths-join-start}*)
      [l.from, p.to, l.to, l.cost + p.cost]
    end (*\label{line:spaths-join-end}*)

    min_cost <= path.group([:from, :to], min(:cost)) (*\label{line:spaths-group}*)
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{A Bloom program to compute the transitive closure of the
  \emph{link} relation.}
\label{fig:bloom-spaths}
\end{figure}

In this section, we briefly review the Bloom programming language and the CALM
program analysis technique.  We highlight a simple distributed protocol for
which the CALM analysis produces unsatisfactory results.

\subsection{Bloom}
\label{sec:bg-bloom}

Bloom is a Datalog-based domain-specific language (DSL) for distributed
programming~\cite{Alvaro2011,bloom}. The current prototype implementation,
\emph{Bud}, allows Bloom logic to be embedded within Ruby
programs. Figure~\ref{fig:bloom-spaths} contains an example Bloom program.

The state of a Bloom program is representing using \emph{collections}: unordered
sets of tuples, akin to relations in Datalog. Each collection has a
\emph{schema}, which declares the structure (column names) of the tuples in the
collection. A subset of the columns in a collection form its \emph{key}: as in
SQL, the key columns of a collection functionally determine the remaining
columns. Bloom adopts the Ruby type system rather than inventing its own; hence,
Bloom tuples are just Ruby arrays that contain Ruby values (e.g., strings,
integers and booleans). Bloom provides five builtin collection types to
represent different kinds of state (Table~\ref{tbl:bloom-collections}).

In Bloom, computation is expressed as a bundle of declarative
\emph{statements}. Each statement has one or more input collections and a single
output collection. A statement defines how the contents of the input
collections should be transformed before being included (via set union) in the
output collection. Each statement takes the form: \\ \noindent
\mbox{\hspace{0.25in}\emph{$<$collection-variable$>$ $<$op$>$
    $<$collection-expression$>$}}\\ \noindent
The left-hand side (lhs) of the statement is the name of the output collection
and the right-hand side (rhs) is an expression that produces a collection. Bloom
allows the usual relational operators to be used on the rhs (select, project,
join, grouping, aggregation, and negation), although it adopts a syntax intended
to be more familiar to imperative programmers. In Figure~\ref{fig:bloom-spaths},
line~\ref{line:spaths-proj} contains projection,
lines~\ref{line:spaths-join-start}--\ref{line:spaths-join-end} perform a join
between \texttt{link} and \texttt{path}, and line~\ref{line:spaths-group}
demonstrates grouping and aggregation. Note that, as in Datalog, Bloom allows
statements to be recursive (either directly or
indirectly). % Talk about stratification?

\begin{table}
\begin{tabular}{|c|l|}
\end{tabular}
\caption{Bloom collection types.}
\label{tbl:bloom-collections}
\end{table}

\begin{table}
\begin{tabular}{|c|l|p{1.85in}|}
\hline
\textbf{Op} & \textbf{Name} & \textbf{Meaning} \\
\hline
\verb|<=| & \emph{merge} & lhs includes the content of rhs in the
current timestep \\
\hline
\verb|<+| & \emph{deferred merge} & lhs will include the content of rhs in the
next timestep \\
\hline
\verb|<-| & \emph{deferred delete} & lhs will not include the content of the rhs
in the next timestep \\
\hline
\verb|<|$\sim$ & \emph{async merge} & (remote) lhs will include the content of the
rhs at some non-deterministic future timestep\\
\hline
\end{tabular}
\caption{Bloom operators.}
\label{tbl:bloom-ops}
\end{table}

\subsection{CALM Analysis}
\label{sec:bg-calm}

\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
\end{lstlisting}
\end{scriptsize}
\caption{A non-monotonic Bloom program that waits for a quorum of votes to be received.}
\label{fig:bloom-nm-quorum}
\end{figure}
