\section{Introduction}
\label{sec:intro}
Although distributed programming has become an essential and commonplace task,
it remains very challenging for most developers to write correct distributed
programs. The inherent difficulties of distributed computing---concurrency,
asynchrony, and partial failure---have been exacerbated by the scale at which
modern distributed systems must operate.

To allow their programs to gracefully tolerate network partitions and
unpredictable messaging delays, many system designers have chosen to give up
sequential consistency because it typically requires the use of heavyweight
distributed commit and consensus protocols. Instead, many modern systems aim
instead to provide a weaker degree of consistency, such as eventual
consistency~\cite{Terry1995} or causal consistency~\cite{Lloyd2011}.

We recently proposed the CALM theorem, which links distributed
\emph{consistency} with \emph{logical
  monotonicity}~\cite{Alvaro2011,Hellerstein2010}. Intuitively, a monotonic
program computes more information over time---it never ``retracts'' an earlier
conclusion in the face of new information. Hence, a monotonic program can be
executed in a coordination-free manner and still reach a consistent state---all
monotonic programs are eventually consistent~\cite{Ameloot2011}.  Since
syntactic monotonicity of a Datalog program is straightforward to determine, the
CALM theorem provides the basis for a simple analysis technique for loosely
consistent distributed programs~\cite{Alvaro2011}. The CALM analysis is realized
as part of Bloom, a Datalog-based DSL for distributed programming~\cite{bloom}.

Our initial formulation of Bloom and CALM only considered programs that compute
sets of facts that grow over time (``set monotonicity''); that is, ``growth'' is
defined according to set containment. This limits the usefulness of the CALM
analysis because it makes several common distributed programming idioms
non-monotonic. In particular, threshold tests over aggregate values (e.g.,
``$\textrm{max}(S) > k$'') and upward-moving counters are both non-monotonic
under set monotonicity.

In this paper, we extend our previous results by using a more general notion of
monotonicity. Instead of only allowing growth according to the set containment
partial order, we allow any user-defined partial order to be used. We do this by
introducing \emph{complete join semi-lattices} as a programming construct. We
give a formal definition of this construct below, but the intuition is that the
user must supply a commutative, idempotent merge function (``least upper
bound'') that takes two input values and produces an output value that is not
smaller than either of the input values (according to the user's partial
order). This generalizes Bloom (and traditional Datalog), which assumes a fixed
merge function (set union) and partial order (set containment).

% Explain how lattices generalize monotonic datalog
In this paper, we make the following contributions:
\begin{enumerate}
\item
  We present \baselang, a variant of Datalog that is defined over lattices. We
  define a model-theoretic semantics for \baselang, and show that \baselang
  generalizes Datalog.

\item
  We introduce \lang, an extension of Bloom that supports lattices. We introduce
  the syntax and semantics of \lang and show how to extend the standard
  semi-na\"{i}ve Datalog evaluation scheme~\cite{Balbin1987} to support both
  lattices and traditional database relations. We detail the builtin lattice
  types provided by \lang, describe how developers can define custom lattice
  types, and illustrate how more complex programs can be constructed via the
  composition of different lattices.

\item
  Finally, we validate the effectiveness of lattices with two detailed case
  studies. We revisit the simple e-commerce scenario presented in Alvaro et.\
  al, in which clients interact with a replicated shopping cart
  service~\cite{Alvaro2011}. We use lattices to allow a more flexible and
  compact representation of shopping cart state. Second, we show how lattices
  can make the ``checkout'' aggregation operation monotonic.

  We also use lattices to implement a classical distributed protocol for
  point-to-point causal delivery~\cite{Schiper1989}. We show that causal
  delivery is monotonic and detail how domain-specific correctness criteria can
  be proven more easily with the aid of the lattice properties.
\end{enumerate}
