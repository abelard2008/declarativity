\section{Introduction}
\label{sec:intro}
Although distributed programming has become an essential and commonplace task,
it remains very challenging for most developers to write correct distributed
programs. The inherent difficulties of distributed computing---concurrency,
asynchrony, and partial failure---have been exacerbated by the scale at which
modern distributed systems must operate.

To allow their programs to gracefully tolerate network partitions and
unpredictable messaging delays, many system designers have chosen to give up
sequential consistency because it typically requires the use of heavyweight
distributed commit and consensus protocols. Instead, many modern systems aim
instead to provide a weaker degree of consistency, such as eventual
consistency~\cite{Terry1995} or causal consistency~\cite{Lloyd2011}.

We recently proposed the CALM theorem, which links distributed
\emph{consistency} with \emph{logical
  monotonicity}~\cite{Alvaro2011,Hellerstein2010}. Intuitively, a monotonic
program computes a set of facts that only grows over time: it never ``retracts''
an earlier conclusion in the face of new information. Hence, a monotonic program
can be executed in a coordination-free manner and still reach a consistent
state---all monotonic programs are ``eventually
consistent''~\cite{Ameloot2011}. Since syntactic monotonicity of a Datalog
program is straightforward to determine, the CALM theorem provides the basis for
a simple analysis technique for loosely consistent distributed
programs~\cite{Alvaro2011}. The CALM analysis is realized as part of Bloom, a
Datalog-based DSL for distributed programming~\cite{bloom}.

Our initial formulation of Bloom and CALM only considered programs that compute
sets of facts that grow over time (``set monotonicity''). This limits the
usefulness of the CALM analysis because it makes several common distributed
programming idioms non-monotonic. In particular, threshold tests
(``$\textrm{max}(S) > k$'') and upward-moving counters are both non-monotonic
under set monotonicity.

In this paper, we extend our previous results by using a more general notion of
monotonicity. We do this by introducing \emph{join semi-lattices} as a
programming construct. A join semi-lattice consists of a partial order $\le$
over a domain $S$ and a least upper bound (LUB) function $f$. For any two
elements $a,b \in S$, $f(a, b) = c$, where $a \le c$ and $b \le c$. For the set
lattice, $f$ is set union and $\le$ is set containment.

% Explain how lattices generalize monotonic datalog
In this paper, we extend our previous results in several directions:
\begin{enumerate}
\item
  We review the algebraic properties of lattices and present \baselang, a
  variant of Datalog that is defined over lattices. We show that \baselang
  generalizes Datalog.

\item
  We introduce \lang, an extension of Bloom that supports lattices. We introduce
  the syntax and semantics of \lang and describe how we extended the standard
  semi-na\"{i}ve Datalog evaluation scheme~\cite{Balbin1987} to support both
  lattices and traditional database relations. We describe the builtin lattice
  types provided by \lang, describe how developers can define custom lattices,
  and illustrate how to compose lattices into more complex behaviors.

\item
  Finally, we validate the effectiveness of lattices with two detailed case
  studies. We revisit the simple e-commerce scenario presented in Alvaro et.\
  al, in which clients interact with a replicated shopping cart
  service~\cite{Alvaro2011}. We use lattices to allow a more flexible and
  compact representation of shopping cart state. Second, we show how lattices
  can make the ``checkout'' aggregation operation monotonic.

  We also use lattices to implement a classical distributed protocol for
  point-to-point causal delivery~\cite{Schiper1989}. We show that causal
  delivery is monotonic and detail how domain-specific correctness criteria can
  be proven more easily with the aid of the lattice properties.
\end{enumerate}
