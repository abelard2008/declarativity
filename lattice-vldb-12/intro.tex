\section{Introduction}
\label{sec:intro}
Although distributed programming has become an essential and commonplace task,
it remains very challenging for most developers to write correct distributed
programs. The inherent difficulties of distributed computing---concurrency,
asynchrony, and partial failure---have been exacerbated by the scale at which
modern distributed systems must operate.

To allow their programs to gracefully tolerate network partitions and
unpredictable messaging delays, many system designers have chosen to give up
sequential consistency because it typically requires the use of heavyweight
distributed commit and consensus protocols. Instead, many modern systems aim
instead to provide a weaker degree of consistency, such as eventual
consistency~\cite{Terry1995,vogels} or causal consistency~\cite{Lloyd2011}.



In this paper, we extend our previous results by using a more general notion of
monotonicity. Instead of only allowing growth according to the set containment
partial order, we allow any user-defined partial order to be used. We do this by
introducing \emph{join semi-lattices} as a programming construct. We give a
formal definition of this construct below, but the intuition is that the user
must supply a commutative, idempotent merge function (``least upper bound'')
that takes two input values and produces an output value that is not smaller
than either of the input values (according to the user's partial order). This
generalizes Bloom (and traditional Datalog), which assumes a fixed merge
function (set union) and partial order (set containment).
% Relate user-defined merge functions to merge functions in other contexts?
% (e.g., key-value store, COPS, Piccolo)

% Explain how lattices generalize monotonic datalog
In this paper, we make the following contributions:
\begin{enumerate}
% \item
%   We present \baselang, a variant of Datalog that is defined over lattices. We
%   define a model-theoretic semantics for \baselang, and show that \baselang
%   generalizes Datalog.

\item
  We introduce \lang, an extension of Bloom that supports lattices. We describe
  how to express computation over lattices, detail the builtin lattice types
  provided by \lang, and illustrate how developers can define new lattice
  types.

\item 
  We generalize the CALM analysis to programs that contain both lattices and
  set-oriented collections, and show how lattices can be used to prove the
  confluence of several common distributed design patterns that were regarded as
  non-monotonic in Bloom. % XXX: revisit this

\item
  We show how to extend the standard Datalog semi-naive evaluation
  scheme~\cite{Balbin1987} to support both lattices and traditional database
  relations. We also describe how an existing Datalog engine can be extended to
  support lattices with relatively minor changes.

\item
  Finally, we validate the effectiveness of lattices with two case studies. We
  revisit the simple e-commerce scenario presented in Alvaro et al., in which
  clients interact with a replicated shopping cart service~\cite{Alvaro2011}. We
  use lattices to allow a more flexible and compact representation of shopping
  cart state. Second, we show how lattices can make the ``checkout'' aggregation
  operation monotonic.

  We also use lattices to implement a classical distributed protocol for
  point-to-point causal delivery~\cite{Schiper1989}. We show that causal
  delivery is monotonic and detail how domain-specific correctness criteria can
  be proven more easily with the aid of the lattice properties.
\end{enumerate}
