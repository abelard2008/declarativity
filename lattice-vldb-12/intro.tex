\section{Introduction}
\label{sec:intro}
Although distributed programming has become an essential and commonplace task,
it remains very challenging for most developers to write correct distributed
programs. The inherent difficulties of distributed computing---concurrency,
asynchrony, and partial failure---have been excaberated by the scale at which
modern distributed systems must operate.

To allow their programs to gracefully tolerate network partitions and
unpredictable messaging delays, many system designers have chosen to give up
sequential consistency because it typically requires the use of heavyweight
distributed commit and consensus protocols. Instead, many modern systems aim
instead to provide a weaker degree of consistency, such as eventual
consistency~\cite{Terry1995} or causal consistency~\cite{Lloyd2011}.

We recently proposed the CALM theorem, which links distributed
\emph{consistency} with \emph{logical
  monotonicity}~\cite{Alvaro2011,Hellerstein2010}. Intuitively, a logically
monotonic program computes a set of facts that only grows over time; it never
``retracts'' an earlier conclusion in the face of new information. Hence, a
monotonic program can be executed in a coordination-free manner and still reach
a consistent state: all monotonic programs are ``eventually consistent.'' Since
synctactic monotonicity of a Datalog program is straightforward to detect, the
CALM theorem provides a simple analysis technique for loosely consistent
distributed programs. The CALM analysis is realized as part of Bloom, a
Datalog-based DSL for distributed programming~\cite{bloom}.
% XXX: cite Belgians
% XXX: validate that 

Our initial formulation of Bloom and CALM only considered programs that compute
sets of facts that grow over time (``set monotonicity''). This limits the
usefulness of the CALM analysis, because it makes several common distributed
programming idioms non-monotonic. In particular, threshold tests (``$\textrm{count}(S) >
k$'') and monotonically increasing counters are both non-monotonic in the
original definition.

In this paper, we extend our previous results to apply to a more general notion
of monotonicity. We use lattices to describe any domain 

% Explain how lattices generalize monotonic datalog
In this paper, we extend our previous results in several directions:
\begin{enumerate}
\item
  First, we introduce lattices, explain the algebraic properties that must be
  satisfied by lattice implementations, and present \latlang, a generalization
  of Dedalus to support both lattices and traditional relations.

\item
  We prove that \latlang generalizes Datalog, and formally prove that a sub-class of
  \latlang programs are confluent.

\item
  We describe how we extended the Bloom DSL to support user-defined lattices. We
  detail the API that lattice implementations must support, and describe how we
  extended the standard semi-na\"{i}ve Datalog evaluation scheme~\cite{Balbin1987}
  to support both lattices and traditional database relations.

\item
  Finally, we examine the effectiveness of lattices as a practical programming
  construct through the use of two case studies: a causally-consistent
  point-to-point delivery protocol and a replicated shopping cart service. In
  both cases, we show how lattices enable concise and intuitive implementations
  of these designs. More importantly, we show how domain-specific correctness
  criteria can be expressed in terms of lattice properties, giving us more
  confidence in the correctness of our programs.
\end{enumerate}
