\section{Introduction}
\label{sec:intro}
Although distributed programming has become an essential and commonplace task,
it remains very challenging for most developers to write correct distributed
programs. The inherent difficulties of distributed computing---concurrency,
asynchrony, and partial failure---have been exacerbated by the scale at which
modern distributed systems must operate.

To allow their programs to gracefully tolerate network partitions and
unpredictable messaging delays, many system designers have chosen to give up
sequential consistency because it typically requires the use of heavyweight
distributed commit and consensus protocols. Instead, many modern systems aim
instead to provide a weaker degree of consistency, such as eventual
consistency~\cite{Terry1995,vogels} or causal consistency~\cite{Lloyd2011}.

We recently proposed the CALM theorem, which links distributed
\emph{consistency} with \emph{logical
  monotonicity}~\cite{Alvaro2011,Hellerstein2010}. Intuitively, a monotonic
program computes more information over time---it never ``retracts'' an earlier
conclusion in the face of new information. Hence, a monotonic program can be
executed in a coordination-free manner and still reach a consistent state---all
monotonic programs are eventually consistent~\cite{Ameloot2011}.  Since
syntactic monotonicity of a Datalog program is straightforward to determine, the
CALM theorem provides the basis for a simple analysis technique for loosely
consistent distributed programs~\cite{Alvaro2011}. The CALM analysis is realized
as part of Bloom, a Datalog-based DSL for distributed programming~\cite{bloom}.

Our initial formulation of Bloom and CALM only considered programs that compute
sets of facts that grow over time (``set monotonicity''); that is, ``growth'' is
defined according to set containment. This limits the usefulness of the CALM
analysis because it makes several common distributed programming idioms
non-monotonic. In particular, threshold tests over aggregate values (e.g.,
``$\textrm{max}(S) > k$'') and upward-moving counters are both non-monotonic
under set monotonicity.

In this paper, we extend our previous results by using a more general notion of
monotonicity. Instead of only allowing growth according to the set containment
partial order, we allow any user-defined partial order to be used. We do this by
introducing \emph{join semi-lattices} as a programming construct. We give a
formal definition of this construct below, but the intuition is that the user
must supply a commutative, idempotent merge function (``least upper bound'')
that takes two input values and produces an output value that is not smaller
than either of the input values (according to the user's partial order). This
generalizes Bloom (and traditional Datalog), which assumes a fixed merge
function (set union) and partial order (set containment).
% Relate user-defined merge functions to merge functions in other contexts?
% (e.g., key-value store, COPS, Piccolo)

% Explain how lattices generalize monotonic datalog
In this paper, we make the following contributions:
\begin{enumerate}
% \item
%   We present \baselang, a variant of Datalog that is defined over lattices. We
%   define a model-theoretic semantics for \baselang, and show that \baselang
%   generalizes Datalog.

\item
  We introduce \lang, an extension of Bloom that supports lattices. We describe
  how to express computation over lattices, detail the builtin lattice types
  provided by \lang, and illustrate how developers can define new lattice
  types.

\item 
  We generalize the CALM analysis to programs that contain both lattices and
  set-oriented collections, and show how lattices can be used to prove the
  confluence of several common distributed design patterns that were regarded as
  non-monotonic in Bloom. % XXX: revisit this

\item
  We show how to extend the standard Datalog semi-naive evaluation
  scheme~\cite{Balbin1987} to support both lattices and traditional database
  relations. We also describe how an existing Datalog engine can be extended to
  support lattices with relatively minor changes.

\item
  Finally, we validate the effectiveness of lattices with two case studies. We
  revisit the simple e-commerce scenario presented in Alvaro et al., in which
  clients interact with a replicated shopping cart service~\cite{Alvaro2011}. We
  use lattices to allow a more flexible and compact representation of shopping
  cart state. Second, we show how lattices can make the ``checkout'' aggregation
  operation monotonic.

  We also use lattices to implement a classical distributed protocol for
  point-to-point causal delivery~\cite{Schiper1989}. We show that causal
  delivery is monotonic and detail how domain-specific correctness criteria can
  be proven more easily with the aid of the lattice properties.
\end{enumerate}
