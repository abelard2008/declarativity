\section{Adding Lattices to Bloom}
\label{sec:lang}

In this section, we introduce \lang, an extension to Bloom that allows monotonic
programs to be written using arbitrary lattices. We begin by reviewing the
algebraic properties of lattices, monotone functions, and morphisms. We then
introduce the basic concepts of \lang and detail the builtin lattices provided
by the language. We also show how users can define their own lattice types using
a simple API.

% is this the right place for this?
When designing \lang, we decided to extend Bloom to include support for lattices
rather than building a new language from scratch. Hence, \lang is backward
compatible with Bloom and was implemented with relatively minor changes to the
Bud runtime. This design decision also required that we consider how code
written using lattices should interoperate with traditional Bloom relations; we
added several \lang features to ease this interoperability, which we describe in
Section~\ref{sec:bloom-interop}.

\subsection{Definitions}
\label{sec:lattice-defn}
A \emph{bounded join semilattice} is a triple $\langle S, \lor, \bot\rangle$,
where $S$ is a poset, $\lor$ is a binary operator (called ``join'' or ``least
upper bound''), and $\bot \in S$. $\lor$ is associative, commutative, and
idempotent. For all $x, y \in S$, $x \lor y = z$, where $x \leq_S z, y \leq_S
z$, and there is no $z' \in S$ such that $z' <_S z$ (where $<_S$ is the partial
order of poset $S$). Note that although the underlying set only has a partial
order, the least upper bound is defined for all elements $x,y \in S$. The
distinguished element $\bot$ is the smallest element in $S$; this implies that
$x \lor \bot = x$ for all $x \in S$. For brevity, we use the term ``lattice'' to
mean ``bounded join semilattice'' in the rest of this paper.

% XXX: note that algebraic properties that must be satisfied by morphisms and
% monotone functions
A \emph{monotone function} from poset $S$ to poset $T$ is a function $f: S \to
T$ such that $\forall a,b \in S: a \leq_S b \Rightarrow f(a) \leq_T f(b)$. That
is, $f$ maps elements of $S$ to elements of $T$ in a manner that is consistent
with the partial orders of both posets.

% XXX: mention that morphisms must be distributive with respect to the lub of
% their domain, whereas monotone functions don't need to be?
A \emph{morphism} from lattice $\langle X, \lor_X, \bot_X\rangle$ to lattice
$\langle Y, \lor_Y, \bot_Y\rangle$ is a function $g: X \to Y$ such that,
$\forall a,b \in X: g(a \lor_X b) = g(a) \lor_Y g(b)$. That is, $g$ allows
elements of $X$ to be converted into elements of $Y$ in a way that preserves the
lattice properties.  Note that morphisms are monotone functions but the converse
is not true in general.

\subsection{Language concepts}
\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
QUORUM_SIZE = 5
RESULT_ADDR = "example.org"

class QuorumVoteL
  include Bud

  state do
    channel :vote_chn, [:@addr, :voter_id]
    channel :result_chn, [:@addr]
    lset    :votes (*\label{line:quorum-lset-decl}*)
    lmax    :cnt
    lbool   :quorum_done
  end

  bloom do
    votes       <= vote_chn {|v| v.voter_id} (*\label{line:quorum-set-accum}*)
    cnt         <= votes.size (*\label{line:quorum-lmax}*)
    quorum_done <= cnt.gt_eq(QUORUM_SIZE) (*\label{line:quorum-threshold}*)
    result_chn  <~ quorum_done.when_true { [RESULT_ADDR] }
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{A monotonic \lang program that waits for a quorum of votes to be received.}
\label{fig:lattice-quorum}
\end{figure}

\lang allows both lattices and collections to be used to represent state. A
lattice is analogous to a collection type in Bloom, while a lattice element
corresponds to a collection with a particular value. For example, the
\texttt{lset} lattice is similar to the \texttt{table} collection type provided
by Bloom; an element of the \texttt{lset} lattice is a particular set. In the
terminology of object-oriented programming, a lattice is a class that obeys a
certain interface and an element of a lattice is an instance of that
class. Figure~\ref{fig:lattice-quorum} contains an example \lang program.

As with collections, the lattices used by a \lang program are declared in a
\texttt{state} block. More precisely, a state block declaration introduces an
identifier that is associated with a lattice element; over time, the binding
between identifiers and lattice elements is updated to reflect state changes in
the program. For example, line~\ref{line:quorum-lset-decl} of
Figure~\ref{fig:lattice-quorum} declares an identifier \texttt{votes} that is
mapped to an element of the \texttt{lset} lattice. As more votes are received,
the lattice element associated with the \texttt{votes} identifier
changes---specifically, it moves ``upward'' in the \texttt{lset} lattice.

\subsubsection{Statements in \lang}
Statements take the same form in both Bloom and \lang:
 \\ \noindent
\mbox{\hspace{0.25in}\emph{$<$identifier$>$ $<$op$>$
    $<$expression$>$}}\\ \noindent
The identifier on the lhs can refer to either a set-oriented collection or a
lattice. The expression on the rhs can contain both traditional relational
operators (applied to Bloom collections) and methods invoked on lattices.
Lattice methods are similar to methods in an object-oriented language and are
invoked using the standard method invocation syntax.

Note that if the lhs of a statement refers to a lattice, the statement's
operator must be either \verb|<=| or \verb|<+| (instantaneous or deferred
deduction, respectively). \lang does not currently support a notion of
``deletion'' for lattices. Lattices do not directly support asynchronous
communication (via the \verb|<~| operator) but lattice elements can be embedded
into tuples that appear channels (Section~\ref{sec:bloom-interop}).

\subsubsection{Lattice methods}
\lang statements compute values over lattices by invoking methods on lattice
elements. Just like a subset of the relational operators (selection, projection,
and join) are monotonic, some lattice methods are monotone functions (as defined
in Section~\ref{sec:lattice-defn}). The input to a monotone lattice method is
the receiver of the method invocation; the output is the result of the method
invocation. A monotone method guarantees that, if the input to the method grows
(according to the input's lattice type), the output will grow (according to the
output's lattice type).

Lattices are free to provide non-monotonic methods. Invoking a non-monotonic
lattice method in a statement is analogous to using a non-monotonic relational
operator (aggregation and negation) in Bloom: the Bud interpreter stratifies the
program to ensure that the input value is computed exactly before allowing a
non-monotonic operator to be applied to it. This implies that statements that
invoke non-monotonic methods on lattice values cannot be recursive.

\subsection{Builtin lattice types}
\label{sec:lattice-builtins}

\begin{table*}[t]
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Name} & \textbf{Description} & \textbf{Merge} & \textbf{Morphisms} &
\textbf{Monotone functions}\\
\hline
\texttt{lbool} & Boolean lattice (false $\to$ true) & & \texttt{when\_true} & \\
\texttt{lmax} & Max over an ordered domain & &\texttt{gt},
\texttt{gt\_eq}, \texttt{+}, \texttt{-} & \\
\texttt{lmin} & Min over an ordered domain & &\texttt{lt}, \texttt{lt\_eq},
\texttt{+}, \texttt{-} & \\
\texttt{lset} & Set of values & & \texttt{intersect}, \texttt{product},
\texttt{project} & \texttt{size} \\
\texttt{lpset} & Set of non-negative numbers & &
\texttt{intersect}, \texttt{product}, \texttt{project}& \texttt{size}, \texttt{sum} \\
\texttt{lbag} & Multiset of values & & \texttt{intersect},
\texttt{project}, \texttt{mult(k)}, \texttt{+} & \texttt{size}\\
\texttt{lmap} & Map from key to lattice values & &
\texttt{intersect}, \texttt{project}, \texttt{at(k)}, \texttt{key?(k)} & \texttt{size}\\
\hline
\end{tabular}
\caption{Builtin lattices in \lang.}
\label{tbl:builtin-lattices}
\end{table*}

Table~\ref{tbl:builtin-lattices} lists the builtin lattices provided by
\lang. Many common distributed protocols can be expressed using these lattices
(e.g., the causal delivery protocol described in Section~\ref{sec:causal}).

Note that \emph{size} is a monotone function provided by several lattices, but
it is not a morphism. This is because \texttt{size} cannot be distributed over
the merge functions of those lattices. For example, \ldots

\subsection{Lattice API}
\label{sec:lattice-api}
In \lang, each lattice has an associated Ruby class, which we call the
\emph{lattice class}. An instance of this class is called a \emph{lattice
  element}. A lattice element represents a single point in the lattice---i.e., an
element of the poset associated with the lattice.

A lattice class is a normal Ruby class that meets a certain API contract. Every
lattice class inherit from the builtin \texttt{Bud::Lattice} class, and
must also define two methods:
\begin{itemize}
\item \texttt{initialize(i)}: given a Ruby object \emph{i}, this method
  constructs a new lattice element that ``wraps'' \emph{i} (\texttt{initialize}
  is just the normal Ruby syntax for defining a constructor). By convention, the
  Ruby value wrapped by a lattice element is assigned to a Ruby member variable
  \texttt{@v}. If $i$ is the null reference, this method returns the least
  element of the lattice.

\item \texttt{merge(e)}: given a lattice element \emph{e}, this method returns the
  lattice element that is the least upper bound of $\{e, \textit{self}\}$. This method must
  satisfy the algebraic properties summarized in Section~\ref{sec:lattice-defn}---in
  particular, it must be commutative, associative, and idempotent. Note that
  \emph{e} must have the same class as \emph{self}.
\end{itemize}
Lattice elements are \emph{immutable} (e.g., \texttt{merge} functions should
construct a new lattice element rather than modifying one of their inputs
in-place). Efficient lattice implementations may \emph{share structure} on merge
operations, as is common practice for immutable data structures in functional
programming languages~\cite{Okasaki1999}. % XXX: maybe not the right place for this

\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
class Bud::SetLattice < Bud::Lattice
  wrapper_name :lset

  def initialize(x=[])
    # Reject invalid input (elided)
    @v = x.uniq # Remove duplicates from input
  end

  def merge(i)
    self.class.new(@v | i.reveal)
  end

  morph :intersect do |i|
    self.class.new(@v & i.reveal)
  end

  morph :pro do |&blk|
    @v.map(&blk)
  end

  monotone :size do
    Bud::MaxLattice.new(@v.size)
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{The implementation of the \texttt{lset} lattice in Ruby.}
\label{fig:lattice-set}
\end{figure}

\subsection{Integration with set-oriented logic}
\label{sec:bloom-interop}
\lang provides two features to ease integration of lattice-based code with
traditional Bloom programs that manipulate set-oriented collections.

\subsubsection{Implicit fold}
% XXX: this ignores the fact that Bloom collections consist of sets of tuples,
% whereas implicit fold works for sets of singleton values
% XXX: refer to shortest paths program as practical example
This feature enables set-oriented collections to be more easily used as input to
lattices. If a \lang statement has a set-oriented collection on the rhs and a lattice
on the lhs, the lattice merge function is used to ``fold over'' the elements of
the collection. That is, each element of the collection is converted to a
lattice element (via the appropriate lattice constructor); then the set of
lattice elements are merged together (via repeated application of the
\texttt{merge} method). In our experience, this is typically the behavior
intended by the user.

\subsubsection{Collections with embedded lattice values}
It would be convenient to allow lattice elements to be stored as attributes of
tuples that appear in set-oriented Bloom collections. Furthermore, Bloom
provides several facilities (e.g., network communication, persistent storage,
module interfaces) as collections with special semantics; it would be
unfortunate if a redundant set of facilities would be necessary to support
lattice-based code. A simple solution would be to extract the underlying Ruby
value from the lattice element (e.g., using the \texttt{reveal} method), and
then store that value as a tuple attribute in a set-oriented
collection. Unfortunately, that would introduce needless non-monotonicity into
the program.

Storing lattice elements as attributes of tuples in set-oriented collections
introduces several challenges. Consider a simple \lang statement that derives tuples
with a lattice element as an attribute value:
\begin{verbatim}
    t1 <= t2 {|t| [t.x, lat_foo]}
\end{verbatim}
where \texttt{t1} and \texttt{t2} are Bloom relations and \texttt{lat\_foo}
identifies a lattice; suppose that the first column of \texttt{t1} is the
relation's key. The value associated with \texttt{lat\_foo} can change over the
course of the fixpoint computation (specifically, it can grow ``upward''
according to the lattice's partial order, as more values are merged into the
lattice). Implemented naively, this might result in multiple \texttt{t1} tuples
with different values for the second attribute, which would violate
\texttt{t1}'s key (the first column of \texttt{t1} would not functionally
determine a single value for the second column).

This problem could be avoided by placing constraints on the evaluation order of
statements: for example, we could require that all potential changes to
\texttt{lat\_foo} be completed before rules that embed \texttt{lat\_foo} could
be evaluated. This would effectively stratify the program according to lattice
embedding rules, which would disallow cycles through lattice
embeddings~\cite{Apt1988}. This would reject intuitively reasonable programs; it
also seems unsatisfying to require stratification of monotonic programs.

% Clarify this
Instead, \lang allows rules to produce multiple tuples that differ only in their
embedded lattice values. During the course of the fixpoint computation, those
values are merged together using the appropriate lattice merge function. This is
safe because Bud stratifies programs according to non-monotonic operators;
hence, any operators that might be applied to an embedded lattice value before
it has been determined exactly must be monotonic. Nevertheless, this solution is
somewhat counterintuitive because tuples in Datalog relations are traditionally
immutable: once a fact is known to be true, its value remains the
same.% \footnote{Bloom facts can be deleted, but this is an explicit non-monotonic
  % operation that can only occur between timesteps. Conceptually, Bloom models
  % update as the retraction of the previous version of a fact and the insertion
  % of a new fact~\cite{dedalus}.}
% Should we note that we might add an option to disable this behavior for
% particular attributes, or explain more about why this might be considered
% weird?

For similar reasons, we currently disallow lattice values from being used as
keys in Bloom collections. It might be possible to relax this restriction in
certain ``safe'' cases, but we have not found this limitation to be problematic
to date.

\subsection{Confluence in \lang}
\nrc{TODO: justify that CALM continues to hold for monotonic programs over
  lattices.}
