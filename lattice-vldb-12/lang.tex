\section{Adding Lattices to Bloom}
\label{sec:impl}

% Outline:
% * design philosophy, sign posting
% * introduce lattice values
% * introduce lattice wrappers
% * introduce morphisms
% * discuss example program
% * discuss integration features
% * implementation notes

When designing \lang, we decided to extend Bloom to include support for
lattices, rather than building a new language from scratch. Hence, \lang is
backward compatible with Bloom, and was implemented with relatively minor
changes to the Bud runtime. This design decision also required that we consider
rules written over lattices should interoperate with rules that use traditional
Bloom relations; we added several \lang features to ease this interoperability,
which we describe in Section~\ref{sec:bloom-interop}.

\subsection{Lattice types and values}
In \lang, each lattice has an associated Ruby class, which we call the
\emph{lattice class}. An instance of this class is called a \emph{lattice
  value}. A lattice element represents a single point in the lattice---i.e., an
element of the poset associated with the lattice.

A lattice class is a normal Ruby class that meets a certain API contract. Every
lattice class must define two methods:
\begin{itemize}
\item \texttt{initialize(i)}: given a Ruby object \emph{i}, this method
  constructs a new lattice element that ``wraps'' \emph{i} (\texttt{initialize}
  is just the normal Ruby syntax for defining a constructor). If $i$ is the null
  reference, this method returns the least element of the lattice.
\item \texttt{merge(e)}: given a lattice element \emph{e}, this method returns the
  lattice element that is the least upper bound of $\{e, self\}$. This method must
  satisfy the algebraic properties summarized in Section~\ref{sec:found-defn}---in
  particular, it must be commutative, associative, and idempotent. Note that
  \emph{e} must have the same lattice class as \emph{self}.
\end{itemize}
A lattice value is \emph{immutable} (e.g., \texttt{merge} functions should
construct new lattice values rather than modifying one of their input values
in-place). Efficient lattice implementations may \emph{share structure} on merge
operations, as is common practice for immutable data structures in functional
programming languages~\cite{Okasaki1999}.

\subsection{Lattice wrappers}
A \emph{lattice wrapper} manages the mapping from identifier names to lattice
values.

\subsection{Morphisms}

\subsection{Example program}
\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
class ShortestPaths
  include Bud

  state do
    table :link, [:from, :to, :c]
    table :path, [:from, :to, :next_hop] => [:c]
    table :min_cost, [:from, :to] => [:c]
  end

  bloom do
    path <= link {|l| [l.from, l.to, l.to, MinLattice.new(l.c)]}
    path <= (link*path).pairs(:to => :from) do |l,p|
      [l.from, p.to, l.to, p.c + l.c]
    end
    min_cost <= path {|p| [p.from, p.to, p.c]}
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{A \lang program to compute the all-pairs shortest paths of a
  graph.}
\label{fig:lattice-spaths}
\end{figure}

\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
class Bud::SetLattice < Bud::Lattice
  lattice_name :lset

  def initialize(x=[])
    @v = x     # Reject invalid input (elided)
  end

  def merge(i)
    Bud::SetLattice.new((@v + i.reveal).uniq)
  end

  morph :size do
    Bud::MaxLattice.new(@v.size)
  end

  morph :intersect do |i|
    Bud::SetLattice.new(@v & i.reveal)
  end

  morph :pro do |&blk|
    @v.map(&blk)
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{The implementation of the \texttt{lset} lattice in Ruby.}
\label{fig:lattice-set}
\end{figure}

\subsection{Integration with set-oriented logic}
\label{sec:bloom-interop}

\subsection{Implementation}

\begin{table*}[t]
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{Description} & \textbf{Merge} & \textbf{Morphisms} \\
\hline
\texttt{lbool} & Boolean lattice (false $\to$ true) & & \texttt{when\_true} \\
\texttt{lmax} & Max over an ordered domain & &\texttt{gt},
\texttt{gt\_eq}, \texttt{+}, \texttt{-} \\
\texttt{lmin} & Min over an ordered domain & &\texttt{lt}, \texttt{lt\_eq},
\texttt{+}, \texttt{-} \\
\texttt{lset} & Set of values & &\texttt{size}, \texttt{intersect}, \texttt{project}
\\
\texttt{lbag} & Multiset of values & &\texttt{size}, \texttt{intersect},
\texttt{project}, \texttt{mult(k)}\\
\texttt{lmap} & Map from key to lattice values & &\texttt{size},
\texttt{intersect}, \texttt{project}, \texttt{at(k)}, \texttt{key?(k)} \\
\texttt{lsum} & Sum of non-negative numbers & &\\
\hline
\end{tabular}
\caption{Builtin lattices provided by \lang.}
\label{tbl:builtin-lattices}
\end{table*}