\section{Adding Lattices to Bloom}
\label{sec:lang}

In this section, we introduce \lang, an extension of Bloom that allows monotonic
programs to be written using arbitrary lattices. We begin by reviewing the
algebraic properties of lattices, monotone functions, and morphisms. We then
introduce the basic concepts of \lang and detail the builtin lattices provided
by the language. We also show how users can define their own lattice types using
a simple Ruby API.

% is this the right place for this?
When designing \lang, we decided to extend Bloom to include support for
lattices rather than building a new language from scratch. Hence, \lang is
backward compatible with Bloom and was implemented with relatively minor
changes to the Bud runtime. This design decision also required that we consider
rules written over lattices should interoperate with rules that use traditional
Bloom relations; we added several \lang features to ease this interoperability,
which we describe in Section~\ref{sec:bloom-interop}.

\subsection{Definitions}
\label{sec:lattice-defn}
A \emph{bounded join semilattice} is a triple $\langle S, \lor, \bot\rangle$,
where $S$ is a poset, $\lor$ is a binary operator (called ``join'' or ``least
upper bound''), and $\bot \in S$. $\lor$ is associative, commutative, and
idempotent. For all $x, y \in S$, $x \lor y = z$, where $x \leq_S z, y \leq_S
z$, and there is no $z' \in S$ such that $z' <_S z$ (where $<_S$ is the partial
order associated with the poset $S$). Note that although the underlying set only
has a partial order, the least upper bound is defined for all elements $x,y \in
S$. The distinguished element $\bot$ is the smallest element in $S$; this
implies that $x \lor \bot = x$ for all $x \in S$. For brevity, we use the term
``lattice'' to mean ``bounded join semilattice'' in the rest of this paper.

% XXX: note that algebraic properties that must be satisfied by morphisms and
% monotone functions
A \emph{monotone function} from poset $S$ to poset $T$ is a function $g: S \to
T$ such that $\forall a,b \in S: a \leq_S b \Rightarrow g(a) \leq_T g(b)$. That
is, $g$ maps elements of $S$ to elements of $T$ in a manner that is consistent
with the partial orders of both posets.

% XXX: mention that morphisms must be distributive with respect to the lub of
% their domain, whereas monotone functions don't need to be?
A \emph{morphism} from lattice $\langle X, \lor_X, \bot_X\rangle$ to lattice
$\langle Y, \lor_Y, \bot_Y\rangle$ is a function $f$ such that, $\forall a,b \in
X: f(a \lor_X b) = f(a) \lor_Y f(b)$. That is, $f$ allows elements of $X$ to be
converted into elements of $Y$ in a way that preserves the lattice properties.
Note that all morphisms are monotone functions but the converse is not true in
general.

\subsection{Language concepts}
In \lang, state is represented using lattices and computation is expressed as
functions over lattices. A lattice in \lang is analogous to a collection type in
Bloom, while a lattice element corresponds to a particular collection value. For
example, the \texttt{lset} lattice provides similar functionality to the
set-oriented collections provided by Bloom; an element of the \texttt{lset}
lattice is a particular set value. In the terminology of object-oriented
programming, a lattice is a class that obeys a certain interface and an element
of a lattice is an instance of that class.

As in Bloom, the lattices used by a \lang program are declared in a
\texttt{state} block. More precisely, the declarations in the state block
introduce identifiers that are associated with lattice elements; over time, the
binding between identifiers and lattice elements is updated to reflect state
changes in the program. For example, line~\ref{line:quorum-lset-decl} of
Figure~\ref{fig:lattice-quorum} declares an identifier \texttt{votes} that is
mapped to an element of the \texttt{lset} lattice. As more votes are received,
the lattice element associated with the \texttt{votes} identifier
changes---specifically, it moves upward in the \texttt{lset} lattice.

\subsubsection{Computation in \lang}
Statements take the same form in both Bloom and \lang. The identifier on the lhs
of a statement can refer to either a set-oriented collection or a lattice. The
expression on the rhs can contain both traditional relational operators (applied
to Bloom collections) and method invocations (applied to lattice elements).

Note that if the lhs of a statement refers to a lattice, the statement's
operator must be either \verb|<=| or \verb|<+|, denoting instaneous or deferred
deduction. \lang does not currently support a notion of ``deletion'' for
lattices. Lattices do not directly support asynchronous communication (via the
\verb|<~| operator), but lattice elements can be embedded into channels (as
described in Section~\ref{sec:bloom-interop}).

\subsection{Builtin lattice types}
\label{sec:lattice-builtins}

\begin{table*}[t]
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{Name} & \textbf{Description} & \textbf{Merge} & \textbf{Morphisms} &
\textbf{Monotone functions}\\
\hline
\texttt{lbool} & Boolean lattice (false $\to$ true) & & \texttt{when\_true} & \\
\texttt{lmax} & Max over an ordered domain & &\texttt{gt},
\texttt{gt\_eq}, \texttt{+}, \texttt{-} & \\
\texttt{lmin} & Min over an ordered domain & &\texttt{lt}, \texttt{lt\_eq},
\texttt{+}, \texttt{-} & \\
\texttt{lset} & Set of values & & \texttt{intersect}, \texttt{product},
\texttt{project} & \texttt{size} \\
\texttt{lpset} & Set of non-negative numbers & &
\texttt{intersect}, \texttt{product}, \texttt{project}& \texttt{size}, \texttt{sum} \\
\texttt{lbag} & Multiset of values & & \texttt{intersect},
\texttt{project}, \texttt{mult(k)}, \texttt{+} & \texttt{size}\\
\texttt{lmap} & Map from key to lattice values & &
\texttt{intersect}, \texttt{project}, \texttt{at(k)}, \texttt{key?(k)} & \texttt{size}\\
\hline
\end{tabular}
\caption{The builtin lattices in \lang.}
\label{tbl:builtin-lattices}
\end{table*}

Table~\ref{tbl:builtin-lattices} lists the builtin lattices provided by
\lang. Many common distributed protocols can be expressed using these lattices
(e.g., the causal delivery protocol described in Section~\ref{sec:causal}).

Note that \emph{size} is a monotone function provided by several lattices, but
it is not a morphism. This is because \texttt{size} cannot be distributed over
the merge functions of those lattices. For example, \ldots

\subsection{Lattice API}
\label{sec:lattice-api}
In \lang, each lattice has an associated Ruby class, which we call the
\emph{lattice class}. An instance of this class is called a \emph{lattice
  element}. A lattice element represents a single point in the lattice---i.e., an
element of the poset associated with the lattice.

A lattice class is a normal Ruby class that meets a certain API contract. Every
lattice class inherit from the builtin \texttt{Bud::Lattice} class, and
must also define two methods:
\begin{itemize}
\item \texttt{initialize(i)}: given a Ruby object \emph{i}, this method
  constructs a new lattice element that ``wraps'' \emph{i} (\texttt{initialize}
  is just the normal Ruby syntax for defining a constructor). By convention, the
  Ruby value wrapped by a lattice element is assigned to a Ruby member variable
  \texttt{@v}. If $i$ is the null reference, this method returns the least
  element of the lattice.

\item \texttt{merge(e)}: given a lattice element \emph{e}, this method returns the
  lattice element that is the least upper bound of $\{e, \textit{self}\}$. This method must
  satisfy the algebraic properties summarized in Section~\ref{sec:lattice-defn}---in
  particular, it must be commutative, associative, and idempotent. Note that
  \emph{e} must have the same class as \emph{self}.
\end{itemize}
Lattice elements are \emph{immutable} (e.g., \texttt{merge} functions should
construct a new lattice element rather than modifying one of their inputs
in-place). Efficient lattice implementations may \emph{share structure} on merge
operations, as is common practice for immutable data structures in functional
programming languages~\cite{Okasaki1999}. % XXX: maybe not the right place for this

\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
class Bud::SetLattice < Bud::Lattice
  wrapper_name :lset

  def initialize(x=[])
    # Reject invalid input (elided)
    @v = x.uniq # Remove duplicates from input
  end

  def merge(i)
    self.class.new(@v | i.reveal)
  end

  morph :intersect do |i|
    self.class.new(@v & i.reveal)
  end

  morph :pro do |&blk|
    @v.map(&blk)
  end

  ord_map :size do
    Bud::MaxLattice.new(@v.size)
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{The implementation of the \texttt{lset} lattice in Ruby.}
\label{fig:lattice-set}
\end{figure}

\subsection{Integration with set-oriented logic}
\label{sec:bloom-interop}

\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
class ShortestPaths
  include Bud

  state do
    table :link, [:from, :to, :c]
    table :path, [:from, :to, :next_hop] => [:c]
    table :min_cost, [:from, :to] => [:c]
  end

  bloom do
    path <= link {|l| [l.from, l.to, l.to, MinLattice.new(l.c)]}
    path <= (link*path).pairs(:to => :from) do |l,p|
      [l.from, p.to, l.to, p.c + l.c]
    end
    min_cost <= path {|p| [p.from, p.to, p.c]}
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{A \lang program to compute the all-pairs shortest paths of a
  graph.}
\label{fig:lattice-spaths}
\end{figure}

\lang provides two features to ease integration of lattice-based code with
traditional Bloom programs that manipulate set-oriented collections.

\subsubsection{Implicit fold}
% XXX: this ignores the fact that Bloom collections consist of sets of tuples,
% whereas implicit fold works for sets of singleton values
% XXX: refer to shortest paths program as practical example
This feature enables set-oriented collections to be more easily used as input to
lattices. If a \lang statement has a set-oriented collection on the rhs and a lattice
on the lhs, the lattice merge function is used to ``fold over'' the elements of
the collection. That is, each element of the collection is converted to a
lattice element (via the appropriate lattice constructor); then the set of
lattice elements are merged together (via repeated application of the
\texttt{merge} method). In our experience, this is typically the behavior
intended by the user.

\subsubsection{Collections with embedded lattice values}
It would be convenient to allow lattice elements to be stored as attributes of
tuples that appear in set-oriented Bloom collections. Furthermore, Bloom
provides several facilities (e.g., network communication, persistent storage,
module interfaces) as collections with special semantics; it would be
unfortunate if a redundant set of facilities would be necessary to support
lattice-based code. A simple solution would be to extract the underlying Ruby
value from the lattice element (e.g., using the \texttt{reveal} method), and
then store that value as a tuple attribute in a set-oriented
collection. Unfortunately, that would introduce needless non-monotonicity into
the program.

Storing lattice elements as attributes of tuples in set-oriented collections
introduces several challenges. Consider a simple \lang statement that derives tuples
with a lattice element as an attribute value:
\begin{verbatim}
    t1 <= t2 {|t| [t.x, lat_foo]}
\end{verbatim}
where \texttt{t1} and \texttt{t2} are Bloom relations and \texttt{lat\_foo}
identifies a lattice; suppose that the first column of \texttt{t1} is the
relation's key. The value associated with \texttt{lat\_foo} can change over the
course of the fixpoint computation (specifically, it can grow ``upward''
according to the lattice's partial order, as more values are merged into the
lattice). Implemented naively, this might result in multiple \texttt{t1} tuples
with different values for the second attribute, which would violate
\texttt{t1}'s key (the first column of \texttt{t1} would not functionally
determine a single value for the second column).

This problem could be avoided by placing constraints on the evaluation order of
statements: for example, we could require that all potential changes to
\texttt{lat\_foo} be completed before rules that embed \texttt{lat\_foo} could
be evaluated. This would effectively stratify the program according to lattice
embedding rules, which would disallow cycles through lattice
embeddings~\cite{Apt1988}. This would reject intuitively reasonable programs; it
also seems unsatisfying to require stratification of monotonic programs.

% Clarify this
Instead, \lang allows rules to produce multiple tuples that differ only in their
embedded lattice values. During the course of the fixpoint computation, those
values are merged together using the appropriate lattice merge function. This is
safe because Bud stratifies programs according to non-monotonic operators;
hence, any operators that might be applied to an embedded lattice value before
it has been determined exactly must be monotonic. Nevertheless, this solution is
somewhat counterintuitive because tuples in Datalog relations are traditionally
immutable: once a fact is known to be true, its value remains the
same.% \footnote{Bloom facts can be deleted, but this is an explicit non-monotonic
  % operation that can only occur between timesteps. Conceptually, Bloom models
  % update as the retraction of the previous version of a fact and the insertion
  % of a new fact~\cite{dedalus}.}
% Should we note that we might add an option to disable this behavior for
% particular attributes, or explain more about why this might be considered
% weird?

For similar reasons, we currently disallow lattice values from being used as
keys in Bloom collections. It might be possible to relax this restriction in
certain ``safe'' cases, but we have not found this limitation to be problematic
to date.

\subsection{Confluence in \lang}
\nrc{TODO: justify that CALM continues to hold for monotonic programs over
  lattices.}
