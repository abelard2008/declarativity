\section{Adding Lattices to Bloom}
\label{sec:impl}

% Outline:
% * design philosophy, sign posting
% * introduce lattice values
% * introduce lattice wrappers
% * introduce morphisms
% * discuss example program
% * discuss integration features
% * implementation notes

When designing \lang, our philosphy was to extend Bloom to allow the
manipulation of lattices, rather than designing a new language from
scratch. Thus, \lang is completely backward compatible with Bloom. This decision
also required that we consider how 

\subsection{Lattice values}
In \lang, each lattice has an associated Ruby class that defines the behavior of
the lattice. Every lattice class must define two methods:
\begin{itemize}
\item \texttt{initialize(i)}: given a Ruby object \emph{i}, this method
  constructs a new instance of the lattice class that ``wraps'' \emph{i}
  (\texttt{initialize} is just the normal Ruby syntax for a constructor).
\item \texttt{merge(v)}: given another instance of the (same) lattice class,
  this method returns an instance of the lattice class that is $\ge$ both of the
  input values. That is, this method computes the least upper bound of the two
  values; a legal \emph{merge} function implementation must satisfy the 
\end{itemize}
An instance of a lattice class represents a single point in the lattice space. A
lattice value is \emph{immutable} (e.g., \texttt{merge} functions should
construct new lattice values rather than modifying one of their input values
in-place). 

\subsection{Lattice wrappers}
A \emph{lattice wrapper} manages the mapping from identifier names to lattice
values.

\subsection{Morphisms}

\subsection{Example Program}
\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
class ShortestPaths
  include Bud

  state do
    table :link, [:from, :to, :c]
    table :path, [:from, :to, :next_hop] => [:c]
    table :min_cost, [:from, :to] => [:c]
  end

  bloom do
    path <= link {|l| [l.from, l.to, l.to, MinLattice.new(l.c)]}
    path <= (link*path).pairs(:to => :from) do |l,p|
      [l.from, p.to, l.to, p.c + l.c]
    end
    min_cost <= path {|p| [p.from, p.to, p.c]}
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{A \lang program to compute the all-pairs shortest paths of a
  graph.}
\label{fig:lattice-spaths}
\end{figure}

\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
class Bud::SetLattice < Bud::Lattice
  lattice_name :lset

  def initialize(x=[])
    @v = x     # Reject invalid input (elided)
  end

  def merge(i)
    Bud::SetLattice.new((@v + i.reveal).uniq)
  end

  morph :size
  def size
    Bud::MaxLattice.new(@v.size)
  end

  morph :intersect
  def intersect(i)
    Bud::SetLattice.new(@v & i.reveal)
  end

  morph :pro
  def pro(&blk)
    @v.map(&blk)
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{The implementation of the \texttt{lset} lattice in Ruby.}
\label{fig:lattice-set}
\end{figure}

\subsection{Integration with set-oriented logic}

\subsection{Implementation}

\begin{table*}[t]
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Name} & \textbf{Description} & \textbf{Merge} & \textbf{Morphisms} \\
\hline
\texttt{lbool} & Boolean lattice (false $\to$ true) & & \texttt{when\_true} \\
\texttt{lmax} & Max over an ordered domain & &\texttt{gt},
\texttt{gt\_eq}, \texttt{+}, \texttt{-} \\
\texttt{lmin} & Min over an ordered domain & &\texttt{lt}, \texttt{lt\_eq},
\texttt{+}, \texttt{-} \\
\texttt{lset} & Set of values & &\texttt{size}, \texttt{intersect}, \texttt{project}
\\
\texttt{lbag} & Multiset of values & &\texttt{size}, \texttt{intersect},
\texttt{project}, \texttt{mult(k)}\\
\texttt{lmap} & Map from key to lattice values & &\texttt{size},
\texttt{intersect}, \texttt{project}, \texttt{at(k)}, \texttt{key?(k)} \\
\texttt{lsum} & Sum of non-negative numbers & &\\
\hline
\end{tabular}
\caption{Builtin lattices provided by \lang.}
\label{tbl:builtin-lattices}
\end{table*}