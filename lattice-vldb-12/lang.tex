\section{Adding Lattices to Bloom}
\label{sec:lang}

In this section, we introduce \lang, an extension to Bloom that allows monotonic
programs to be written using arbitrary lattices. We begin by reviewing the
algebraic properties of lattices used in CRDTs and note the applicability of
monotone functions and morphisms in that context. We then introduce the basic
concepts of \lang and detail the builtin lattices provided by the language. We
also show how users can define their own lattice types.

% is this the right place for this?
When designing \lang, we decided to extend Bloom to include support for lattices
rather than building a new language from scratch. Hence, \lang is backward
compatible with Bloom and was implemented with relatively minor changes to the
Bud runtime. This design decision also required that we consider how code
written using lattices should interoperate with traditional Bloom relations; we
added several \lang features to ease this interoperability, which we describe in
Section~\ref{sec:bloom-interop}.

\subsection{Definitions}
\label{sec:lattice-defn}
A \emph{bounded join semilattice} is a triple $\langle S, \lor, \bot\rangle$,
where $S$ is a poset, $\lor$ is a binary operator (called ``join'' or ``least
upper bound''), and $\bot \in S$. $\lor$ is associative, commutative, and
idempotent. For all $x, y \in S$, $x \lor y = z$, where $x \leq_S z, y \leq_S
z$, and there is no $z' \ne z \in S$ such that $z' \leq_S z$ (where $\leq_S$ is
the partial order of poset $S$). Note that although the underlying set only has
a partial order, the least upper bound is defined for all elements $x,y \in
S$. The distinguished element $\bot$ is the smallest element in $S$; this
implies that $x \lor \bot = x$ for all $x \in S$. For brevity, we use the term
``lattice'' to mean ``bounded join semilattice'' in the rest of this paper. We
also use the informal term ``merge function'' to mean ``least upper bound.''

% XXX: note that algebraic properties that must be satisfied by morphisms and
% monotone functions
A \emph{monotone function} from poset $S$ to poset $T$ is a function $f: S \to
T$ such that $\forall a,b \in S: a \leq_S b \Rightarrow f(a) \leq_T f(b)$. That
is, $f$ maps elements of $S$ to elements of $T$ in a manner that is consistent
with the partial orders of both posets.

% XXX: mention that morphisms must be distributive with respect to the lub of
% their domain, whereas monotone functions don't need to be?
A \emph{morphism} from lattice $\langle X, \lor_X, \bot_X\rangle$ to lattice
$\langle Y, \lor_Y, \bot_Y\rangle$ is a function $g: X \to Y$ such that,
$\forall a,b \in X: g(a \lor_X b) = g(a) \lor_Y g(b)$. That is, $g$ allows
elements of $X$ to be converted into elements of $Y$ in a way that preserves the
lattice properties.  Note that morphisms are monotone functions but the converse
is not true in general.

\subsection{Language concepts}
\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
QUORUM_SIZE = 5
RESULT_ADDR = "example.org"

class QuorumVoteL
  include Bud

  state do
    channel :vote_chn, [:@addr, :voter_id]
    channel :result_chn, [:@addr]
    lset    :votes (*\label{line:quorum-lset-decl}*)
    lmax    :cnt
    lbool   :quorum_done
  end

  bloom do
    votes       <= vote_chn {|v| v.voter_id} (*\label{line:quorum-set-accum}*)
    cnt         <= votes.size (*\label{line:quorum-size}*)
    quorum_done <= cnt.gt_eq(QUORUM_SIZE) (*\label{line:quorum-threshold}*)
    result_chn  <~ quorum_done.when_true { [RESULT_ADDR] } (*\label{line:quorum-when-true}*)
  end
end
\end{lstlisting}
\end{scriptsize}
\caption{A monotonic \lang program that waits for a quorum of votes to be received.}
\label{fig:lattice-quorum}
\end{figure}

\lang allows both lattices and collections to be used to represent state. A
lattice is analogous to a collection type in Bloom, while a lattice element
corresponds to the particular contents of a collection. For example, the
\texttt{lset} lattice is similar to the \texttt{table} collection type provided
by Bloom; an element of the \texttt{lset} lattice is a particular set. In the
terminology of object-oriented programming, a lattice is a class that obeys a
certain interface and an element of a lattice is an instance of that
class. Figure~\ref{fig:lattice-quorum} contains an example \lang program.

As with collections, the lattices used by a \lang program are declared in a
\texttt{state} block. More precisely, a state block declaration introduces an
identifier that is associated with a lattice element; over time, the binding
between identifiers and lattice elements is updated to reflect state changes in
the program. For example, line~\ref{line:quorum-lset-decl} of
Figure~\ref{fig:lattice-quorum} declares an identifier \texttt{votes} that is
mapped to an element of the \texttt{lset} lattice. As more votes are received,
the lattice element associated with the \texttt{votes} identifier changes (it
moves ``upward'' in the \texttt{lset} lattice). When a lattice identifier is
declared, it is initially bound to the value $\bot$, the ``least element'' in
the lattice's underlying poset. For example, an \texttt{lset} lattice initially
contains the empty set.

\subsubsection{Statements in \lang}
Statements take the same form in both Bloom and \lang: \\ \noindent
\mbox{\hspace{0.25in}\emph{$<$identifier$>$ $<$op$>$
    $<$expression$>$}}\\ \noindent
The identifier on the lhs can refer to either a set-oriented collection or a
lattice. The expression on the rhs can contain both traditional relational
operators (applied to Bloom collections) and methods invoked on lattices.
Lattice methods are similar to methods in an object-oriented language and are
invoked using the standard method invocation syntax. For example,
line~\ref{line:quorum-size} of Figure~\ref{fig:lattice-quorum} invokes the
\texttt{size} method on an element of the \texttt{lset} lattice.

If the lhs of a statement is a lattice, the statement's operator must be either
\verb|<=| or \verb|<+| (instantaneous or deferred deduction, respectively). The
meaning of this operator is that, at either the current or the following
timestep, the lhs identifier will take on the result of applying the lattice's
least upper bound to the lhs and rhs lattice elements. The intuition remains the
same as in Bloom: the rhs value is ``merged into'' the lhs lattice, except that
the semantics of the merge operation are defined by the lattice's least upper
bound operator. We require that the lhs and rhs refer to a lattice of the same
type.

\lang does not currently support a notion of deletion (\verb|<-| operator) for
lattices. Lattices do not directly support asynchronous communication (via the
\verb|<~| operator) but lattice elements can be embedded into tuples that appear
in channels (Section~\ref{sec:bloom-interop}).

\subsubsection{Lattice methods}
\lang statements compute values over lattices by invoking methods on lattice
elements. Just as a subset of the relational operators are monotonic, some
lattice methods are monotone functions (as defined in
Section~\ref{sec:lattice-defn}). A monotone lattice method guarantees that, if
the lattice on which the method is invoked grows (according to the lattice's
partial order), the value returned by the method will grow (according to the
return value's lattice type). From a CRDT perspective, a lattice's monotone
methods are a ``safe'' set of operations that can be invoked in a distributed
setting without risk of inconsistency.

A lattice method's signature indicates its monotonicity properties. More
precisely, \lang distinguishes between methods that are monotone and a subset of
monotone methods that are \emph{morphisms}. The properties that a morphism must
satisfy are given formally in Section~\ref{sec:lattice-defn}, but the intuition
is that a morphism on lattice $T$ can be distributed over $T$'s least upper
bound operator. This allows a variant of semi-naive evaluation for lattice
programs, as we discuss further in Section~\ref{sec:lattice-eval-strat}.

Lattices can also define non-monotonic methods. Using a non-monotonic lattice
method is analogous to using a non-monotonic relational operator in Bloom: the
Bud interpreter stratifies the program to ensure that the input value is
computed to completion before allowing the non-monotonic operator to be invoked. This
implies that programs with cycles through non-monotonic lattice methods will be
rejected. \lang encourages developers to minimize the use of non-monotonic
constructs: as the CALM analysis suggests, non-monotonic reasoning may need to
be augmented with coordination to ensure consistent results.

Every lattice defines a non-monotonic \texttt{reveal} method that returns a
representation of the lattice element as a plain Ruby value. For example, the
\texttt{reveal} method on a \texttt{lset} lattice returns a Ruby array
containing the contents of the set. This is non-monotonic because once the
underlying Ruby value has been extracted from the set, \lang cannot ensure that
subsequent code uses the value in a monotonic fashion.

\subsection{Builtin lattices}
\label{sec:lattice-builtins}

\begin{table*}[t]
\begin{center}
\begin{tabular}{|l|l|l|l|p{1.57in}|p{1.09in}|}
\hline
\textbf{Name} & \textbf{Description} & \textbf{Least element ($\bot$)} & \textbf{Merge($a,b$)} & \textbf{Morphisms} &
\textbf{Monotone functions}\\
\hline
\hline
\texttt{lbool} & Boolean lattice (false $\to$ true) & \texttt{false} & $a \lor
b$ & \texttt{when\_true}() $\to$ \texttt{v} & \\
\hline
\texttt{lmax} & Max over an ordered domain & $-\infty$ & $max(a, b)$ &
\texttt{gt(n)} $\to$ \texttt{lbool}\newline
\texttt{gt\_eq(n)} $\to$ \texttt{lbool}\newline
\texttt{$\mathtt{+}$(lmax)} $\to$ \texttt{lmax}\newline
\texttt{$\mathtt{-}{}$(lmax)} $\to$ \texttt{lmax} & \\
\hline
\texttt{lmin} & Min over an ordered domain & $\infty$ & $min(a, b)$ &
\texttt{lt(n)} $\to$ \texttt{lbool}\newline
\texttt{lt\_eq(n)} $\to$ \texttt{lbool}\newline
\texttt{$\mathtt{+}$(lmin)} $\to$ \texttt{lmin}\newline
\texttt{$\mathtt{-}{}$(lmin)} $\to$ \texttt{lmin} & \\
\hline
\texttt{lset} & Set of values & empty set & $a \cup b$ &
\texttt{intersect(lset)} $\to$ \texttt{lset}\newline
\texttt{product(lset)} $\to$ \texttt{lset}\newline
\texttt{project(lset)} $\to$ \texttt{lset}\newline
\texttt{contains?(v)} $\to$ \texttt{lbool}
& \texttt{size()} $\to$ \texttt{lmax}\\
\hline
\texttt{lpset} & Set of non-negative numbers & empty set & $a \cup b$ &
\texttt{intersect(lpset)} $\to$ \texttt{lpset}\newline
\texttt{product(lpset)} $\to$ \texttt{lpset}\newline
\texttt{project(lpset)} $\to$ \texttt{lpset}\newline
\texttt{contains?(v)} $\to$ \texttt{lbool}
& \texttt{size()} $\to$ \texttt{lmax}\newline
\texttt{sum()} $\to$ \texttt{lmax} \\
\hline
\texttt{lbag} & Multiset of values & empty multiset & $a \cup b$ &
\texttt{intersect(lbag)} $\to$ \texttt{lbag}\newline
\texttt{project(lbag)} $\to$ \texttt{lbag}\newline
\texttt{mult(v)} $\to$ \texttt{lmax}\newline
\texttt{contains?(v)} $\to$ \texttt{lbool}\newline
\texttt{$\mathtt{+}$(lbag)} $\to$ \texttt{lbag}
& \texttt{size()} $\to$ \texttt{lmax}\\
\hline
\texttt{lmap} & Map from key to lattice values & empty map & see text&
\texttt{intersect(lmap)} $\to$ \texttt{lmap}\newline
\texttt{key\_set(lmap)} $\to$ \texttt{lset}\newline
\texttt{at(v)} $\to$ \texttt{any-lattice}\newline
\texttt{key?(v)} $\to$ \texttt{lbool}
& \texttt{size()} $\to$ \texttt{lmax}\\
\hline
\end{tabular}
\caption{Builtin lattices in \lang. \texttt{v} denotes a Ruby value and
  \texttt{n} denotes a number.}
\label{tbl:builtin-lattices}
\end{center}
\end{table*}


Table~\ref{tbl:builtin-lattices} lists the lattices provided by \lang. The
builtin lattices provide support for several different notions of ``progress'':
a predicate that moves from false to true (\texttt{lbool}), a numeric value that
increases or decreases (\texttt{lmax} and \texttt{lmin}, respectively), and
various kinds of collections that grow over time (\texttt{lset}, \texttt{lpset},
\texttt{lbag}, and \texttt{lmap}). The behavior of most of the lattice methods
should be unsurprising, so we do not describe every method in this section.

The \texttt{lbool} lattice is useful for representing conditions that, once
satisfied, remain satisfied. For example, the \texttt{gt} morphism on the
\texttt{lmax} lattice takes a numeric argument $n$ and returns an
\texttt{lbool}; once the \texttt{lmax} exceeds $n$, it will remain $>n$. The
\texttt{when\_true} morphism takes a Ruby block; if the \texttt{lbool} element
has the value \texttt{true}, \texttt{when\_true} returns the result of
evaluating the block. For example, see line~\ref{line:quorum-when-true} in
Figure~\ref{fig:lattice-quorum}. \texttt{when\_true} is similar to an ``if''
statement.\footnote{Observe that an ``else'' clause would test for an upper bound on the final lattice value, which is a non-monotonic property!}

The \texttt{lmap} lattice associates keys with values. Keys are normal Ruby
objects and values are lattice elements. For example, a web application could
use an \texttt{lmap} to associate session IDs with an \texttt{lset} containing
the pages visited by that session. The \texttt{lmap} merge function takes the
union of the key sets of its input maps. If a key occurs in both inputs, the two
corresponding values are merged using the appropriate lattice merge function.

Several lattices provide \texttt{size}, a monotone function that is not a
morphism. This is because \texttt{size} cannot be distributed over the merge
functions of those lattices. For example, consider two elements of the
\texttt{lset} lattice, $\{1,2\}$ and $\{2,3\}$.  We can see that \texttt{size} is not a morphism because $size(\{1,2\} \lor_{\mathtt{lset}}
\{2,3\}) \ne size(\{1,2\}) \lor_{\mathtt{lmax}} size(\{2,3\})$.

The \texttt{lpset} lattice is an example of how \lang can be used to encode
domain-specific knowledge about an application. If the developer knows that a
set will contain only non-negative numbers, the sum of those numbers increases
monotonically as the set grows. Hence, \texttt{sum} is a monotone function of
\texttt{lpset}. Inserting a negative value (or a non-number) into an
\texttt{lpset} results in a Ruby exception.
% Explain why sum is a monotone function?

\subsection{User-defined lattices}
% XXX: note that we omit some methods from lset
\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}[deletekeywords={lset}]
class Bud::SetLattice < Bud::Lattice
  wrapper_name :lset (*\label{line:lset-wrapper-name}*)

  def initialize(x=[])
    # Test for valid input removed for brevity
    @v = x.uniq # Remove duplicates from input
  end

  def merge(i)
    self.class.new(@v | i.reveal)
  end

  morph :intersect do |i| (*\label{line:lset-morph-begin}*)
    self.class.new(@v & i.reveal) (*\label{line:lset-reveal}*)
  end (*\label{line:lset-morph-end}*)

  morph :contains? do |i|
    Bud::BoolLattice.new(@v.member? i)
  end

  monotone :size do (*\label{line:lset-monotone-begin}*)
    Bud::MaxLattice.new(@v.size)
  end (*\label{line:lset-monotone-end}*)
end
\end{lstlisting}
\end{scriptsize}
\caption{The implementation of the \texttt{lset} lattice in Bud.}
\label{fig:lattice-lset}
\end{figure}

\label{sec:lattice-api}
The builtin lattices provided by \lang are sufficient to express many
distributed protocols---for example, the causal delivery protocol described in
Section~\ref{sec:causal}. However, \lang also allows developers to create
custom lattices to capture domain-specific behavior. To define a lattice, a
developer creates a Ruby class that meets a certain API
contract. Figure~\ref{fig:lattice-lset} contains the Ruby code that implements
the \texttt{lset} lattice.

A lattice class must inherit from the builtin \texttt{Bud::Lattice} class and
must also define two methods:
\begin{itemize}
\item \texttt{initialize(i)}: given a Ruby object $i$, this method constructs a
  new lattice element that ``wraps'' $i$ (\texttt{initialize} is the standard
  Ruby syntax for defining a constructor). If $i$ is \texttt{nil} (the null
  reference), this method returns $\bot$, the least element of the lattice.

\item \texttt{merge(e)}: given a lattice element $e$, this method returns the
  least upper bound of \emph{self} and \emph{e}. This method must satisfy the
  algebraic properties of least upper bound as summarized in
  Section~\ref{sec:lattice-defn}---in particular, it must be commutative,
  associative, and idempotent. Note that \emph{e} and \emph{self} must be
  instances of the same class.
\end{itemize}
In addition to the constructor and the merge method, lattices can also define
any number of monotone functions, morphisms, and non-monotonic methods. The
syntax for declaring morphisms and monotone functions can be seen in
lines~\ref{line:lset-morph-begin}--\ref{line:lset-morph-end} and
\ref{line:lset-monotone-begin}--\ref{line:lset-monotone-end} of
Figure~\ref{fig:lattice-lset}, respectively. Because lattice methods can contain
arbitrary Ruby code, the lattice developer should be careful to ensure that
lattice methods satisfy the appropriate algebraic properties. For example,
implementing a lattice method might require examining the underlying Ruby value
contained in another lattice element. This can be done using the \texttt{reveal}
method (e.g., line~\ref{line:lset-reveal} in Figure~\ref{fig:lattice-lset}).
Since \texttt{reveal} is not itself monotonic, lattice developers should use it
carefully when implementing monotone functions and morphisms.
% Tweak this text

Because Ruby is dynamically typed, there will often be constraints on the legal
inputs to these functions that cannot be enforced until runtime. For example,
initializing a \texttt{lbool} lattice with a non-boolean value is not
supported. The developer of a lattice implementation should check for invalid
inputs and signal errors by raising a Ruby exception.

Lattice elements are \emph{immutable} (e.g., \texttt{merge} functions construct
a new lattice element rather than destructively modifying one of their
inputs). Efficient lattice implementations will often \emph{share structure} on merge
operations, as is common practice for immutable data structures in functional
programming languages~\cite{Okasaki1999}. % XXX: not the right place for this?

% XXX: awkward placement for this paragraph
Finally, custom lattices must define a keyword that can be used in \lang state
blocks. This is done using the \texttt{wrapper\_name} class method. For example,
line~\ref{line:lset-wrapper-name} of Figure~\ref{fig:lattice-lset} means that
``\texttt{lset :foo}'' in a \lang state block will introduce an identifier
\texttt{foo} that is associated with an instance of the \texttt{Bud::SetLattice}
class.

\subsection{Integration with set-oriented logic}
\label{sec:bloom-interop}
\lang provides two features to ease integration of lattice-based code with
traditional Bloom programs that manipulate set-oriented collections.

\subsubsection{Converting collections into lattices}
% XXX: this ignores the fact that Bloom collections consist of sets of tuples,
% whereas implicit fold works for sets of singleton values
% XXX: refer to shortest paths program as practical example
This feature enables an intuitive syntax for merging the contents of a
set-oriented collection into a lattice. If a statement has a Bloom collection on
the rhs and a lattice on the lhs, the collection is converted into a lattice
element by ``folding'' the lattice's merge function over the collection. That
is, each element of the collection is converted to a lattice element (by
invoking the lattice constructor), and then the set of lattice elements are
merged together via repeated application of the lattice's \texttt{merge}
method. In our experience, this is usually the behavior intended by the user.

For example, line~\ref{line:quorum-set-accum} of Figure~\ref{fig:lattice-quorum}
contains a Bloom collection on the rhs and an \texttt{lset} lattice on the
lhs. This statement is implemented by constructing a singleton \texttt{lset} for
each element of the rhs collection and then merging the sets together. The
resulting \texttt{lset} is then merged with the \texttt{votes} lattice
referenced by the lhs.

\subsubsection{Collections with embedded lattice values}
\label{sec:lattice-embedding}

\jmh{You know my gripes here.}

It would be convenient to allow lattice elements to be used as attributes of
tuples in Bloom collections. In addition to easing interoperability, Bloom
provides several facilities (e.g., network communication, persistent storage,
module interfaces) as collections with special semantics.  It would be
unfortunate if a redundant set of facilities was required to support
lattice-based code. A simple solution would be to extract the underlying Ruby
value from the lattice element (e.g., using the \texttt{reveal} method).
However, that would introduce needless non-monotonicity into the program.

Storing lattice elements as attributes of tuples in set-oriented collections
introduces several challenges. Consider a simple \lang statement that derives
tuples with a lattice element as an attribute:
\begin{verbatim}
    t1 <= t2 {|t| [t.x, lat_foo]}
\end{verbatim}
where \texttt{t1} and \texttt{t2} are Bloom relations and \texttt{lat\_foo}
identifies a lattice; suppose that the first column of \texttt{t1} is the
relation's key. The value associated with \texttt{lat\_foo} can change over the
course of the fixpoint computation (specifically, it can grow ``upward''
according to the lattice's partial order, as more values are merged into the
lattice). Implemented naively, this might result in multiple \texttt{t1} tuples
with different values for the second attribute, which would violate
\texttt{t1}'s key (the first column of \texttt{t1} would not functionally
determine a single value for the second column).

This problem could be avoided by placing constraints on the evaluation order of
statements: for example, we could require that all potential changes to
\texttt{lat\_foo} be completed before statements that embed \texttt{lat\_foo}
could be evaluated. This would effectively stratify the program according to
lattice embedding statements and disallow cycles through lattice
embeddings~\cite{Apt1988}. This would reduce the expressiveness of the language;
it also seems unsatisfying to require stratification of monotonic programs.

% Clarify this
Instead, \lang allows statements to produce multiple tuples that differ only in
their embedded lattice values. During the course of the fixpoint computation,
those values are merged together using the appropriate lattice merge
function. This is safe because Bud stratifies programs according to
non-monotonic operators; hence, any operators that might be applied to an
embedded lattice value before it has been determined exactly must be
monotonic. Nevertheless, this solution is somewhat counterintuitive because
tuples in Datalog relations are traditionally immutable: once a fact is known to
be true, its value remains the same.

% Should we note that we might add an option to disable this behavior for
% particular attributes, or explain more about why this might be considered
% weird?

For similar reasons, we currently disallow lattice values from being used as
keys in Bloom collections. It might be possible to relax this restriction in
certain ``safe'' cases, but we have not found this limitation to be problematic
to date.

\subsection{Confluence in \lang}
Recall that Bloom follows a timestepped execution model, where a local fixpoint
is computed at each timestep.  The fixpoint is computed over the program input
and received network messages.  The existence of this fixpoint is guaranteed by
the Knaster-Tarski theorem, assuming all \lang operators are
monotone.  The state of a program at a given timestamp is
defined to be its fixpoint at that timestep.

We can also define notions of input and output, that capture the {\em initial}
and {\em eventual} states of the program.  The {\em input} to a \lang program is
defined to be the initial contents of a set of special {\em input} relations or
lattices, which are inflationary over time, and may not occur in the head of
rules.  The input to a program contains information about the partitioning of
input values between the nodes.  The {\em ultimate model}, or eventual state of
the program, is defined to be the eventual contents of a union across all nodes
of a set of special {\em output} relations or lattices, which are inflationary
over time, regardless of whether the \lang program is monotonic.  These special
lattices may only appear in a rule's body.  Like the input, information about
the partitioning of the output between the nodes is included in the output.

A Bloom program is {\em confluent} if, for each input to the program, there is a
unique ultimate model.  The existence of a unique ultimate model implies that
non-determinism in message ordering does not affect the program result, which is
sometimes a desirable correctness criterion for distributed programs.  If a
Bloom program is monotonic, and does not exhibit message loss, then it is
confluent \wrm{Though, this isn't proved in any publication}.  Similarly, if a
\lang program is monotonic and has no message loss, then it is confluent because
local fixpoints of monotonic operators are being computed over lattices that are
inflating over time.
