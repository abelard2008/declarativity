\chapter[Dissertation Overview]{Dissertation Overview}
\label{ch:overview}

There has been renewed interest in recent years on applying declarative
languages to a variety of applications outside the traditional boundaries of
data management.  Examples include work on compilers~\cite{lam05context},
computer games~\cite{white-sigmod07}, security protocols~\cite{li-padl03}, and
modular robotics~\cite{ashley-iros07}.  Our work in this area began with the
{\em Declarative Networking} project, as instantiated by the {\em P2} system
for Internet overlays~\cite{p2:sosp, loo-sigmod06}.  The P2 project
demonstrated the viability of declarative languages as being a natural fit for
programming network overlay protocols.  In Chapter~\ref{ch:p2}, we review this
influential work because it sets the stage for this thesis.  Specifically, we
describe the declarative language \OVERLOG\@ --- a dialect of Datalog --- and
the P2 system, which compiles \OVERLOG programs into dataflow runtime
implementations reminiscent of traditional database query plans.

Following the background material, Chapter~\ref{ch:evita} describes a
declarative system component called Evita Raced, which is a metacompiler
implemented in P2.  Evita Raced formulates the task of query compilation as a
query; written in the same declarative language (\OVERLOG) used by ``client''
queries: such as the various networking protocols from Loo, et
al.~\cite{loo-sigmod06, p2:sosp}.  Evita Raced exposes the P2 compiler state to
the \OVERLOG language (Chapter~\ref{ch:evita:sec:compile}), thereby permitting
the specification of query transformations (i.e., optimizations) in \OVERLOG.
Many traditional database optimizations, like the magic-sets rewrite
(Chapter~\ref{ch:magic}), the System R dynamic program
(Chapter~\ref{ch:opt:sec:systemr}), and the Cascades branch-and-bound algorithm
(Chapter~\ref{ch:opt:sec:cascades}), can be fully expressed as \OVERLOG
queries.  Specifying these optimizations as \OVERLOG queries results in a more
concise representation of the {\em algorithm as code} and a dramatic reduction
in the overall development effort.  We reflect on the practicalities of a
declarative approach to query compilation and our overall experience with Evita
Raced in Chapter~\ref{ch:evitaend}.

In Chapter~\ref{ch:cloud}, we turn to the topic of {\em cloud
computing}~\cite{abovetheclouds} and introduce the \BOOM project: an effort to
explore implementing cloud software using declarative, data-centric languages.
As a first concrete exercise, we built \BOOMA: an API-compliant
reimplementation of Hadoop MapReduce in a declarative language.  In
Chapter~\ref{ch:hadoop}, we review the salient aspects of Hadoop and the
MapReduce programming model that it implements.  In Chapter~\ref{ch:boom}, we
describe our rewrite of the Hadoop scheduler in a declarative language and show
that equivalent performance, fault-tolerance, and scalability properties can be
achieved in a declarative language.  In Chapter~\ref{ch:hop}, we evolve the
batch-oriented data flow implemented by Hadoop to a more online execution model
that pipelines data between operators.  We then describe extra scheduling
policies implemented in the declarative scheduler that accommodate pipelined plans.
Finally, we conclude in Chapter~\ref{ch:conclusion} with a discussion of future
directions.


%Hadoop is an open source software project that
%implements the MapReduce programming model~\cite{mapreduce-osdi}.  In our work
%here, we focus on the Hadoop task scheduler, which is responsible for
%scheduling computation tasks on (distributed) machines in a data center.  
%The scheduler code is written in the (relatively) low-level Java
%language. In our work here, we describe a declarative implementation
%of Hadoop that models the Hadoop architecture and expresses scheduling policies
%in a declarative language.


%We conjecture that building and debugging distributed
%software like Hadoop can be extremely difficult in such a procedural language.
%We evaluate our conjecture by adopting a {\em data-centric} approach to system
%design that recasts the logic of a  in a declarative programming language.
%Our goal here is to raise the programming abstraction to a level that improves
%code simplicity, speed of development, ease of software evolution, and overall
%program correctness.

