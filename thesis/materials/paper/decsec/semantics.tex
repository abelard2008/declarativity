\section{Semantics}\label{semantics}

\subsection{Compound Tuple Primitive}
\begin{code}
someRule: ParentTableName(...,field-set, \\
\> [child-key, LocationSpecifier], ...):- ....,\\
\> ChildTableName(...,field-set, @LocationSpecifier,...) 
\end{code}

Here, we are linking a tuple of type ParentTableName table to contain a reference to the tuple of type ChildTableName. The information that appears in the square brackets on the left side of the delimiter, enables the implementation to unambiguously locate the ChildTableName tuples the programmer intend to be linked to the ParentTableName tuple. Finally, we describe the semantics of using this ParentTableName tuple to extract the included ChildTableName tuples.

\begin{code}
someRule: .... :- ParentTableName(...,field-set, \\
\> LocationSpecifier, ...), \\
\> ChildTableName(...,field-set,@LocationSpecifier,...) 
\end{code}

This code snippet illustrates how to extract the embedded ChildTapleName tuples within a ParentTableName tuple. This extraction process can be repeated further to extract the tuples embedded in the ChildTableName tuple. Let's extend our earlier example to see how a node receiving the parent tuple would fetch the child tuples.

\begin{code}
r1: log(@Me, Z, A, C):- parent(@Z, A, B, S),\\
\> child(@S, A, C), link(@Me, Z)
\end{code}

Now that we have described how compound tuples can be build and parsed, let's look at their usage in secure and insecure settings.


\subsubsection{Authenticating Compound Statements}

Saying compound statement is quite similar to saying simple statements except that compound statements have strong links to other links. So, when a says primitive is used on a compound tuple, it implies that all the tuples strongly linked from the root tuple must also be {\em said}. The creation of compound says statement is no different from embedding a compound statement into another. The implementation transparently ensures that the strongly linked tuples are securely transported. Similarly, parsing a secure compound statement is quite similar to parsing a deepcopied compound statement with the only difference being that the says statement appears before all the parsed components of compound tuples. We will illustrate the use of compound authenticated statements through several scenarios.

\noindent\textbf{Case 1: A principal wants to make a compound statement comprising of only local tuples to another principal }

Let the root tuple be a tuple of table parent and the tuple referenced by this tuple be a tuple of child table. In this case, a parent commits the value collected from a child and the result of computing some complex function on that child's value.

\begin{code}
\textit{Materialize}(parent, infinity, infinity, key(2))\\
\textit{Materialize}(child, infinity, infinity, key(2))\\
\textit{StrongReferences}(parent, field-set(2), child, \\
\> field-set(2), version(4))
\end{code}

\noindent\underline{Rules Executed at Sender side}
\begin{code}
child(@Me, Me, value) \\
parent(@Me, Me, Func, Me):- \\
\> child(@Me, Me, value), Func = f\_someFunc(value) \\
says@Z(Me, Z, 1, U) <parent(@Me, Me, Func, Me)> :- \\
\> parent(@Me, Me,  Func, Me), auditor(@Me, Z)
\end{code}

In this case, all the location specifiers at the sender side are kept to default value(\textit{@LocalLocationIdentifier = @Me}) to indicate that the currently active copy of these tuples should be exported.

\noindent\underline{Rules Executed at Receiver Side}
\begin{code}
log(@Me, N, V, F):- child(@S, N, V), \\
\> says@Me(N, Me, 1, U) <parent(@S, N, F, S)>
\end{code}

In this case, at the receivers side, all the location specifiers in this compound tuple will be the same. 

\noindent\textbf{Case 3: A principal wants to make a compound statement of multiple local tuples}

Lets extend the earlier example to possibly include several tuples. We modify the child table a bit to extend the key to include both the child and parent.

\begin{code}
\textit{Materialize}(parent, infinity, infinity, key(2))\\
\textit{Materialize}(child, infinity, infinity, key(2,3))\\
\textit{StrongReferences}(parent, field-set(2), child, \\
\> field-set(2), version(4))
\end{code}

\noindent\underline{Rules Executed at Sender side}

\begin{code}
child(@Me, Me, C, value)\\
parent(@Me, Me, f\_someFunc<value>, Me):- \\
\> child(@Me, Me, C, value)\\
says@Z(Me, Z, 1, U) <parent(@Me, Me, Func, Me)> :- \\
\> parent(@Me, Me,  Func, Me), auditor(@Me, Z)
\end{code}

As before, all the location specifiers are still set to default values

\noindent\underline{Rules Executed at Receiver Side}

\begin{code}
log(@Me, P, N, C, V, F):- \\
\> says@Me(P, Me, 1, U) <parent(@S, N, F, S)>, \\
\> says@Me(N, $\phi$, 1, U) <child(@S, N, C, V)>
\end{code}

The runtime automatically collects all the matching child tuples and includes them in the compound statement. Alternatively, if a non-default version of these tuples need to be included in the statement (for example, something that was said several versions ago and is no longer current), then the approach described in the next scenario can be used.


