\section{Implementation} 

Our implementation of the authentication and DADS primitives is primarily in form of rewrites of the Syslog language. Thus, in the first step, we construct a compiler that can process a language with DADS(let's call it DDlog) and output a program which with some minor additions to the runtime, can be executed on the existing runtime for executing Overlog code. Next, we build another compiler that can take our syslog code and process authentication primitive to produce code compatible with the DADS compiler (modulo the changes to Overlog and DADS runtime). Besides the convenience and modularity of a rewrite based implementation approach, it imposes an important invariant on our design to be relational. We strived to make our design and implementation relational and by ensuring that our final implementation can be expressed in a relational language, we ascertain that it is indeed the case. We look at each of these rewrites in this section.

\subsection{DADS}

Intuitively, a DADS is represented by a set of {\em versioned tuples} and a set of {\em link tuples}. The {\em versioned tuples} store the actual data values of a DADS and the {\em link tuples} store the connectivity information of the tuples. A tuple is always exported with the link information associated with all the links of that tuple. Our transformations create rules and tables that create and export the versioning and link information of a DADS. This is done by converting the new predicates into new events for the corresponding tuples. These events then trigger the constructor rules. The constructor rules lead to creation of the link and version tuples for the DADS. Finally, the new event for the root of the DADS also leads to creation of a processTuple which is materialized tuple that is created at the end of the fix-point. The processTuple triggers a serialization function that parses the DADS graph and serializes all the tuples into an opaque buffer which is sent to the destination where it is deserialized.

We first describe the list of tables we create briefly outlining the purpose of each table we create. Later, we describe transformations that create and use these tables. 

\noindent\textit{\textbf{versionTable:}} In presence of DADS, it becomes essential to distinguish between different versions of a tuple. This is because keys simply don't suffice as we can now have different tuples with same keys placed under different location specifiers. Now, even though conceptually, location specifiers present the semantics of a snapshot, they're implemented as versioned tuples in our system. However, since only materialized tuples can be included in a DADS, we only need to maintain versions for tuples which are already materialized. Thus, a simple approach we adopt is to augment the tuples with a version field. The key of a table now comprises of the key provided in the specification and the version field. All the unversioned tuples are also versioned with a default version. Note that we don't really create a new table but instead modify the existing table and all its references to include the version field. 

\noindent\textit{\textbf{LocationSpecifierTable:}} LocationSpecifierTable maintains the location specifier to version and principal/node mapping for each tuple. Recall that semantically, location specifiers can be used in place of location. Thus, location specifiers must encode enough information to detect the source node and the referred tuple at that node. The location specifier table has the following structure:

\begin{center}
locationSpecifierTable(@N, locationSpecifier, Location, Version)
\end{center}

The location field specifies the node on which the tuple actually exists. We require the uniqueness of versions across different nodes. i.e. two nodes A and B shouldn't be creating a version V with different data. This can be enforced by making the version, a combination of creating node's id and the version number (similar to version vectors). Generally speaking, location and version fields are globally unique identifiers. The indirection through the location specifier to version exposes the possibility of reusing common tuples across different DADS. This is partly possible because of the immutability of the (non-current) versioned tuples. Thus, versioned tuples can be included in several graphs without the risk of violating consistency. Another advantage of this indirection is that the referring tuple and the referred tuple are decouple location-wise allowing them to reside on different nodes. This exposes a possibility of application specific optimization of export policies. 

Now that we have described the implementation tables for DADS, lets outline the mechanism of creating and accessing DADS tuples. 

A DADS is created by a DADS creator rule. These rules have {\em new} primitive on the head of the rule. The new primitive is transformed into a new event during the rewrite stage. This new event triggers all the constructor rules associated with tuples of the head type. In fact, to be precise, a new primitive is transformed into one new event for each new location specifier it contains and each such new event triggers the constructors associated with the head tuple and filling up the newly created link position. This process is recursively repeated as the constructor rules can be the creator rules for other linked tuples. 

Once, no more new events can be created, materialization phase begins. In this phase, the locationSpecifierTable tuples and version tuples are created for the DADS generated in this fix-point. Also, a process tuple is created for root tuples. All this materialization takes place at the end of the fix-point. Our rewrite stages add another rule that takes a process tuple and serializes the linked graph into an opaque buffer. This opaque buffer contains all the tuples that are necessary to export this graph according to the export policy (push/pull etc). The serialized buffer is then exported as a sendTuple event. This rules generating this event are also produced by our rewrite stages.

The implementation described above works for deals weakly linked DADS. However, strong links in a DADS require a bit of an additional effort. One of the major differences between strong links and weak links is in the use of strong location specifier and strong versions as opposed to normal location specifiers and versions. A normal location specifier or version is simply a globally unique identifier. Thus, any malicious man-in-the middle node can modify the sender's data and replace it. However, a strongly version and location specifier contains a self-certifying hash of the data contained in the tuple. So, a strong version will also include a self-certifying hash of the contents of the data tuple along with the unique identifier. Similarly, a strong location specifier also has the hash of {\em all} the linked version tuples. Since multiple version tuples can be linked with the same location specifier, the hash in location specifier is essentially a merkle hash of the hashes of the linked version tuples. 

This ensures that the integrity of the DADS sent by the original sender is preserved. That is, if the root reaches the destination correctly, then the rest of the strongly linked graph will also be correctly received. A man-in the middle in this case can mount a DOS attack but can't compromise the safety. To better support the location independence of our DADS tuples, we need to ensure that even if only a subset of location specifier tuples are received, the receiver must be able to validate and process them. It's not difficult to do this for weak links as weak locationSpecifier tuples don't require any validation. However, strong location specifier tuple require validation that checks the self-certifying hash of the location specifier against the hashes of all the version tuples. This will prevent any progress from being made until all the locationSpecifier tuples have been received. To ensure processing of partially received strong locationSpecifierTuple set, we introduce another table called {\em linkExpanderTable}.

\noindent\textit{\textbf{linkExpanderTable:}} A linkExpanderTable represents a merkle link for the strong links in DADS. It gives the set of hashes corresponding to the linked version tuples and their summarized hash. A node receiving a linkExpanderTable validates that the hash of the set of hashes must match the summarized hash. If the hashes don't match, the linkExpanderTable tuple is discarded, otherwise its accepted. A linkExpanderTuple thus has the following structure:

\begin{center}
linkExpanderTable(@N, locationSpecifierHash, Set<VersionHashes>)
\end{center}

The transformations for accessing strong links also change to check if a linkExpanderTuple exists whose summarized hash matches that hash of the locationSpecifierTable and whose set of hashes contain the hash of the version tuple hash. This check ensures that tuples can be {\em safely} processed even when all of the locationSpecifierTuples have not been received.

The self-certifying hash help ensuring the integrity property across the DADS. This is done recursively through a merkle-tree like construct. The self-certifying hash of a tuple comprises of all the non-key fields of the tuple, and the hash component of the strong links. Note that neither the weak links' location specifier, nor the unique identifier part of the strong links is included in calculating the self certifying hash for the tuple. This is done to ensure that the secure link can be copied and replicated without complicating the implementation significantly. Thus, when this approach of constructing DADS is followed recursively, a merkle-tree like construct extending the strongly connected part of the DADS is created. 

However, a key challenge introduced by the presence of self-certifying hashes is that the parent's hash can't be determined until all its children have been recursively constructed and their hashes finalized. This introduces slight complication in our serialization mechanism as now before serialization, the graph needs to be {\em secured}. {Securing} a graph involves creating self-certifying hashes for the strongly linked tuples in a bottom-up manner. Currently, serialization function also performs the task of securing a graph.
%However, note that we have both strong and weak links. Even though the implementation of both strong and weak links uses both the above mentioned tables, the semantics of location specifier and version field changes between strong and weak location specifier. Strong links have strong location specifier and are linked to strong version tuples. Strong version tuples have strong versions. A strong version or location specifier can be thought of the global unique identifier information (from the weak version and location specifier) and a secure hash. A strong version field is a self-certifying version field whose hash part is calculated over all the fields of the tuple excluding the location field, the version field, any weak link field, and the unique identifier part of the strong links. 


\subsection{Authenticated Tuples}

\noindent\textit{\textbf{Simple Tuple:}} Let's first consider how an authenticated statement about a {\em simple tuple} can be made. Here, a simple tuple implies that it has no links, i.e. no foreign fields. So, we only want to be able to make statements about such tuples and possibly quote such simple tuples to others. For this purpose, we introduce a {\em saysTable} for each table {\em Table}. This table has the following structure:

\begin{center}
saysTable(@S, P, R, k, V, Proof, ...fields from original Table...)
\end{center}


Here, $Proof$ denotes the proof of the authenticity of this tuple according the says params {\em P, R, K and V}. An entry in says table appears only when a proof that satisfies the requirements of the corresponding authenticate primitive is available. Whenever a principal makes a says statement to another principal, the implementation takes care of ensuring that the appropriate proof is also exported. On receiving the proof and the corresponding tuple, the implementation on the receiving principals side verifies the proof against the tuple and if found valid, an entry is installed in the says table. @S is the location specifier of the node/DADS where the says tuple resides. The main goal of our declarative approach is to hide the proofs from the programmer allowing him to focus on the properties expressed in form of primitives rather than how these properties are precisely implemented. Thus, proofs are kept hidden from the programmer. 

This tuple is installed at the receiver only after verifying the correctness of the proof with respect to the says params and the data contained in the original tuple. This tuple can be created in of the following ways:
\be
\item By serializing the content of the tuple and signing it using a key that satisfies the says params
\item By using the proof from a saysTable tuple that has {\em stronger} says params than the desired says params 
\item By combining the proofs from multiple saysTable tuples that, using the {\em combination algebra} given in earlier section, can produce a says params {\em stronger} than the desired says params. We currently do this only for simple tuples. For compound tuples, as discussed below, the programmer needs to write rules that incorporate the authentication algebra.
\ee

\noindent\textit{\textbf{DADS:}} Authenticated DADS are produced and validated in a way similar to above with one key difference. Since DADS tuples can have {\em strong links} to other tuples, the hash for signing must be calculated as described in the previous section: i.e. hash should be calculated over the non-link fields non-location specifier fields and the certifying hash of the strong links. This ensures that signing the root also extends the property of the says primitive to the strongly linked portions of the graph. This might require that the signing can not be done before the {\em securing} phase is over as that is when the certifying hashes will be installed. Other than that, there's one more difference between the semantics associated with authenticated DADS and authenticated normal tuples.

Since, DADS are immutable, it is not possible to automatically combine two DADS authenticated tuples to produce and a combined authenticated DADS tuple that also is a part of DADS. Thus, we don't currently perform combination algebra for DADS tuples.