\documentclass[twocolumn,10pt]{article}
%\documentclass[11pt]{article}
%\usepackage{setspace}
%\doublespacing
 
% Page layout and spacing
\usepackage[margin=1in]{geometry}
\usepackage[medium,compact]{titlesec}

% Formatting
\usepackage{alltt}
\usepackage{url}
% Type1 fonts please!
\usepackage[T1]{fontenc}
%\usepackage{times,courier,mathptmx}
\usepackage{times}
\usepackage{textcomp}

\usepackage[tight]{subfigure}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{epsfig}
\usepackage{cite}
\usepackage{color}
\usepackage{xspace}
\newcommand{\delete}[1]{}
%\usepackage{usenix}

\newenvironment{overlog}{\begin{alltt}\footnotesize}{\end{alltt}}
\newcommand{\ol}[1]{{\tt\footnotesize#1}}

\newenvironment{code}{\begin{tabbing}\hspace*{0.25in}\=\hspace{0.25in}\=\hspace{0.25in}\=\hspace{0.25in}\=\kill}{\end{tabbing}}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{definition}{Definition}
\newcommand{\grumbler}[2]{\begin{quote}\sl{\bf #1:} #2\end{quote}}

\newcommand{\prince}[1]{\grumbler{Prince}{#1}}

%\newcommand{\note}[1]{}
\newcommand{\note}[1]{[\textcolor{red}{\textit{#1}}]}
\newcommand{\msg}[1]{{\textsc{\small #1}}}
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\la}{$\langle$}
\newcommand{\ra}{$\rangle$}
\newcommand{\bv}{\begin{verbatim}}
\newcommand{\ev}{\end{verbatim}}
\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}

\newcommand{\squishlist}{
   \begin{list}{$\bullet$}
    { \setlength{\itemsep}{0pt}      \setlength{\parsep}{3pt}
      \setlength{\topsep}{3pt}       \setlength{\partopsep}{0pt}
      \setlength{\leftmargin}{1.5em} \setlength{\labelwidth}{1em}
      \setlength{\labelsep}{0.5em} } }

\newcommand{\squishlisttwo}{
   \begin{list}{$\bullet$}
    { \setlength{\itemsep}{0pt}    \setlength{\parsep}{0pt}
      \setlength{\topsep}{0pt}     \setlength{\partopsep}{0pt}
      \setlength{\leftmargin}{2em} \setlength{\labelwidth}{1.5em}
      \setlength{\labelsep}{0.5em} } }

\newcommand{\squishend}{
    \end{list}  }

\newcommand{\squishsettings}{
  { \setlength{\itemsep}{0pt}
    \setlength{\parsep}{3pt}
    \setlength{\topsep}{3pt}
    \setlength{\partopsep}{0pt}
    \setlength{\leftmargin}{1.5em}
    \setlength{\labelwidth}{1em}
    \setlength{\labelsep}{0.5em}
  }
}



\title{Authenticated Distributed Data for Declarative Networking Systems}

\author{Prince Mahajan, Petros Maniatis and Mike Dahlin}

\date{}

% make the bibliography compact
\let\oldthebibliography=\thebibliography
\let\endoldthebibliography=\endthebibliography
\renewenvironment{thebibliography}[1]{%
    \begin{oldthebibliography}{#1}%
    \small
    \setlength{\parskip}{0ex}%
    \setlength{\itemsep}{0ex}%
}%
{%
    \end{oldthebibliography}%
}

\begin{document}

%\linespread{.97}
\maketitle

\begin{abstract}
%\small Your abst
Research middleware such as P2, Mace, and WiDS have taken great strides
towards specifying and automatically building complex distributed
applications from a concise, high-level, implementation unspecific
description. However, though powerful, such systems still lack
the fundamental language and semantics needed to talk about complex,
structured application data, and their security and distribution requirements.

In this work, we define the notion of distributed abstract data
structures (DADS). DADS allow a programmer to specify how application
data are logically structured, the parts of the structure that require
integrity, and those that require fate-sharing (i.e., to travel
together), without explicitly micromanaging at which network node each
component will ultimately live. Depending on a run-time policy, such a
data structure might be pushed in its entirety from a sender to a
receiver, might be pulled selectively by the receiver's access patterns,
or a combination of both, leading to great potential for
optimized performance under different network conditions.

Furthermore, we define high-level authentication primitives for DADS,
reminiscent of the ``says'' construct in BAN logic. These primitives
enables programmers to specify precisely the authentication requirements
of their application and data in terms of principals, without getting
bogged down with the details of particular cryptosystems, libraries, or
related protocols. As a result, the same
system specification can be automatically instantiated, for example,
using shared key cryptography, public key cryptography, trusted
channels, or a combination, without violating the authentication
requirements of the programmer. Besides the performance gains from using
the cheapest crypto primitive that correctly implements the
authentication requirement, this alleviates common
pitfalls plaguing programmers who manually translate a crypto primitive
to another in ignorance of what the application's correctness
demands. We design and implement these
contributions in
the context of the P2  system, and 
show case studies in Byzantine replication, secure
route construction (a la BGP), and secure in-network aggregation that
evidence their potential to improve the safe development of secure distributed applications.

\end{abstract}

%\input{abstract}
\input{intro}
\input{background}
\input{authenticate}
\input{algebra}
\input{dads}
\input{implementation}
\input{specification}
\input{evaluation}
\input{todo}
%\input{newsemantics}
%\input{implementation}

\bibliographystyle{abbrv}
\bibliography{decsec}

\end{document}

