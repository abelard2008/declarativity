
\begin{figure}
\centering
\begin{boxedminipage}{\linewidth}
\small{\tt
r1 path(Src,Dst,Dst,Cost) :- \\
\datalogspace link(Src,Dst,Cost), \\
\\
r2 path(Src,Dst,Hop$_1$,Cost) :- \\
\datalogspace link(Src,Hop$_1$,C$_1$), \\
\datalogspace path(Hop$_1$,Dst,Hop$_2$,C$_2$), \\
\datalogspace Cost = C$_1$ + C$_2$. \\
\\
r3 minCostPath(Src, Dst, min<Cost>) :- \\
\datalogspace path(Src,Dst,NextHop,Cost). \\
\\
r4 shortestPath(Src, Dst, NextHop, Cost) :- \\
\datalogspace minCostPath(Src, Dst, Cost), \\
\datalogspace path(Src, Dst, NextHop, Cost). \\
\\
r5 shortestPath("localhost", Dst, NextHop, Cost).
}
\small{\caption{\label{fig:datalogSP}\emph{\small Shortest path in traditional Datalog}.}}
\end{boxedminipage}
\end{figure}

% An example
To illustrate declarative networking, we begin with a simple example
that specifies shortest-path computation among a set of nodes.  In
Figure~\ref{fig:datalogSP} we present this protocol in the traditional
recursive query language {\em Datalog} enhanced with aggregation
functions~\cite{greco99}.  Datalog programs consist of a set of
declarative {\em rules}, terminated by periods.  The right-hand-side
of the rule represents a conjunctive predicate over relations in a
database, and the left-hand side represents the deduction from that
predicate.  For example, rule {\bf r1} can be read as ``{\bf if} there
is a tuple there is a tuple {\tt (Src, Dst, Cost)} in the {\tt link} relation, 
{\bf then} there is a tuple {\tt (Src, Dst, Dst, Cost)} in
the {\tt path} relation.''  This rule identifies paths to immediate 
neighbors; those paths have the cost of the
corresponding one-hop link from Src to Dst, and the paths' ``next
hop'' for routing (the third field of the {\tt path} relation) is,
naturally, the Dst itself.  This is the base case of a recursive
shortest-path finding specification.  The recursive case is captured in rule
{\bf r2}: {\bf if} a source node has a link to another ``Hop$_1$'' node, 
{\bf then} the {\tt Src} node has a path to the "Dst" {\em via} that
``Hop$_1$'' node, with the appropriate cost.

These two rules are sufficient to find all possible paths from sources
to reachable nodes.  The next rule prunes this set: {\bf r3} uses the
aggregation function {\tt min} to identify the cost of the shortest 
(least-cost) path from each source to each destination.  
Finally, the query specifies that all such {\tt shortestPath}s should be 
returned as output.

\begin{figure}
\centering
\begin{boxedminipage}{\linewidth}
\small{\tt
materialize(link,infinity,infinity,keys(1,2)). \\
materialize(path,infinity,infinity,keys(3)). \\
materialize(bestPath,infinity,infinity,keys(2)).\\
\\
r1 path(@X,Y,P,C) :- \\
\datalogspace link(@X,Y,C), P := f\_cons(X,Y). \\
\\
r2 path(@X,Y,P,C) :- \\
\datalogspace link(@X,Z,C1), \\
\datalogspace path(@Z,Y,P2,C2), \\
\datalogspace f\_contains(X,P2) == false, \\
\datalogspace P := f\_cons(X,P2), C := C1 + C2. \\
\\
r3 pathQuery("localhost:10000",Y) :- \\
\datalogspace path("localhost:10000",Y,P,C). \\
\\
r4 minCostPath(@X, Y, a\_min<C>) :- \\
\datalogspace pathQuery(@X,Y), path(@X,Y,P,C). \\
\\
r5 shortestPath(@X, Y, P, C) :- \\
\datalogspace minCostPath(@X, Y, C), \\
\datalogspace path(@X, Y, P, C).
}
\small{\caption{\label{fig:overlogSP}\emph{\small Shortest path program in Overlog}.}}
\end{boxedminipage}
\end{figure}

The short Datalog program of Figure~\ref{fig:datalogSP} is sufficient
to specify the establishment of shortest paths to reachable nodes in a graph, 
and a Datalog engine can naturally translate each
node's path-finding rules into an efficient shortest-paths algorithm
like Dijkstra's.  However, this is still not a network protocol:
Datalog assumes that the relevant data, and the query processing
computation, are centralized on a single computer.
Figure~\ref{fig:overlogSP} shows a variant of the program expressed in
our {\em Overlog} language, which specifies a workable,
distributed network protocol based on that logic.  There are only two
modifications introduced in Figure~\ref{fig:overlogSP}:
\begin{CompactEnumerate}
\item Each relation has one field prepended with
   the ``{\tt @}'' symbol; this field is called the {\em location specifier}
of the relation.  The location specifier specifies data distribution:
each tuple is to be stored at the address in its location
specifier field.  For example, the {\tt path} relation is partitioned
by the first (source) field; each partition corresponds to the
networking notion of a local routing table.
% In rule ND1, we see that \texttt{\link,}
% \texttt{intree} and \texttt{path} tuples are all stored at the
% location in their first field.
\item Queries are not explicit in Overlog. The query in Figure~\ref{fig:overlogSP}
         is identified by the {\tt pathQuery} predicate that will be asserted whenever
         a new {\tt path} with the correct attribute bindings is asserted.
\end{CompactEnumerate}
Loo et al.~\cite{loo-sigmod06} show how location specifiers and link
relations enable an Overlog compiler to generate a distributed
protocol that is guaranteed to be executable over the
underlying network topology captured by the link relation.
