
Flow: 

 - Language? 
 - Or dataflow diagrams?

When you look at Chord it's not that easy to read.  Recursivity is
only in the lookup.   

Claim: Chord is now easier to read.  

Declarative: 
 - much easier to runtime / compile time optimization.  Data
    independence. 
 - 

Declarative vs. FSM approach.  They have a different factorization,
and so one is a better way to share things.

Joins are the key.  Dataflow diagrams themselves are more natural than
FSMs.  We chose to represent dataflow diagrams one level up as a logic
language. 

Petros said:  

1) In order to maintain a distri datastruct you have a
   set of asynchrouns messages - need to match newly arrived values to
   existing state.    Asynchrony + pointers lead naturally to joins.

2) Many of the things we ant to do is to run contninuous queries -
   what's a live?  Who's best for task x?  They are questions which
   should be reified as explicit queries - can now be named in a logic
   language. 

Ion: state machines vs. dataflows: why are statemachines? 

Thinking of these things as dataflwos guides our imperative lang
implemntation.   Allows us to identify  common components. 

Typing scoping asynchrony. 

Logic languages: layer collapse.  ILP. 

We lose: efficiency.  Fine tuning of timing.   
         Click can query downstream elements to implement RED. 

We can cite increasing use of logic languages.

--------------
Axes of graphs:

Replicate from Chord papers.  Basic Chord graphs.  Churn handling
   graphs to Bamboo. 
 
Extensions to Chord: PNS, PRS. 



----------------------------------------
Reviews:

 General: Experimental results are inadequate.  Film at 11. 

 #1,2 Seems to be a misunderstanding about our code being slow: the code
   is damn fast.  What's slow is as a result of the protocol timings
   being less tuned.  We need to make the case that the dataflow
   engine itself is pretty fast (we could benchmark it, but why
   bother?), but the performance cost is in overlay efficiency.  

 #1,5 State very clearly what Macedon Chord doesn't do. 

 #1,2,3,4 More of a case that everyone's writing overlay networks. More
   examples of things that are overlay networks, but don't look like
   them.   People seemed unclear about applicability.   Why doesn't
   modular reuse of C++ do the same thing?  "There are only a handful
   of different overlays and most are not used".  Clearly this
   reviewer didn't grok what we meant by an overlay - need to make the
   case stronger that there are lots of these things. 

 #1,2,4,5 Language is hard to understand ("weirdo prolog-language").  Can
   people really write in this language?   "Is it really so hard to do
   this imperatively?"
 
 #2 Super-optimizer idea?

 #3,4 No sharing / reuse demonstrated

 #3,4 No failure reporting.  How easy is it to integrate into the language?

 #3 Cleaner discussion of expiry and deletion of tables. 

 #3 Compare timings to Chord.  Or Macedon.  How much do we give up in
   terms of performance and reliability?

 #4 Can we handle layering?  [A: yes. trivially.]

 #4 Fix the Narada code.  Network partitions?

 #4 Transport: make it clearer that we're not talking about that. 

 #4 Yes, there can be multiple remote tuples on the LHS of a :- 

 #4 Doesn't buy the scoping, typing, reuse.  
 
 #4 Pastry?  Id arithmetic (easy now we have the new PEL type system)

 #5,6 Demonstrate and "examine deeply" benefits beyond existing
    approaches.  Broader consequences of the declarative approach
    should be enunciated. 

 #5 talk about rich querying / discovery

 #5 Datalog has poor abstraction support.  Nancy Lynch has
  abstraction/modularity support in FSMs.

 #6 Overlog does not have a formal specification (!)

 #6 Correctness checking would be good.
