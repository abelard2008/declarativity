R2T1 A number of extensions are indeed possible, and could be
highlighted in the paper.  Our discussion focuses on
select-project-aggregation, motivated by our running scenario, but the
techniques directly extend to GROUP BY and HAVING as well.  Since we
provide a verifiable sampling operator, we can add joins to our
repertoire by performing them at the querier over the samples, in the
spirit of Join Samples and Ripple Joins (both SIGMOD 99), ICICLES
(SIGMOD 00), etc.  When a modest sample size suffices, this is
efficient.  Going further, in Section 5.3 we sketch out verifiable Bloom
filters, which support set membership queries.  It is a short further
step to develop verifiable Bloom-joins and -antijoins (set
difference). A careful exposition of this idea would not fit in the
current paper.  So while we kept this paper focused on an applied
scenario outside the classical DB context, extensions to other
relational operators seem viable, and the point merits discussion.

R3T0 The guarantees of our techniques (Sec. 3 & 4) are stated
rigorously, corresponding to a formal set of adversary capabilities.
The threat model section is more informal, but is, we believe,
consistent with typical systems security papers, e.g., section 2.3 of
[28], or Section 2.2 of "Verifying Completeness of Relational Query
Results in Data Publishing", Pang et al.(SIGMOD'05), for a different
security/DB problem.

Admittedly, our threat model section covers more than the threat model:
(1) vulnerabilities in the ecosystem (data sources, aggregators, and
querier), (2) the trust scenarios we tackle (trusted data sources,
untrusted aggregators), (3) and those we do not (untrusted data sources
or queriers) with some pointers to how those may be addressed.  Then it
focuses on the capabilities of our specific adversary.  Refactoring to
separate "ecosystem" from threat model may clarify it.

R3T1 Fairplay and similar SFE methods rely on the translation of a
sequential algorithm to an acyclic boolean circuit without registers.
This produces a number of (virtual) gates linear in the number of
possible execution paths via the algorithm (roughly exponential in the
number of basic blocks with all loops unrolled).  Simple operations such
as array indexing are reduced to large subcircuits of demultiplexers,
with input gates per array content bit, to ensure oblivious execution.
As a result, Fairplay can produce practical results only for small
algorithms with inputs of small constant number, e.g., a comparison of 2
numbers, or the median of 10 numbers, and then only for 2-party
computations.  Even then, a simple 2-party comparison of 2 numbers over
the Internet takes 1.5 sec for current CPUs and network conditions.

Contrast this to our problem set: verifiable, duplicate-insensitive
counts, distinct sampling, etc., of potentially millions of inputs, by
potentially thousands of parties, at rates of 1 every few seconds.
The performance of general SFE trails such problems by several orders of
magnitude still.


