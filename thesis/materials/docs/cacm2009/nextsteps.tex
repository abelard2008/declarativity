\section{Conclusion}
In Jim Gray's Turing Award Lecture in 1998~\cite{grayturing}, one of
his grand challenges was the development of ``automatic
programming'' techniques that would be (a) $1000\times$ easier for people to use, (b) directly compiled into working code, and (c) suitable for
general purpose use.  
% As of that time, Gray noted that automatic
% programming had been achieved only in a few domain-specific cases.
Butler Lampson reiterated the first two points in a subsequent invited article, but suggested that 
they might be more tractable in domain-specific settings~\cite{lampsonjacm}.  

Declarative Networking has gone a long way towards Gray's vision, if only in the domain of network protocol implementation.  On multiple occasions we have seen at least two orders of magnitude reduction in code size, with the reduced linecount producing qualitative improvements.  In the case of Chord, a multi-thousand line C++ library was rewritten as a declarative program that fits on a single sheet of paper -- a software artifact that can be studied and holistically understood by a programmer in a single sitting.  

We have found that a high-level declarative language not only simplifies a programmer's work, but re-focuses the programming task on appropriately high-level issues. For example, our work on declarative routing concluded that discussions of routing in wired vs.\ wireless networks should not result in different protocols, but rather in different compiler optimizations on the same simple declaration, with the potential to be automatically blended into new hybrid strategies as networks become more diverse~\cite{sigcomm05, ipsn09}.  This lifting of abstractions seems well suited to the increasing complexity of modern networking, introducing software malleability by minimizing the affordances for over-engineering solutions to specific settings.

Since we began our work on this topic, there has been increasing evidence that declarative, data-centric programming has much broader
applicability. Within the networking domain, we have expanded in
multiple directions from our initial work on routing, to encompass
low-level network issues at the wireless link layer~\cite{sensys07} to
higher-level logic including both overlay
networks~\cite{sosp05,sensys07} and applications like code
dissemination, object tracking, and content
distribution~\cite{sensys07,ipsn09}.  Meanwhile, a
variety of groups have been using declarative programming ideas in
surprising ways in many other domains. We briefly highlight two of our own follow-on
efforts:

\begin{itemize}

\item {\bf Secure Distributed Systems:} Despite being developed
independently by separate communities, logic-based security
specifications and declarative networking programs both extend Datalog
in surprisingly similar ways: by supporting the notion of context
(location) to identify components (nodes) in distributed systems.  The
{\em Secure Network Datalog}~\cite{decsec} language extends \Dlog with
basic security constructs for implementing secure distributed systems,
which are further enhanced with type checking and meta-programmability
in the LBTrust~\cite{lbtrust} system for supporting various forms of
encryption/authentication, delegation, for distributed trust
management. 

\item {\bf BOOM: Data-Centric Datacenter Programming}
The BOOM project is exploring the use of declarative languages in the 
setting of Cloud Computing, which currently provide developers with a distributed system and a sequential programming model.  As a counter-example, we used \Overlog as the basis for reimplementing a standard analytics stack for datacenters: the Hadoop File System (HDFS) and MapReduce infrastructure.  Our resulting system is API-compatible with Hadoop, with performance that is equivalent or better.  The high-level \Overlog specification of key Hadoop internals enabled a group of 4 graduate students to quickly add sophisticated distributed features to the system that are not in Hadoop:  hot standby master nodes supported by MultiPaxos consensus, simple scaleout of (quorums of) masters via data partitioning, and simple implementations of new scheduling protocols and query processing strategies~\cite{boom}.  
\end{itemize}

In addition to these two bodies of work, others have successfully
adopted concepts from declarative networking, in the areas of
mobility-based overlays, adaptively hybridized mobile ad-hoc
networks, overlay network composition, sensor networking, fault-tolerant
protocols, network configuration, replication systems, distributed machine 
learning algorithms, and robotics.  
Outside the realm of networking and distributed systems, 
there has been an increasing use of declarative languages -- many rooted in Datalog -- to a wide range of problems including natural language processing, compiler analysis, security and computer games.  We maintain a list of related declarative languages and research projects at \link{http://declarativity.net/related}.  

For the moment, these various efforts represent individual instances of Lampson's domain-specific approach to Gray's automatic programming challenge.  In the coming years it will be interesting to assess whether these solutions prove fruitful, and whether it is feasible to go after Gray's challenge directly: to deliver an attractive general-purpose declarative programming environment for a wide range of tasks.


%In our work, certain design patterns have recurred in the cases where
%our code seemed most compact and natural.  The first is our initial
%inuition that because networks are graphs, many network protocols are
%naturally expressed as transitive closures (recursive queries) of the
%graph's edge relation.  The second was the connection between
%asynchronous communication and join: asynchronous dialogs require the
%rendezvous of cached outbound messages with potentially reordered
%responses -- i.e. the join of the request and response ``stream''.  A
%third pattern is that dynamic programming algorithms are neatly
%expressed as recursive queries, a topic that we have exploited in a
%variety of settings not discussed in this paper.


%\subsection{Recent Developments}


%\subsection{Perspectives}


%additional bullet points
%a) The right abstraction: Data-centric programming key for
%distribution/parallelism (e.g. request/response design patterns,
%leveraging MapReduce excitement, fitness to many distributed tasks)
%b) Recursive state: networks, dynamic programming.
%c) Metamodels and metaprogramming
%       - query optimization
%       - static and dynamic testing for bugs and security
%e) Challenges: update/time semantics, integration/boundaries with native
%code, high performance \& multicore
%f) Going mainstream: cloud \& multicore
%g) Network Verification

