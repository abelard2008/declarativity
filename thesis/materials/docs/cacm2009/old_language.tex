\section{Declarative Networking Language}
\label{sec:language}

In this section, we formally define the Network Datalog (\Lang) language
for declarative networking. The \Lang language is based on extensions to
traditional Datalog, a well-known recursive query language traditionally
designed for querying graph-structured data in a centralized
database. Based on our introduction, we step through an example, to
illustrate the execution model and demonstrates its close connections to
routing protocols, recursive network graph computations, and distributed
state management.
  

\subsection{Introduction to Datalog}
\label{sec:language: Datalog}
We first provide a short review of Datalog, following the conventions in
Ramakrishnan and Ullman's survey~\cite{ramakrishnan93survey}. A Datalog
program consists of a set of declarative {\em rules} and an optional
{\em query}. Since these programs are commonly called {\em ``recursive
  queries''} in the database literature, we use the term ``query'' and
``program'' interchangeably when we refer to a Datalog program.

A Datalog {\em rule} has the form {\em p :- $q_{1}, q_{2}, ...,
q_{n}$}., which can be read informally as ``$q_{1}$ and $q_{2}$ and $
... $ and $q_{n}$ implies p''. $p$ is the {\em head} of the rule, and
$q_{1}, q_{2}, ..., q_{n}$ is a list of {\em literals} that constitutes
the {\em body} of the rule.  Literals are either {\em predicates} over
{\em fields} (variables and constants), or function symbols applied to
fields. The rules can refer to each other in a cyclic fashion to express
recursion. The order in which the rules are presented in a program is
semantically immaterial.  The commas separating the predicates in a rule
are logical conjuncts ({\em AND}); the order in which predicates appear
in a rule body also has no semantic significance, though most
implementations (including ours) employ a left-to-right execution
strategy. The {\em query} specifies the output of interest.

The predicates in the body and head of traditional Datalog rules are
relations, and we refer to them interchangeably as predicates, relations
or tables.  Each relation has a {\em primary key}, which consists of a
set of fields that uniquely identify each tuple within the relation. In
the absence of other information, the primary key is the full set of
fields in the relation.

By convention, the names of predicates, function symbols and constants
begin with a lower-case letter, while variable names begin with an
upper-case letter.  Most implementations of Datalog enhance it with a
limited set of function calls (which start with ``\nd{f\_}'' in our
syntax), including boolean predicates and arithmetic
computations. Aggregate constructs are represented as functions with
field variables within angle brackets ($<$$>$).
 
As an example, Figure~\ref{fig:background:shortestPath} shows a Datalog
program that computes the next hop along the shortest paths between all
pairs of nodes in a graph.  The program has four rules (which for
convenience we label \nd{r1-r4}), and takes as input a base
(``extensional'') relation \nd{link(Source, Destination, Cost)}.  Rules
\nd{r1-r2} are used to derive ``paths'' in the graph, represented as
tuples in the derived (``intensional'') relation \nd{path(S,D,Z,C)}.
The \nd{S} and \nd{D} fields represent the source and destination
endpoints of the path; \nd{Z} contains the ``next hop'' in the graph
along the shortest path that a node \nd{S} should take in order to go to
node \nd{D}. The number and types of fields in relations are inferred
from their (consistent) use in the program's rules.

Rule \nd{r1} produces \nd{path} tuples directly from existing \nd{link}
tuples, and rule \nd{r2} recursively produces \nd{path} tuples of
increasing cost by matching (or {\em unifying}) the destination fields
of existing links to the source fields of previously computed paths. The
matching is expressed using the repeated ``\nd{Z}'' variable in
\nd{link(S,Z,C1)} and \nd{path(Z,D,Z2,C2)} of rule \nd{r2}. Intuitively,
rule \nd{r2} says that ``if there is a link from node \nd{S} to node
\nd{Z}, and there is a path from node \nd{Z} to node \nd{D}, then there
is a path from node \nd{S} to node \nd{D} via \nd{Z}''.
 
Given the \nd{path} relation, rule \nd{r3} derives the relation
\nd{spCost(S,D,C)} that computes the minimum cost \nd{C} for each source
(\nd{S}) and destination (\nd{D}) for all input paths. Rule \nd{r4}
takes as input \nd{spCost} and \nd{path} tuples and then computes
\nd{shortestPathHop(S,D,Z,C)} tuples that contains the next hop (\nd{Z})
along the shortest path from \nd{S} to \nd{D} with cost \nd{C}. Last,
the {\em Query} specifies the output of interest to be the
\nd{shortestPath} table.


\begin{figure}[h]
\begin{NDlog}
r1 path(S,D,D,C) :- link(S,D,C).
r2 path(S,D,Z,C) :- link(S,Z,C1), path(Z,D,Z2,C2), C = C1 + C2.
r3 spCost(S,D,min<C>) :- path(S,D,Z,C).
r4 shortestPathHop(S,D,C) :- spCost(S,D,C), path(S,D,Z,C).
Query shortestPathHop(S,D,Z,C).
\caption{{\small Shortest-Path-Hop Datalog program.}\label{fig:background:shortestPath}}
\end{NDlog}
\end{figure}


\subsection{Overlog by Example}
\label{sec:language:firstExample}

We first introduce \Lang by example using a distributed variant of the
earlier {\em Shortest-Path-Hop} Datalog program. This distributed \Lang
program, shown in Figure~\ref{fig:language:dv}, computes for every node,
the next hop along the shortest paths of all nodes in a network in a
distributed fashion. We use this \Lang program to highlight four new
requirements: {\em distributed computation}, {\em link-restricted
  rules}, {\em soft-state data and rules}, and {\em incremental
  maintenance of network state}.


\begin{figure}[t]
\begin{NDlog}
materialize(link,infinity,infinity,keys(1,2)).
materialize(path,infinity,infinity,keys(1,2,3,4)).
materialize(spCost,infinity,infinity,keys(1,2)).
materialize(shortestPathHop,infinity,infinity,keys(1,2)).
sh1 path(@S,D,D,C) :- link(@S,D,C).\\ \noindent
sh2 path(@S,D,Z,C) :- link(@S,Z,C1), path(@Z,D,Z2,C2), C = C1 + C2.
sh3 spCost(@S,D,min$<$C$>$) :- path(@S,D,Z,C).
sh4 shortestPathHop(@S,D,Z,C) :- spCost(@S,D,C), path(@S,D,Z,C).
Query shortestPathHop(@S,D,Z,C).
\end{NDlog}
\caption{{\small Shortest-Path-Hop \Lang program.}}\label{fig:language:dv}
\end{figure}


%\subsection{Language Features}
An \Lang program is largely composed of table declaration statements and
rules; we consider each in turn. In \Lang, all input relations and rule
derivations are stored in {\em materialized} tables. Unlike Datalog,
tables must be defined explicitly in \Lang via \nd{materialize}
statements, which specify constraints on the size and lifetime of tuple
storage -- any relations not declared as tables are treated as named
{\em streams} of tuples. Each \nd{materialize(name, lifetime, size,
primary keys)} statement specifies the relation name, lifetime of each
tuple in the relation, maximum size of the relation, and fields making
up the primary key of each relation\footnote{We have a convention of
starting the offset by 1 in the \Sys system, as 0 is reserved in the
implementation for the table name.}. If the primary key is the empty set
\nd{()}, then the primary key is the full set of fields in the relation.
For example, in the {\em Shortest-Path-Hop} \Lang program, all the
tables are specified with infinite sizes and lifetimes.

The execution of \Lang rules will result in the derivation of tuples
that are stored in materialized tables. For the duration of program
execution, these materialized results are incrementally recomputed as
the input relations are updated. For example, the update of \nd{link}
tuples will result in new derivations and updates to existing \nd{path},
\nd{spCost} and \nd{shortestPathHop} tuples. In addition, if an \Lang
rule head is prepended with an optional keyword {\em delete}, the
derived tuples are used to delete an exact match tuple in its relation
instead.

Since network protocols are typically computations over distributed
network state, one of the important requirements of \Lang is the ability
to support rules that express distributed computations. \Lang builds
upon traditional Datalog by providing control over the storage location
of tuples explicitly in the syntax via {\em location specifiers}. Each
location specifier is an attribute within a predicate that indicates the
partitioning field of each relation.  To illustrate, in
Figure~\ref{fig:language:dv}, each predicate in the \Lang rules has an
``\nd{@}'' symbol prepended to a single field denoting the location
specifier. Each tuple generated is stored at the address determined by
its location specifier. For example, all \nd{path} and \nd{link} tuples
are stored based on the address stored in the first field \nd{@S}.

Interestingly, while \Lang is a language to describe networks, there are
no explicit communication primitives. All communication is implicitly
generated during rule execution as a result of data placement. For
example, in rule \nd{sh2}, the \nd{path} and \nd{link} predicates have
different location specifiers, and in order to execute the rule body of
\nd{sh2} based on their matching fields, \nd{link} and \nd{path} tuples
have to be shipped in the network. It is the movement of these tuples
that will generate the messages for the resulting network protocol.  In
reference~\cite{declareRoute}, we show that the resulting communication
and network state generated in program execution resembles the
distance-vector protocol.

Figure~\ref{fig:language:shortestPath} shows the {\em Shortest-Path}
\Lang program that implements the path-vector protocol. The program is
written with only minor modifications to the earlier {\em
Shortest-Path-Hop} \Lang program. The program computes the entire path
vector for a given source to destination, by adding an extra
\nd{pathVector} field in the \nd{path} predicate that the full path. The
function \nd{f\_init(X,Y)} initializes the path vector with nodes
\nd{X} and \nd{Y}, and the function \nd{f\_concatPath(N,P)} prepend a
node \nd{N} to an existing path vector \nd{P}. We revisit more examples
of routing protocols in Chapter~\ref{cha:declareRoute}.

%The execution this query resembles the {\em path vector routing}
%protocol, which is used today as the kernel for the Border Gateway
%Protocol (BGP)~\cite{ee122text} inter-domain routing protocol. 


\begin{figure}[t]
\begin{NDlog}
materialize(link,infinity,infinity,keys(1,2)). 
materialize(path,infinity,infinity,keys(4)). 
materialize(spCost,infinity,infinity,keys(1,2)). 
materialize(shortestPath,infinity,infinity,keys(1,2)). 
sp1 path(@S,D,D,P,C) :- link(@S,D,C), P = f_init(S,D).
sp2 path(@S,D,Z,P,C) :- link(@S,Z,C1), path(@Z,D,Z2,P2,C2), C = C1 + C2,
                        P = f_concatPath(S,P2). 
sp3 spCost(@S,D,min<C>) :- path(@S,D,Z,P,C).
sp4 shortestPath(@S,D,P,C) :- spCost(@S,D,C), path(@S,D,Z,P,C).
Query shortestPath(@S,D,P,C).
\end{NDlog}
\caption{{\small Shortest-Path \Lang program.}}\label{fig:language:shortestPath}
\end{figure}


\subsection{Other Requirements of \Lang}

In addition to distributed computations, \Lang requires the following
additional features for {\em link-restricted communication}, {\em
  soft-state data and rules}, and {\em incremental maintenance of
  network state}. We briefly describe them here. More details are
available in reference~\cite{boonThesis}.


\subsubsection{Link-restricted communications} 

In order to send a message in a low-level network, there needs to be a
link between the sender and receiver. This is not a natural construct in
Datalog. Hence, to model physical networking components where
full-connectivity is not always available, \Lang provides syntactic
restrictions that can be used to ensure that rule execution results in
communication only among nodes that are physically connected. This is
syntactically achieved with the use of the special \nd{link\xspace}
predicate in all \Lang programs. \reminder{Talk about network  Datalog
  and proofs of eventual consistency under FIFO links}.
 
\subsubsection{Soft-state Data and Rules}

In typical network protocols, the generated network state is maintained
as {\em soft-state}~\cite{clark88design} data. In the soft state storage
model, stored data have a {\em lifetime} or time-to-live (TTL), and are
deleted when the lifetime has expired. The soft state storage model
requires periodic communication to refresh network state. Soft state is
often favored in networking implementations because in a very simple
manner it provides well-defined eventual consistency
semantics. Intuitively, periodic refreshes to network state ensure that
the eventual values are obtained even if there are transient errors such
as reordered messages, node disconnection or link failures. While soft
state is useful for maintaining distributed state, we also make
extensive use of traditional {\em ``hard-state''} data with infinite
lifetimes for storing persistent counters, local machine state and
archival logs.


\subsubsection{Incremental maintenance of network state} 

In practice, most network protocols are executed over a long period of
time, and the protocol incrementally updates and repairs routing tables
as the underlying network changes (link failures, node departures, etc).
To better map into practical networking scenarios, one key distinction
that differentiates the execution of \Lang from earlier work in Datalog
is our support for continuous rule execution and results
materialization, where all tuples derived from \Lang rules are
materialized and incrementally updated as the underlying network
changes. As in network protocols, such incremental maintenance is
required both for timely updates and for avoiding the overhead of
recomputing all routing tables ``from scratch'' whenever there are
changes to the underlying network.

