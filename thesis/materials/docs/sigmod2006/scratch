A right linear magic sets rule to do K-horizon all-pairs
computation. Routing is done by the same left-linear approach with
caching (as shown above), or recursively directs to perimeter
of zone, then recursive routes until find the node responsible. 

View of perimeter nodes.
One rule. If in horizon, generate results, send back on reverse path.
If not in horizon, forward query to perimeter nodes via links. 
Perimeter nodes receive query, check never received query before. If so,
repeat the check .

As shown in ~\cite{zrp}, the size of radius depends on parameters like rate of change of paths, and
the density of each node (number of neighbors in k hops). These can be
captured for cost-based analysis using systems statistics. 



Combined the best of both worlds, can be expressed as hybrid
rewrites. One example of this is the {\em zone routing protocol}~\cite{zrp} used in
wireless communication.  Do a limited right-linear computation of all pairs, with filter at source
(K-horizon all-pairs all paths). For each source/destination initiated query, check to see if it is
within zone. If not, forward the query to all nodes at the peripheral of
zone, and they recursively check within their zones.  Best of both
worlds if the horizon size is chosen right. Frame this as a ``partial
magic rewrite''. 

In the rest of the section, we provide a summary of our proofs.

\subsubsection{Linear Recursive Rules}
\label{sec:linearProof}

Consider a linear recursive rule LR1 with a
single recursive predicate $p$ and m base predicates (b$_{1}, b_{2},
...b_{m}$). 

\noindent{\bf LR1:} $p :- p_{1}, b_{1}, b_{2}, ..., b_{m}$. 

Rule LR1 has the recursive predicate $p_{1}$ which is mutually recursive
w.r.t. $p$. The rewritten semi-\naive rule:\\
\noindent{\bf LR1a:} $\triangle$p$^{new}$ :- $\triangle$p$^{old}_{1}$,
$b_{1}, b_{2}, ..., b_{m}$.

%The PSN algorithm (Figure~\ref{alg:psn}) requires minor modifications in
%order to support multi-rule linear recursion. At the end of executing
%the rule strand, rather than directly generating $p_{1}$ tuples,
%the newly generated $p$ tuples are used as
%input to other rules (enqueued in other rule strands), which would in
%turn generate $p_{1}$ tuples. 

Let $FP_{SN}(p)$ and $FP_{PSN}(p)$ denote to the set of resulting $p$ tuples
  generated from SN and PSN evaluation of LR1a respectively. We prove that
  $FP_{SN}(p)=FP_{PSN}(p)$, i.e. generates the same results as SN. We
  further prove that PSN results in no duplicate evaluations.




\begin{Theorem}\label{theorem:nonLinearEq} $FP_{SN}(p)=FP_{PSN}(p)$\end{Theorem}
\begin{proof}Based on theorem~\ref{theorem:nseqpsn}, if sequence
  numbers are not used, $FP_{SN}(p) = FP_{PSN}(p)$. With
  the use of sequence numbers, the results set of $FP_{PSN}(p)$ is
  potentially reduced. However, we show that $\forall t (t \in
  FP_{SN}(p) \Rightarrow t \in FP_{PSN}(p))$. We do a proof by
  induction:\\
The base case for $FP_{SN}^{0}(p)$ and $FP_{PSN}^{0}(p)$ is
  trivial.  Assume $\forall t (t \in FP_{SN}^{i-1}(p) \Rightarrow t \in
  FP_{PSN}^{i-1}(p))$ is true, we show that $\forall t (t \in
  FP_{SN}^{i}(p) \Rightarrow t \in FP_{PSN}^{i}(p))$. Consider any $t \in
  FP_{SN}^{i}(p)$ and $t_{j} \in FP_{SN}^{i-1}(p_{j})$,  s.t. $t :- t_{1},
  t_{2}, ..., t_{n}, b_{1}, ..., b_{m}$. From our assumption, we know
  $t_{j} \in FP_{PSN}^{i-1}(p_{j})$. If $ts(t_{k}) = max(ts(t_{1}),
  ts(t_{2}), ..., ts(t_{n}))$, only the $k^{th}$ PSN rule is used to
  generate $t$.  Hence, $t \in FP_{PSN}(p)$, and this completes our
  prove by induction. 
\end{proof}


Queries can be disseminated to nodes in a variety of ways. In static
scenarios, the query may be ``baked in'' to another artifact -- \eg in
router firmware or peer-to-peer application software running the \Sys
query processor. More flexibly, the query could be disseminated upon initial declaration.
It may be sufficient to perform dissemination via flooding,
particularly if the query will be long-lived, amortizing the cost of
the initial flood\footnote{As an optimization, instead of flooding the query
in the network, we can instead ``piggy-back'' dissemination onto query
execution: the query can be embedded into the first tuple sent to
each neighboring node as part of the query computation. The piggy-back
mechanism has the advantage that nodes that are not involved in the
query computation will not receive the query}.

Each node upon receiving the query, will generate a query execution
plan. 
% \begin{minipage}{.45\linewidth}
%  \begin{center}
%    \epsfig{file=graphs/baseline/bw-zone.ps,width=1.18in,angle=-90}
%    \small{\caption{\label{zone-bw}\emph{\small Bandwidth (Kbps) for
%    all-pairs shortest paths vs hybrid rewrite}}}
%    \end{center}
% \end{minipage}
%\hfill
% \begin{minipage}{.3\linewidth}
%  \begin{center}
    %\epsfig{file=graphs/magiccache/queryBW_gtitm100.ps,width=1.2in,angle=-90}
%    \small{\caption{\label{zone-route}\emph{\small Bandwidth (Kbps) for magic
%    sets vs hybrid rewrite}}}
%    \end{center}
% \end{minipage}

In pipelined semi-\naive evaluation, a FIFO queue is maintained as input
to each rule. This queue consists of new $p_{1}$ tuples that have yet been
processed. Each iteration consists of dequeuing one tuple, and then using
that as input to the rule. The result of executing the rule is new
$p$ tuples, and since $p_{1}$ is a recursive predicate, this leads to
new $p_{1}$ tuples being generated. The new $p_{1}$ tuples are then
added to the queue. Since we check to make sure each tuple inserted into
the queue is not in the current table, there are no duplicate inputs. 

In order to avoid duplicate evaluation, we have to proof the following
theorem: 

\begin{Theorem} Each $p_{1,k}$ used in the $k^{th}$ iteration is unique, i.e. not in $p_{1,1},
  p_{1,2}, ..., p_{1,k-1}$. \end{Theorem}
\begin{proof} (by induction)\\
\noindent {\bf Base Case:} First invocation trivial, as $p_{1,1}$ is the first one..

\noindent{\bf Inductive Hypothesis:} Assume $p_{1,k}$ is true for k. So
$p{1,k}$ is unique, i.e. different from $p_{1,1}$ to $p_{1,k-1}$.

\noindent {\bf Inductive Step: } Since  $p_{1,k+1}$ must also be unique also,
since it is different from $p_{1,k}$. This is because $p_{1,k}$ is added to p
first, and $p_{1,k+1}$ is added to the queue only if it is not in
p. This assumes FIFO ordering in queue.
\end{proof}


The above shows that $p_{1,k}$ is unique for all k from 1 to the number
of iterations necessary for the fixpoint. 


%join fields involve address fields. In order to determine whether a legitimate join ordering exists, we
%introduce the {\em Join mapping graph} G=(V,E), where each body predicate p$_{i}$ is
%represented by a node n$_{i}$ in V. For any two predicates p$_{i}$ and p$_{j}$,
%there is an undirected edge between n$_{i}$ and n$_{j}$ if the two predicates
%have common address field variables . If G is connected, the rule is
%localizable. We note that all topology-restricted Datalog programs are localizable since
%we can always construct a connected join mapping graph based on the
%predicates. 

%For example, the following rule: a(\underline{\&W},Y,Z) :-
%b(\underline{\&W},X), c(\underline{\&X},Y), d(\underline{\&X},Z) has multiple 
%possible join orderings, \eg $a \bowtie b \bowtie c$ and $a \bowtie c \bowtie b$.

%There are also cases where no join ordering is possible. For example,
%the rule a(\underline{X},Y) :- a(\underline{W},X), b(\underline{Y},Z) has no possible join
 % ordering. In fact, such a rule would require the query processor to
 % flood all {\em a} or {\em b} tuples to every node in the network. We
 % reject queries where such join ordering is not possible.

%If G is connected, a
%join ordering exists. To form a left-deep plan, construct a simple path starting
%from any node in G. Since there may be multiple such simple paths, we
%can use the heuristic of picking paths that traverse the predicates that
%represent smaller tables (i.e. perform the joins of smaller tables
%first). Figuring out the correct join ordering is an interesting area of
%research, but not the focus of this paper.


%\numberofauthors{1}
%\author{
%\alignauthor Boon Thau Loo$^\ast$ \quad Tyson Condie $^\ast$  \quad
%Minos Garofalakis$^\dag$\\\vspace{2pt} \quad Joseph M. Hellerstein$^\ast$
%\quad Raghu Ramakrishnan$^\delta$ \quad Ion Stoica$^\ast$ \quad (.....)\\\vspace{2pt}
%\normalsize{$^\ast$UC Berkeley \quad $^\delta$University of
%      Wisconsin-Madison \quad $^\dag$Intel Research Berkeley}
%}


