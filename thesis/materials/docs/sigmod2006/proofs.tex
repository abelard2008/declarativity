
\appendix

\section{Proofs for Pipelined Semi-na\"{i}ve}
\label{appendix:pipeline}

{\small 
\begin{table}[ht]
\begin{center}
\begin{tabular}{|c|p{2.5in}|} \hline
\bf{Symbol} & \bf{Representation} \\ \hline
$t$ & A tuple generated at any iteration.\\ \hline
$t^{i}$ & A tuple generated at the $i^{th}$ iteration.\\ \hline
$p_{k}$ & The table corresponding to the $k^{th}$ recursive predicate in the rule body.\\ \hline
$b_{k}$ & A table for the $k^{th}$ base predicate in the rule body.\\ \hline
$FP_{S}(p)$ & Result set for $p$ using SN evaluation.\\ \hline
$FP_{P}(p)$ & Result set for $p$ using PSN evaluation.\\ \hline
$FP_{S}^{i}(p)$ & Result set for $p$ using SN evaluation at the $i^{th}$
iteration or less.\\ \hline
$FP_{P}^{i}(p)$ & Result set for $p$ using PSN evaluation for all $p$
tuples that are marked with iteration number $i$ or less.\\ \hline
\end{tabular}
\caption{Proof Notation\label{table:notation}}
\end{center}
\end{table}
}


%\subsection{Linear Recursive Proofs}
%\label{appendix:linear}

%Consider the following semi-\naive rewritten rule from
%Section~\ref{sec:queryPro}:\\ 
%\noindent{\bf LR1a:} $\triangle$p$^{new}$ :- $\triangle$p$^{old}_{1}$,
%$b_{1}, b_{2}, ..., b_{m}$, where $p_{1}$ is a recursive predicate. 

%\begin{Theorem}\label{theorem:nseqpsn}$FP_{P}(p)$=$FP_{S}(p)$
%  $\wedge$ $FP_{P}(p_{1})$=$FP_{S}(p_{1})$\end{Theorem}
%\begin{proof}Refer to the proof of the more general Theorem~\ref{theorem:nonLinearEq}\end{proof}

%\begin{Theorem}\label{theorem:psnnodups}There are no duplicate evaluations in computing $FP_{P}(p)$.\end{Theorem}
%\begin{proof}Note that the theorem is trivially true since we only
%  add a new $t^{new}$ tuple into the queue if it does not exist previously. This guarantees that each invocation
%  of the rule is unique.\end{proof}

%\subsection{Non-Linear Recursive Rules}
%\label{appendix:nonLinear}

In our proofs, we use the notation in
Table~\ref{table:notation}. Consider a rule with n recursive predicates $p_{1}$, $p_{2}$,...,
$p_{n}$ and m base predicates:\\ 
\noindent $p :- p_{1}, p_{2}, ..., p_{n}, b_{1}, b_{2}, ..., b_{m}.$\\

For the purposes of the proof of Theorem~\ref{theorem:nonLinearEq}, we
assume that there is a unique derivation for each tuple $t$. 

\begin{Claim}\label{claim:psn} $\forall t^{i} \in FP_{S}^{i}(p), \exists t_{j} \in
  FP_{S}^{i-1}(p_{j})$ s.t. $t :- t_{1},
  t_{2},...,t_{n}, b_{1}, b_{2}, ...,b_{m}$ $\wedge$ $t
  \notin FP_{S}^{i-1}(p)$. Same for $FP_{P}$. 
\end{Claim}

\begin{Theorem}\label{theorem:nonLinearEq}$FP_{S}(p)=FP_{P}(p)$\end{Theorem}
\begin{proof} (By induction). The base case $FP_{S}^{0}(p) = FP_{P}^{0}(p)$ is trivial since this is
the initial set of input $p_{0}$ tuples. Assume inductively $FP_{S}^{i-1}(p)=FP_{P}^{i-1}(p)$ is true, we show
that $FP_{S}^{i}(p)=FP_{P}^{i}(p)$ using the following two lemmas below.
\end{proof}

\begin{Lem}\label{lem:psn1}$FP_{S}^{i}(p) \subseteq FP_{P}^{i}(p)$ \end{Lem}
\begin{proof} Consider tuple $t^{i}$ $\in FP_{S}^{i}(p)$
  derived using SN evaluation $t :- t_{1},t_{2},...,t_{n},b_{1}, b_{2},
  ...,b_{m}$. By Claim~\ref{claim:psn}, $t_{j} \in FP_{S}^{i-1}(p_{j})$ $\wedge$ $t
  \notin FP_{S}^{i-1}(p)$.  One of the input $t_{j}$'s ($t_{k}$) must be in
  $\triangle$p$_{k}^{old}$ in the SN algorithm. $t_{k}^{i-1} \in
  FP_{S}^{i-1}$ $\Rightarrow$ $t_{k}^{i-1} \in FP_{P}^{i-1}$. By the PSN
  algorithm, $t_{j}^{i-1}$ must have been enqueued, hence generating
  $t^{i}$. So $t^{i} \in FP_{S}^{i}$. 
\end{proof}


%\begin{Lem}$FP_{P}(p)$ $\subseteq$ $FP_{S}(p)$\end{Lem}
\begin{Lem}\label{lem:psn2}$FP_{P}^{i}(p) \subseteq FP_{S}^{i}(p)$\end{Lem}
\begin{proof} Consider a tuple $t^{i}$ $\in FP_{S}^{i}(p)$
  derived using modified PSN evaluation $t :- t_{1},t_{2},...,t_{n},b_{1},
  b_{2},...,b_{m}$. From claim~\ref{claim:psn}, $t_{k} \in
  FP_{P}^{i-1}(p_{k})$ $\wedge$ $t \notin FP_{P}^{i-1}(p)$.  By the PSN
  algorithm, one of $t_{j}$'s ($t_{k}$) is $\triangle t_{k}^{old,i-1}$. This means
  that $t_{k}^{i-1} \in FP^{i-1}_{S}(p_{k})$ $\Rightarrow$ $t_{k}^{i-1}
  \in \triangle p_{k}^{old}$ in the $i^{th}$ iteration of the SN
  algorithm. This will result in the rule being used to generate $t$ in
  the $i^{th}$ iteration. Hence, $t^{i} \in FP_{S}^{i}$. 
\end{proof}

If there are multiple derivations for the same tuple, we can apply the same proof above for
Theorem~\ref{theorem:nonLinearEq} using the following
modified PSN: if there are two derivations
$t^{i}$ and $t^{j}$ ($j \gt i$) for the same tuple, the modified PSN algorithm
guarantees that $t^{i}$ is generated by enqueuing $t^{i}$ even if $t^{j}$ was previously
generated. Note that the modified PSN algorithm leads to repeated inferences, but generates
the same results as PSN. 

\begin{Theorem}\label{theorem:dupnl}There are no repeated inferences in computing
  $FP_{P}(p)$.\end{Theorem}

\begin{proof} For linear rules, the theorem is trivially true since we
  only add a new derived tuple into the PSN queue if it does not exist
  previously. This guarantees that each invocation of the rule is unique

For non-linear rules, we continue from Theorem~\ref{theorem:nonLinearEq}'s
  proof. Let $ts(t)$ be the sequence number or timestamp of derived
  tuple $t$. Following the proof for Lemma~\ref{lem:psn1}, only the
  $k^{th}$ rule, where $ts(t^{i-1}_{k}) = max(ts(t^{i-1}_{1}),
  ts(t^{i-1}_{2}), ..., ts(t^{i-1}_{n}))$ will be used to generate
  $t^{i}_{0}$ at the inductive step, ensuring no repeated inferences.\end{proof}


\section{Proofs for Bursty Updates}
\label{appendix:bursty}
\label{appendix:burstyCentral}
\label{appendix:burstyDistributed}

Let $E$ be the set of all extensional tuples that appear during the
execution of a program. Let $D$ be the set of all tuples that can be
derived from $E$ (we assume $E \subseteq D$ for simplicity).  A tuple $t
\in D$ derived by the rule $t \mbox{:-} t_{1}, t_{2}, ..., t_n$ has a
corresponding {\em tree fragment}, with parent $t$ and children
$t_{j}$. The \emph{derivation tree} for $D$ is built by assembling the tree
fragments for all possible derivations of tuples in $D$. We distinguish the
multiple tree fragments for multiple derivations of $t$, but to simplify
notation, we use $t, t_1, \ldots$ to name tree nodes. Leaves of this tree
are elements of $E$.

A series of insertions and deletions to the extensional relations is
modeled as a sequence of values $t(0), \ldots, t(j)$ for each $t \in E$,
where 1 means present and 0 means absent. Similarly, for all tree nodes $t$, we
remember the sequence of values (presence or absence) assigned to $t$ by
the PSN algorithm after each child change.  We write $t(\infty)$ to represent
the value of $t$ once the network has quiesced.

Let $t$ be a tree node whose children are $t_{1},t_{2},...,t_{n}$.

\begin{Claim} \label{claim:fifoEdge} 
Along any tree edge $t_{k} \rightarrow t$, value changes are applied in
the order in which $t_{k}$'s change. This property is guaranteed by PSN's
FIFO queue.
\end{Claim}

\begin{Lem} \label{lem:fifoEdge}
$t(\infty)$ is derived using $t_{1}(\infty), \ldots, t_n(\infty)$.
\end{Lem}
\begin{proof} 
(By induction) $t(0)$ is computed from the initial values of its
children. Assume inductively that $t(j-1)$ is derived based on the
$(j-1)^{th}$ change in its children. If child $t_{k}$ changes, $t(j)$ is
rederived, and based on Claim~\ref{claim:fifoEdge}, reflects the latest
value of $t_{k}$. Hence, $t(\infty)$ is derived from the last value of all
its children.
\end{proof} 

Let $FP_{p}$ be the set of tuples derived using PSN under the bursty model,
and $FFP_{p}$ be the set of tuples that would be computed by PSN if
starting from the quiesced state.

\begin{Theorem} \label{theorem:burst}
$FP_{p} = FFP_{p}$ in a centralized setting.
\end{Theorem}
\begin{proof}
We write $t(\omega)$ for the values derived by PSN when its starting state
is $e(\infty)$ for $e \in E$. If $\forall t \in \mbox{$D$'s derivation
tree},$ $t(\omega) = t(\infty)$ then $FP_{p} = FFP_{p}$. We prove this by
induction on the height of tuples in the derivation tree. We define $D_i$
to be all nodes of $D$'s derivation tree at height $i$, with $D_0=E$.

In the base case, $\forall t \in D_0,$ $t(\infty) = t(\omega)$ by definition
of the base tuple values. In the inductive step, we assume that $\forall
j < i,$ $\forall t
\in D_j,$ $t(\infty) = t(\omega)$. Consider $t \in D_i$.  Based on
Lemma~\ref{lem:fifoEdge}, $t(\infty)$ will be derived from the
$t_k(\infty)$ values of its children, which by induction are equal to
$t_k(\omega)$.  Hence $t(\infty) = t(\omega)$.
\end{proof}

%\subsection{Distributed Updates}
%

\begin{Claim}\label{claim:fifoNetwork}As long as all network links obey
  FIFO for transmitted messages, Claim~\ref{claim:fifoEdge} is true
  for any children of $t$ that are generated using link-restricted
    Datalog rules. 
\end{Claim}

\begin{Theorem}\label{theorem:netburst}$FP_{p} = FFP_{p}$ in a distributed setting.
\end{Theorem}
\begin{proof}With Claim~\ref{claim:fifoNetwork}, the proof is similar to
  that of Theorem~\ref{theorem:burst}.\end{proof}


