Feeback at the talk:

1) how would we apply safehints approach outside the BFT domain? Is there a structured/algorithmic way for identifying such optimizations in other protocols?

2) BFT protocols are not in wide use and one big reason is the complexity of the protocols (in addition to hardware, computation and communication cost). Question is that the gains shown with PSHQ does not seem to justify the complexity added by the safe hints approach. Our results show 2 fold increase on throughput: is this good enough?

3) Is it important to combine all optimizations that we have come up with using the safe hints approach?Of course we do not want our paper to look like a bag of optimizations, but we have to watch out that we do not over-sell and make sure that  none of the optimizations look like stretching the safe hints architecture

   ** Or should we just say that this is one approach that has helped "us" in identifying hints and we hope that it might help others in identifying optimizations in their protocols as well.
   

4) why do we call these safe hints? For most examples, safety of the services is provided by the RSM.
    - Are there other examples of safe hints where a faulty  hint may cause safety to violate and we need checks outside the RSM?


Feedback from Ansley/Animesh/Andreas:

1) Optimizations shows look ad-hoc. Not sure if they fall into the safe hints.

2) May be we should say more precisely what exactly we  mean by safe hints and then present more simpler optimizations that do not go inside the details of the BFT black box like we have with hierarchical optimization.

3) Probably show that there is a lower bound on the amount of work that replicas have to do in a given BFT protocol. Our goal is to approach that and remove other
extraneous factors.

4) May be focus on the "methodology to optimize BFT protocols" for this paper. This will probably ease up the pressure on the experimental evaluation. (Krishna's feedback)


HOTOS Reviews:

* Almost everyone requires more justification for why it is called a design
pattern, how much can we push it and what are its limitations. [Our envelopes
basically answer the technical part of this question. More philosophical bits can
be probably handled in writing.]

* Is trust and verify a new idea? [Applicability to BFT domain is the novelty here. 
Also, we have to justify why it is more than just the introduction of "primary" to the
quorum protocols].

-- Not much meat to the design pattern. Is it just a small extension to HQ?

-- "safe hint" spin should have been explored
more if there is any more meat to it -- how far can these hints go? What
lessons can they offer?

-- I would recommend discussing other possible
uses for this design pattern, as a way of arguing that this is a useful
abstraction. Otherwise the paper might feel a bit incremental.

-- Most interesting insight is the trust-but-verify model, this is really the key
idea. Is this a new concept? Could there be other interesting uses of this
model?

.
