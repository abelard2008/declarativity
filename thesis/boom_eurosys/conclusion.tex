\section{Conclusion}
Our experience developing \BOOMA in Overlog resulted in a number of observations
that are useful on both long and short timescales.  Some of these may be
specific to our BOOM agenda of rethinking programming frameworks for distributed
systems; a number of them are more portable lessons about distributed system
design that apply across programming frameworks.

At a high level, the effort convinced us that a declarative language like
Overlog is practical and beneficial for implementing substantial systems
infrastructure, not just the isolated protocols tackled in prior work.  Though
our metrics were necessarily rough (code size, programmer-hours), we were
convinced by the order-of-magnitude improvements in programmer productivity, and
more importantly by our ability to quickly extend our implementation with
substantial new distributed features.  Performance remains one of our concerns,
but not an overriding one.  One simple lesson of our experience is that modern
hardware enables ``real systems'' to be implemented in very high-level
languages.  We should use that luxury to implement systems in a manner that is
simpler to design, debug, secure and extend --- especially for tricky and
mission-critical software like distributed services.

We have tried to separate the benefits of data-centric system design from our
use of a high-level declarative language. Our experience suggests that
data-centric programming can be useful even when combined with a traditional
programming language, particularly if that language supports set-oriented data
processing primitives (e.g., LINQ, list comprehensions). Since traditional
languages do not necessarily encourage data-centric programming, the development
of libraries and tools to support this design style is a promising direction for
future work.

% More substantially, the wide variety of behaviors required in a full system
% stack like \BOOMA allowed us to observe various distinct advantages of Overlog
% programming, which may offer more portable lessons outside the context of
% declarative languages.  Some of the data-centric design benefits we saw are
% broadly translatable across programming environments; other benefits depended
% upon the presence of parallel, set-oriented data processing primitives; some
% benefits arose from the features of a rich declarative language based in
% Datalog.  Our experience building \BOOMA was the first time we were able to
% unbundle these concerns to a degree, and we hope that more can be done in this
% vein.

Finally, our experience highlighted problems with Overlog that emphasize some
new research challenges; we mention two here briefly.  First and most urgent is
the need to codify the semantics of asynchronous computations and updateable
state in a declarative language.  We have recently made some progress on
defining a semantic foundation for this~\cite{dedalus-tr}, but it remains an
open problem to surface these semantics to programmers in an intuitive fashion.
A second key challenge is to clarify the implementation of invariants, both
local and global.  In an ideal declarative language, the specification of an
invariant should entail its automatic implementation.  In our experience with
Overlog this was hampered both by the need to explicitly write protocols to test
global invariants, and the multitude of possible mechanisms for enforcing
invariants, be they local or global.  A better understanding of the design space
for invariant detection and enforcement would be of substantial use in building
distributed systems, which are often defined by such invariants.

% We built \BOOMA\ to evaluate three key questions about
% data-centric programming of clusters: (1) can it significantly simplify
% the prototyping of distributed systems, (2) can it be used to write
% scalable, performant code, and (3) can it enable a new generation of
% programmers to innovate on novel cloud computing platforms.  Our
% experience suggests that the answer to the first of these questions is
% certainly true, and the second is within reach.  The third question is
% unresolved.  Overlog in its current form is not going to attract
% programmers to distributed computing, but we think that its benefits
% point the way to more pleasant languages that could realistically
% commoditize distributed programming in the Cloud.

% 
% are such we see this as a surmountable challenge for future work on a new data-centric language for Cloud computing.

%\jmh{Better wind up with some of the Cloudy goodness from the intro.  Did we make programmers lives better?  Overlog is not the language of the future.  it's ugly, and we didn't even scratch the surface on tricky semantic issues like negation.  But I think we got a good ways down the road with ``everything is data'', implicit messaging and the fact that we converted the choice between event-loop dispatch or multithreading into dataflow.}
% 
% 
% Keep this really short.  Try to pop up a level from the lessons.
% 
% Some future work ideas:
% \begin{itemize}
% 	\item {\em Managing multiple applications:} Does data-centric/declarative help cloud operators manage/sandbox applications?
% 	\item {\em Managing economics/billing}: Does data-centric/declarative allow developers and operators to write more flexible SLAs and perhaps agents that negotiate dynamically?
% 	\item {\em Many/small vs. Few/Large}: \BOOMA was an exercise in building a service spanning the cluster.  Does data-centric/declarative help with writing/managing many small instances, or is that already well handled?
% 	\item {\em Static and dynamic verification}:  Compare with MACE paper.
% 	\item {\em Cross-layer optimization}: We see hints of this in co-optimizing the runtime and code.  Perhaps some combo of David Chu's proxy selection optimization with leader election and availability?
% 	\item {\em Security:}  Probably move our nascent ideas here.  See end of the latex source.
% 	\item Add to me!
% \end{itemize}
