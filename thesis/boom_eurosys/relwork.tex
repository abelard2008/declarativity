\subsection{Related Work}
\label{sec:relwork}
Declarative and data-centric languages have traditionally been considered useful
in very few domains, but things have changed substantially in recent years.
MapReduce~\cite{mapreduce-osdi} has popularized functional dataflow programming
with new audiences in computing.  Also, a surprising breadth of recent research
projects have proposed and prototyped declarative languages, including overlay
networks~\cite{p2}, three-tier web services~\cite{hilda}, natural language
processing~\cite{dyna}, modular robotics~\cite{meld}, video
games~\cite{cornellgames}, file system metadata analysis~\cite{wiscfsck}, and
compiler analysis~\cite{bddbddb}.

Most of the languages cited above are declarative in the same sense as SQL: they are based in first-order logic.
 % and specify ``what'' the program outcomes should be, rather than ``how'' to achieve them.  
Some --- notably MapReduce, but also SGL~\cite{cornellgames} --- are
algebraic or dataflow languages, used to describe the
composition of operators that produce and consume sets
or streams of data.  Although arguably imperative, they are far closer
to logic languages than to traditional imperative languages like Java
or C, and are often amenable to set-oriented optimization techniques developed for declarative languages~\cite{cornellgames}.
% . Often there is an equivalence between algebraic and declarative languages; the proof of this equivalence for relational databases helped kick off that field~\cite{Codd72}. Because of these equivalences, declarative optimization techniques and formal proof techniques can be used on algebraic dataflow languages with appropriate hooks
Declarative and dataflow languages can also share the same runtime, as
demonstrated by recent integrations of MapReduce and SQL
in Hive~\cite{hive}, DryadLINQ~\cite{DryadLINQ},
HadoopDB~\cite{hadoopdb}, and products from vendors such as Greenplum and Aster.
% and commercial integrations of SQL and MapReduce.
% ~\cite{greenplum,aster}.
  % By contrast, traditional programming languages ask programmers to focus mostly on imperative threads of control specifying sequences of instructions, which typically run on a single machine and communicate with other threads via shared channels.

%Erlang is an interesting alternative approach to cluster programming.  
Concurrent with our work, the Erlang language was used to implement a simple MapReduce framework called Disco~\cite{disco} and a transactional DHT called Scalaris with Paxos support~\cite{scalaris}.
Philosophically, Erlang revolves around concurrent {\em actors}, rather than
data.  Experience papers regarding Erlang can be found in the literature (e.g.,~\cite{armistice}), and this paper can be seen as a complementary experience paper on building distributed systems in a data-centric fashion.  A closer comparison of actor-oriented and data-centric design styles is beyond the scope of this paper, but an interesting topic for future work.

%: Erlang programmers engage in the specification of small agents that pass messages, and Erlang advocates speak of the high numbers of concurrent ``processes'' involved in an implementation.  
%By contrast, the logic languages described above focus on data, and the logical implications of invariants over that data.  Overlog extends that data-centric notion with implicit asynchronous communication in a simple way.  
%We do not have experience to share regarding the suitability of Erlang for datacenter programming.  
% The Disco FAQ warns that ``Hadoop is probably faster, more scalable, and more featureful''~\cite{disco}.  By contrast, \BOOMA performs as well as Hadoop in apples-to-apples performance tests, and adds significant features.  Overlog seems to offer only modestly more compact code than Erlang --- as one example, the Scalaris Paxos implementation in Erlang has significantly more lines of code than our Overlog version, but in the same order of magnitude.

%\jmh{We need to check that this is not in Disco.  They have partitioned master nodes, it seems, but not fault-tolerant master nodes.}
% , which may not be as natural in Erlang's process-centric model.

Distributed state machines are the traditional formal model for distributed system implementations, and can be expressed in languages like Input/Output Automata (IOA) and the Temporal Logic of Actions (TLA)~\cite{lynchbook}.  By contrast, our approach is grounded in Datalog and its extensions.  % The pros and
% cons of starting with a data-centric foundation are a recurring theme of
% this paper.
% These ideas have been used extensively for network protocol design and verification~\cite{lotos,estelle}.   They also form the basis of the MACE~\cite{mace} language for overlay networks.  
%Those languages do not offer the query-like facilities for monitoring and management that data-centric languages provide, which we exploit for manageability and debugging as described in Section~\ref{sec:manage}. 
%These facilities seemed particularly useful for protocols such as Paxos that were originally specified in terms of logical invariants. %\rcs{Joe we changed this; we think sets of invariants are a better approach than IOA, TLA, and state machines are an artifact of existing languages}  
%As we discuss in Section~\ref{sec:manage}, this was confirmed by our experience, especially when we were able to convince ourselves of the correctness of our implementations by metaprogramming our logic.

Our use of metaprogrammed Overlog was heavily influenced by the Evita Raced
Overlog metacompiler~\cite{evitaraced}, and the security and typechecking
features of Logic Blox' LBTrust~\cite{lbtrust}.  Some of our monitoring tools
were inspired by Singh et al.~\cite{singh-eurosys}, although our metaprogrammed
implementation avoids the need to modify the language runtime as was done in that work.
