function problem=generateSlatHallway(KK,id,varargin)
% problem=generateSlatHallway(KK,id,...)
% the optional parameters fps, mps are passed to capture_trajectory
%
% Generates one of 9 "Hallway" scenarios 

if id==1                         % A line of cameras (hall11)
  pos2=[(-5:5)*0.75; ...
        ((-ones(1,11)).^(0:10))*(-1.5)-6.5; ...
        ones(1,11)*2.7; ...
        ((-ones(1,11)).^(0:10))*pi/2; ...
        -0.6*ones(1,11)];
  calib=generate_calibration(KK, pos2);
  problem=capture_trajectory(calib, 'range', [-7 7 -10 4], varargin{:});
  problem.adjacency=adjacency_mn(11,2);
  
elseif id==2                      % A sparse loop of cameras (hall12)
  pos1=[(-1:1)*1; ...
        -3*ones(1,3); ...
        ones(1,3)*2.7; ...
        ones(1,3)*pi/2; ...
        -0.7*ones(1,3)];
  pos2=[3*ones(1,3); ...
        (-1:1)*1; ...
        ones(1,3)*2.7; ...
        ones(1,3)*0; ...
        -0.7*ones(1,3)];
  pos3=[(-1:1)*1; ...
        3*ones(1,3); ...
        ones(1,3)*2.7; ...
        ones(1,3)*(-pi/2); ...
        -0.7*ones(1,3)];
  pos4=[-3*ones(1,3); ...
        (1:-1:-1)*1; ...
        ones(1,3)*2.7; ...
        ones(1,3)*pi; ...
        -0.7*ones(1,3)];
  calib=generate_calibration(KK, [pos1 pos2 pos3 pos4]);
  problem=capture_trajectory(calib, 'range', [-5 5 -5 5], varargin{:});
  %problem.geometry = ...
  %    {[-5.5 -8; 5.5 -8; 5.5 2.5;  -5.5 2.5;  -5.5 -8], ...
  %      [-2.5 -5; 2.5 -5; 2.5 -0.5; -2.5 -0.5; -2.5 -5]};
  %problem.adjacency=adjacency_mn(44,1,1);
  problem.adjacency=adjacency_mn(12,1,1);
  ii=[1 2 3 4 5 6 9 8 7 10 11 12];
  problem.adjacency=problem.adjacency(ii,ii);
  
elseif id==3                    % A dense loop (hall144)
  pos1=[(-5:5)*0.75; ...
        ((-ones(1,11)).^(0:10))*(-1.5)-6.5; ...
        ones(1,11)*2.7; ...
        ((-ones(1,11)).^(0:10))*pi/2; ...
        -0.6*ones(1,11)];
  pos2=[((-ones(1,11)).^(0:10))*1.5+4; ...
        (-10:0)*0.75 + 1; ...
        ones(1,11)*2.7; ...
        ((-ones(1,11)).^(0:10))*(-pi/2)+pi/2; ...
        -0.6*ones(1,11)];
  pos3=[(5:-1:-5)*0.75; ...
        ((-ones(1,11)).^(0:10))*(-1.5)+1; ...
        ones(1,11)*2.7; ...
        ((-ones(1,11)).^(0:10))*pi/2; ...
        -0.6*ones(1,11)];
  pos4=[((-ones(1,11)).^(0:10))*(-1.5)-4; ...
        (0:-1:-10)*0.75 + 1; ...
        ones(1,11)*2.7; ...
        ((-ones(1,11)).^(0:10))*(+pi/2)+pi/2; ...
        -0.6*ones(1,11)];
  calib=generate_calibration(KK, [pos1 pos2 pos3 pos4]);
  problem=capture_trajectory(calib, 'range', [-8 8 -10 4], varargin{:});
  problem.geometry = ...
      {[-5.5 -8; 5.5 -8; 5.5 2.5;  -5.5 2.5;  -5.5 -8], ...
        [-2.5 -5; 2.5 -5; 2.5 -0.5; -2.5 -0.5; -2.5 -5]};
  problem.adjacency=adjacency_mn(44,2,1);

elseif id==4                      % A dense loop with cameras facing right
  pos1=[(-5:5)*0.75; ...
        ((-ones(1,11)).^(0:10))*(-1.5)-6.5; ...
        ones(1,11)*2.7; ...
        ((-ones(1,11)).^(0:10))*pi/2; ...
        -0.6*ones(1,11)];
  pos2=[(-(ones(1,11)).^(0:10))*1.5+4; ...
        (-10:0)*0.75 + 1; ...
        ones(1,11)*2.7; ...
        pi*ones(1,11); ... %((-ones(1,11)).^(0:10))*(-pi/2)+pi/2; ...
        -0.6*ones(1,11)];
  pos3=[(5:-1:-5)*0.75; ...
        ((-ones(1,11)).^(0:10))*(-1.5)+1; ...
        ones(1,11)*2.7; ...
        ((-ones(1,11)).^(0:10))*pi/2; ...
        -0.6*ones(1,11)];
  pos4=[((ones(1,11)).^(0:10))*(-1.5)-4; ...
        (0:-1:-10)*0.75 + 1; ...
        ones(1,11)*2.7; ...
        pi*ones(1,11); ... %((-ones(1,11)).^(0:10))*(+pi/2)+pi/2; ...
        -0.6*ones(1,11)];
  calib=generate_calibration(KK, [pos1 pos2 pos3 pos4]);
  problem=capture_trajectory(calib, 'range', [-8 8 -10 4], varargin{:});
  problem.geometry = ...
      {[-5.5 -8; 5.5 -8; 5.5 2.5;  -5.5 2.5;  -5.5 -8], ...
        [-2.5 -5; 2.5 -5; 2.5 -0.5; -2.5 -0.5; -2.5 -5]};
  problem.adjacency=adjacency_mn(44,2,1);

elseif  id==5,                    % A dense open loop (hall33)
  pos1=[(-5:5)*0.75; ...
        ((-ones(1,11)).^(0:10))*(-1.5)-6.5; ...
        ones(1,11)*2.7; ...
        ((-ones(1,11)).^(0:10))*pi/2; ...
        -0.6*ones(1,11)];
  pos2=[((-ones(1,11)).^(0:10))*1.5+4; ...
        (-10:0)*0.75 + 1; ...
        ones(1,11)*2.7; ...
        ((-ones(1,11)).^(0:10))*(-pi/2)+pi/2; ...
        -0.6*ones(1,11)];
  %pos3=[(5:-1:-5)*0.75; ...
  %      ((-ones(1,11)).^(0:10))*(-1.5)+1; ...
  %      ones(1,11)*2.7; ...
  %      ((-ones(1,11)).^(0:10))*pi/2; ...
  %      -0.6*ones(1,11)];
  pos4=[((-ones(1,11)).^(0:10))*(-1.5)-4; ...
        (0:-1:-10)*0.75 + 1; ...
        ones(1,11)*2.7; ...
        ((-ones(1,11)).^(0:10))*(+pi/2)+pi/2; ...
        -0.6*ones(1,11)];
  calib=generate_calibration(KK, [pos1 pos2 pos4]);
  problem=capture_trajectory(calib, 'range', [-8 8 -10 4], varargin{:});
  problem.geometry = ...
      {[-5.5 -8; 5.5 -8; 5.5 2.5;  -5.5 2.5;  -5.5 -8], ...
        [-2.5 -5; 2.5 -5; 2.5 -0.5; -2.5 -0.5; -2.5 -5]};
  problem.adjacency=adjacency_mn(33,2,1); 

elseif id==6,      % Sparse loop with mixed overhead & side-facing cameras
  pos1=[-0.5  0.5    0.6  0.6    0.5   -.5     -0.6   -0.6; ...
        -0.6  -0.6   0.5    -0.5  0.6    0.6    0.5    -0.5; ...
        ones(1,8)*2.7; ...
        -pi/2 -pi/2 pi    pi   pi/2 pi/2 0   0; ...
        -0.65*ones(1,8)];
  pos2=[-1.65 -1.85   4     pi*5/4 -pi/2; 
         1.65 -1.85   4     pi*3/4 -pi/2;
         1.65  1.85   4     pi*1/4 -pi/2;
        -1.65  1.85   4     -pi*1/4 -pi/2]';
  calib=generate_calibration(KK, [pos1 pos2]);
  problem=capture_trajectory(calib, 'range',[-5 5 -5 5], varargin{:});
  a=1.2786;
  b=3;
  problem.geometry = ...
      {[-a -a; a -a; a a; -a a; -a -a], ...
       [-b -b; b -b; b b; -b b; -b -b]};
  adj=zeros(12);
  adj(1,2)=1;
  adj(2,10)=1;
  adj(10,4)=1;
  adj(4,3)=1;
  adj(3,11)=1;
  adj(11,5)=1;
  adj(5,6)=1;
  adj(6,12)=1;
  adj(12,7)=1;
  adj(7,8)=1;
  adj(8,9)=1;
  adj(9,1)=1;
  problem.adjacency=adj | adj';

elseif id==7,   % Sparse loop with mixed overhead and side-facing cameras
  pos1=[-0.5  0.5     3.6   3.6  0.5   -.5     -3.6   -3.6; ...
        -3.6   -3.6   -0.5  0.5  3.6    3.6    0.5    -0.5; ...
        ones(1,8)*2.6; ...
        +pi/2 +pi/2   0      0    -pi/2 -pi/2    pi     pi; ...
        -0.65*ones(1,8)];
  pos2=[ 2 -2   4   pi/4   -pi/2; ... %pi*3/4 -pi/2;
         2  2   4  -pi/4   -pi/2; ... %pi*1/4 -pi/2;
        -2  2   4  -pi/4*3 -pi/2; ...; %-pi*1/4 -pi/2]';
        -2 -2   4   pi/4*3 -pi/2]'; ... %pi*5/4 -pi/2; 
  pos=[];
  for i=1:4,
    pos=[pos pos1(:,(i*2-1):(i*2)) pos2(:,i)];
  end
  calib=generate_calibration(KK, pos);
  problem=capture_trajectory(calib, 'range',[-5 5 -5 5], varargin{:});
  a=1.2786;
  b=3;
  problem.geometry = ...
      {[-a -a; a -a; a a; -a a; -a -a], ...
       [-b -b; b -b; b b; -b b; -b -b]};
  problem.adjacency=adjacency_mn(12,1,1); 
elseif id==8,    %Small loop with mixed overhead and side-facing cams
  pos1=[-0.5  0.5     3.3   3.3  0.5   -.5     -3.3   -3.3; ...
        -3.3   -3.3   -0.5  0.5  3.3    3.3    0.5    -0.5; ...
        ones(1,8)*2.6; ...
        +pi/2 +pi/2   0      0    -pi/2 -pi/2    pi     pi; ...
        -0.68*ones(1,8)];
  pos2=[ 1.8 -1.8   4   pi/4   -pi/2; ... %pi*3/4 -pi/2;
         1.8  1.8   4  -pi/4   -pi/2; ... %pi*1/4 -pi/2;
        -1.8  1.8   4  -pi/4*3 -pi/2; ...; %-pi*1/4 -pi/2]';
        -1.8 -1.8   4   pi/4*3 -pi/2]'; ... %pi*5/4 -pi/2; 
  pos=[];
  for i=1:4,
    pos=[pos pos1(:,(i*2-1):(i*2)) pos2(:,i)];
  end
  calib=generate_calibration(KK, pos);
  problem=capture_trajectory(calib, 'range',[-5 5 -5 5], varargin{:});
  a=1.2786;
  b=3;
  problem.geometry = ...
      {[-a -a; a -a; a a; -a a; -a -a], ...
       [-b -b; b -b; b b; -b b; -b -b]};
  problem.adjacency=adjacency_mn(12,1,1); 
elseif id==9,    %Small dense loop with mixed overhead and side-facing cams
  pos1=[-0.5  0.5     3.3   3.3  0.5   -.5     -3.3   -3.3; ...
        -3.3   -3.3   -0.5  0.5  3.3    3.3    0.5    -0.5; ...
        ones(1,8)*2.6; ...
        +pi/2 +pi/2   0      0    -pi/2 -pi/2    pi     pi; ...
        -0.68*ones(1,8)];
  pos2=[ 1.7 -1.7   4   pi/4   -pi/2; ... %pi*3/4 -pi/2;
         1.7  1.7   4  -pi/4   -pi/2; ... %pi*1/4 -pi/2;
        -1.7  1.7   4  -pi/4*3 -pi/2; ...; %-pi*1/4 -pi/2]';
        -1.7 -1.7   4   pi/4*3 -pi/2]'; ... %pi*5/4 -pi/2; 
  pos=[];
  for i=1:4,
    pos=[pos pos1(:,(i*2-1):(i*2)) pos2(:,i)];
  end
  calib=generate_calibration(KK, pos);
  problem=capture_trajectory(calib, 'range',[-5 5 -5 5], varargin{:});
  a=1.2786;
  b=3;
  problem.geometry = ...
      {[-a -a; a -a; a a; -a a; -a -a], ...
       [-b -b; b -b; b b; -b b; -b -b]};
  problem.adjacency=adjacency_mn(12,1,1); 
end
