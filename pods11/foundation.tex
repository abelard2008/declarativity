\section{\large \bf \lang}
\label{sec:slang}

\lang is related to Datalog$\lnot$~\cite{ullmanbook}: Datalog enhanced with arbitrary negation (we will henceforth refer to Datalog$\lnot$ as ``Datalog'').  We admit the order constraints \dedalus{<}, \dedalus{=}, \dedalus{!=}, and \dedalus{<=}, over all elements in the universe.  We also admit the \dedalus{count} {\em aggregate}, which computes the number of elements in a set.  Our syntax for \dedalus{count}, similar to~\cite{datalog-agg}, allows its use in the head of a rule, such as: 

\begin{Dedalus}
p(X1, ..., Xn, count<Y>) <- ...;
\end{Dedalus}

For each binding of \dedalus{X1, ..., Xn}, \dedalus{p} contains the count of distinct satisfying assignments to the variable \dedalus{Y}.  Any column of a predicate that hosts a \dedalus{count} aggregate is considered to be of the {\em number} sort; any variable of the {\em number} sort can only be constrained by other variables of the {\em number} sort, and we forbid recursion through \dedalus{count}.

Each predicate in \lang has a distinguished {\em temporal attribute}, of the {\em temporal} sort.  The balance of the arguments are {\em data} arguments, and may not contain any variable of the {\em temporal} sort.  \lang contains an infinite unary relation \dedalus{time} $= \mathbb{N}$, and an infinite binary relation \dedalus{successor} $:= \{(a,b) | a,b \in \mathbb{N} \land b = a + 1\}$, whose arguments are all of the {\em temporal} sort.  To model network nondeterminisim, we require the use of Sacc\`{a} and Zaniolo's \dedalus{choice} construct to bind a rule's head temporal attribute when modeling communication.

\wrm{move this somewhere}
{\bf Modeling failure:}  Later, when we discuss \lang with failure, we will add the element $\infty$ to \dedalus{time} to model transient or permanent channel failure, or transient node failure.  Furthermore, to model permanent node failure, we will assume all rules have the \dedalus{!fail()} predicate in their body, except for a single rule \dedalus{fail()@async <- enabled();}, and all programs have an \dedalus{enabled()} fact, where \dedalus{enabled} is a predicate symbol that does not otherwise appear in the program.  \wrm{Also, we assume durability through transient node failure?}  \wrm{Also note that failure makes confluence impossible}

\lang requires that all atoms in each rule body use the same temporal variable symbol in their temporal attribute.  The temporal variable in the head atom may be constrained by exactly one of the following methods:

\begin{enumerate}
\item The rule is called an {\em atemporal rule} if its head temporal variable is the same as its body temporal variable;
\item The rule is called an {\em inductive rule} if its head temporal variable is the \dedalus{successor} of its body temporal variable;
\item The rule is called an {\em asynchronous rule} if its head temporal variable is constrained using the \dedalus{choice} construct over all body variables (including the body temporal variable).
\end{enumerate}

\begin{example}
The following are examples of well-formed deductive, inductive, and asynchronous rules, respectively.
\\\\
deductive:
\begin{Dedalus}
p(A, B, T) <- e(A, B, T);
\end{Dedalus}
inductive:
\begin{Dedalus}
q(A, B, S) <- e(A, B, T), successor(T, S);
\end{Dedalus}
asynchronous:
\begin{Dedalus}
r(A, B, S) <- e(A, B, T), time(S),
              choose((A, B, T), (S));
\end{Dedalus}
\end{example}

Since unification on the temporal attribute is required in every rule body, we introduce syntax sugar that omits the body temporal variable.  Since the relationship between the head and body temporal variables is tightly constrained, we may omit the head temporal variable and instead introduce a temporal annotation: \dedalus{@next} or \dedalus{@async}.  Below, we rewrite the above rules using this syntax sugar:

\begin{example}
The following are examples of sugared well-formed deductive, inductive, and asynchronous rules, respectively.
\\\\
deductive:
\begin{Dedalus}
p(A, B) \(\leftarrow\) e(A, B);
\end{Dedalus}
inductive:
\begin{Dedalus}
q(A, B)@next \(\leftarrow\) e(A, B, T);
\end{Dedalus}
asynchronous:
\begin{Dedalus}
r(A, B)@async \(\leftarrow\) e(A, B, T);
\end{Dedalus}
\end{example}

\wrm{\lang only allows recursion through negation if the recursion passes through at least one \dedalus{@next} or \dedalus{@async}.}

\lang adopts the ``horizontal partitioning'' conventionintroduced by Loo et al. and used in many subsequent efforts~\cite{Loo:2005}. To represent a distributed system, we consider some number of agents, each running a copyof the same program against a disjoint subset ({\em horizontal partition}) of each predicate's contents.  We require one attribute in each predicate to be used to identify the partitioning for tuples in that predicate. We call such an attribute a {\em location specifier}, and prefix it with a \dedalus{\#} symbol in Dedalus.

We constrain \lang rules so that the location specifier variable in each body predicate be the same---i.e.\ the body contains tuples from exactly one partition of the database, logically colocated (on a single ``machine'').  If the head of the rule has the same location specifier variable as the body, we call the rule {\em local}.
%since its results can remain on the machine where they are computed.
If the head has a different variable in its location specifier, we call the rule a {\em communication rule}.  A communication rule must be asynchronous

By restricting bodies to a single agent, the only communication
modeled in \lang is modeled by communication rules.  Second, because
all communication rules are asynchronous, agents may only learn about
time values at another agent by receiving messages (with unbounded
delay) from that agent.  Note that this model says nothing about the
relationship between the agents' clocks; they could be
non-monotonically increasing, or they could respect a global order.

\subsection{Design Rationale and Implications}

Below we explain the rationale for certain choices.
\wrm{We need to remember to mention the dual role of time.  Atomicity and non-determinism.  Say stuff about dense partial orders.}

{\bf Time:}
We want to model intermediates states of distributed systems that are not necessarily models of the programs and their
input (e.g., to represent states with messages that are in flight, in which the premises
of certain implications hold but their conclusions do not).
Moreover, distributed systems are often noninflationary over time.  However, Datalog's {\em least fixpoint} operator is inflationary.  Reifying time into the langauge solves both these problems.

{\bf Locality in Time and Space:}
\begin{definition}
The {\em temporal diameter} of a \lang program is the number of ``old values'' accessible for a fact \wrm{formalize}.
\end{definition}

Every \lang program has a temporal diameter polynomial in the data size \wrm{or is this linear??}.\footnote{We can allow a program to have an unbounded temporal diameter by allowing {\em entanglement} between the {\em temporal} kind and the {\em data} kind.  This is sufficient to model an arbitrary Turing Machine in \lang (via substitution of \dedalus{finite\_succ} with \dedalus{successor} in the proof of Lemma~\ref{lem:} in the appendix.}.

\paa{still not sure what we need this for}

%\begin{example}
%A \lang program with a temporal diameter of 2.
%
%\begin{Dedalus}
%p_1(X,Y)@next \(\leftarrow\) p(X,Y);
%p_2(X,Y)@next \(\leftarrow\) p_1(X,Y);
%r(X,Y) \(\leftarrow\) p_2(X,Y), q(X,Y);
%\end{Dedalus}
%\end{example}

\subsection{Semantics}
The semantics of a \lang program can be characterized by the {\em stable model semantics}~\cite{stable-model} for logic programming.  Intuitively, a stable model of a \lang program is a trace of its \paa{a single execution, right?} distributed execution.  The stable model contains all input, intermediate stages of the computation, and all messages sent.  Note that a stable model of a \lang program may be infinite, such as in the following example:

\begin{example}
\label{ex:flipflop}
A \lang program with an infinite stable model.

\begin{Dedalus}
flipflop(Y,X)@next \(\leftarrow\) flipflop(X,Y);
flipflop(1,2)@1;
\end{Dedalus}
\end{example}

\dedalus{flipflop(1,2)} is true at all odd times, and \dedalus{flipflop(2,1)} is true at all even times.

Such periodicities are not unfamiliar to the logic programming community.  

\begin{definition}
A cycle is {\em nontrivially periodic} if its period is at least 2.  Otherwise, it is {\em trivially periodic}.
\end{definition}

The program in Example~\ref{ex:flipflop} has a nontrivially periodic cycle of period 2.  Previous work in temporal deductive databases attempted to compute finite representations for such periodicities~\cite{tdd-infinite}.  Additionally, the noninflationary generalization of the least fixpoint---the {\em partial fixpoint}---is equal to all trivially periodic cycles.  We adopt the latter approach of ignoring nontrivial periodicity when defining the output of a \lang program.

\begin{definition}
For each stable model, the nontrivially \paa{?? you mean trivially, right?} periodic cycles comprise an {\em ultimate model} for the program.  We represent a nontrivially periodic cycle in the ultimate model finitely by picking a representative, and discarding its timestamp.
\end{definition}

For example, the cycle \{\dedalus{p(a,7); p(a,8); p(a,9);} \ldots\} is represented in the ultimate model as \dedalus{p(a)}.  A program may have multiple distinct ultimate models if it has multiple stable models with different nontrivial periodicities.

The program in Example~\ref{ex:flipflop} has a single ultimate model, which is empty.

Note that ultimate models are always of finite cardinality (polynomial in the input size) because only constants of the {\em data} kind appear in any ultimate model, and there are only finitely many such constants.  By the same reasoning, a \lang program may only have a finite number of different ultimate models (exponential in the input size), whereas it may have uncountably many stable models, as infinitely many messages may be sent \paa{why not countable?}:

\begin{example}
A \lang program with uncountably many stable models, but a single ultimate model.

\begin{Dedalus}
p(X,Y)@next \(\leftarrow\) p(X,Y);
r(#X,Y)@async \(\leftarrow\) p(X,Y);
\end{Dedalus}
\end{example}

A Dedalus program without asynchronous rules has a single stable model.  This corresponds to its perfect model evaluated with a local stratification on time, as in~\cite{deductiveupdates}.  It is known that the stable model semantics coincides with the perfect model semantics for locally stratified programs~\cite{stable-model}, so our usage here is consistent.

\wrm{In the CRON conjecture below, we should explain how purely monotonic logic does not allow us to establish a ``happens before'' relation on network traffic.  If we can't express it, then intuitively it doesn't matter whether the execution abides by the property.}

\begin{lemma}
Any non-deterministic choice of timestamps induces a stable model for a \lang program with no recursion through negation; If a \lang program has recursion through negation, only a causal choice of timestamps is permissible~\footnote{This lemma is similar in spirit to Hellerstein's CRON conjecture~\cite{declarative-imperative}.}.
\end{lemma}

Note that we have not restricted \dedalus{async} to choose a timestamp in the future.  Thus, one may be concerned about a {\em temporal paradox}, such as the grandfather paradox.  A program that we might be worried about would be the following:

\begin{Dedalus}
g(X)@next \(\leftarrow\) g(X), !del_g(X);
del_g(X)@async \(\leftarrow\) p(X), g(X);
p(1)@3;
g(1)@1;
\end{Dedalus}

Taking the operational interpretation, we might posit the folowing trace, where \dedalus{p(1)@3, g(1)@3} cause \dedalus{del\_g(1)@2} in the past, implying that \dedalus{g(1)@3} should never have existed:

\begin{Dedalus}
g(1)@1;
g(1)@2;
del_g(1)@2;
g(1)@3;
p(1)@3;
\end{Dedalus}

\begin{proof}
By the definition of the stable model semantics, such situations due not produce stable models~\cite{stable-model}.  Whereas, if recursion through negation is unsatisfiable, all choices of timestamps produce stable models.
\end{proof}

\subsection{Operational Interpretation}
\lang programs are intended to capture the execution of an asynchronous distributed system.  An important property of distributed systems is that individual computers cannot control or observe the temporal interleaving of their computations with other computers.  One aspect of this uncertainty is captured in network delays: the arrival ``time'' of messages cannot be directly controlled by either sender or receiver.

For example, a fact, \dedalus{p($C_1 \ldots C_n$, $C_{n+1}$)}, with some constant $C_{n+1}$ in its time
suffix can be thought of as a fact that is true ``at time $C_{n+1}$''.

Deductive rules can be seen as {\em instantaneous} statements: their deductions hold for 
predicates agreeing in the time suffix and describe what is true ``for an instant'' given 
what is known at that instant.
 Inductive and asynchronous 
 rules are {\em temporal}---their consequents are defined to
be true ``at a different time'' than their antecedents.

Operationally, we can model a \lang execution as a collection of Turing Machines, each enhanced with an input queue; the machine is polynomially time bounded, during which time it can perform normal operations, and additionally write to its queue, or the queue of any other machine; after the machine has executed, the tape is erased, and atomically, the queue is erased and the tape initialized with the contents of the queue. \wrm{how do we decide whether the Turing Machine has accepted???? need coordination?}

\begin{lemma}
For any \lang program, the family of ultimate models is the same as the elements which are eventually always in the queue of the Turing Machine. \wrm{blah}
\end{lemma}
\begin{proof}
\end{proof}


\subsection{Complexity}

The language of confluent \lang programs is equal to the language of PSPACE, provided we introduce a \dedalus{bit} relation as described in Immerman.  The main part of the proof is that adding recursion or choice to FO[PFP] does not screw things up.  \wrm{This may not be important for the paper, but I feel we should at least mention something offhand so people don't think ``wow you've got this language but can it really express a wide range of distributed systems?''  Also, the fact that it corresponds so well with existing languages suggests it's a natural characterization.}
