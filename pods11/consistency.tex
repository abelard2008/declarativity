\section{Eventual Consistency}

In the previous section, we relaxed confluence to allow greater availability.  However, traditionally in the distributed systems domain, systems are of such a large scale that replication of functionality is required to ensure good performance, fault tolerance, and availability, as the system scales.  This symmetry property implies a spectrum of natural correctness criteria called {\em consistency}.  In particular, {\em eventual consistency} is defined in the distributed systems domain as all replicas will eventually return the latest data after the last update is made.

We formalize the notion of consistency using {\em constraints}.

\begin{definition}
A {\em constraint} is a rule whose head consists of a special predicate called \dedalus{fail()}.  We say a constraint is {\em violated} if it is satisfiable in any ultimate model.  Since constraints are not meant to be executed, we do not require them to unify on location specifiers.
\end{definition}

\wrm{It seems sensible to define the notion of a replicated predicate, rather than generalize to a replicated subset of a predicate}
We augment the definition of a \lang program to include a set of {\em replicated predicates} -- predicates that will be eventually always identical on all replicas.

\begin{definition}
\label{def:ec}
A \lang program is {\em eventually consistent} if the following constraint is unsatisfiable for all replicated predicates \dedalus{p}:

\begin{Dedalus}
fail() <- p(#Y,\(\bar{X}\)), !p(#Z,\(\bar{X}\)), replica(Y), replica(Z);
\end{Dedalus}
\end{definition}
\paa{this is too specific; there is more than one way to skin a cat.  why do we need to define replication in terms of participating rules?}

%means that all replicas eventually have the same replicated state, for any non-deterministic choices of time.  In other words, every ultimate model has the symmetry property that the contents of any replicated predicate is equivalent at all the replicas.

\begin{lemma}
In general, proving unsatisfiability of constraints for all EDBs is undecidable.
\end{lemma}
\begin{proof}
Proved in~\cite{qs-datalog} for Datalog programs with IDB negation; any Datalog program has a corresponding \lang program consisting of the original rules converted into atemporal \lang rules in the obvious way.
\end{proof}

\begin{lemma}
In particular, proving unsatisfiability of the constraint listed in Definition~\label{def:ec} is undecidable.
\end{lemma}
\begin{proof}
Proof sketch: Assume two different 2CMs are modeled at two different replicas.  Deciding eventual consistency implies we can decide whether the two 2CMs accept the same input, which is undecidable.
\end{proof}
%\paa{not sure I get it.  We are asking if a program is EC wrt a particular set of known constraints (those that 
%axiomatize ``replication'').  this is not tantamount to inferring FDs -- but it is query satisfiability, right?}

%Adding {\em replication} \wrm{define} to a confluent program yields an eventually consistent program.  However, there are some eventually consistent programs that are not confluent.

\begin{example}
An eventually consistent program that is not confluent.

\begin{Dedalus}
p(X)@async <- p_edb(X);
s(X) <- p(X), !s(_);
r(#R, X) <- replica(R), s(X);
\end{Dedalus}
\end{example}

The above program is eventually consistent under the integrity constraint \dedalus{fail() <- r(\_, X), r(\_, Y), X != Y;}, but it is not confluent: the second rule ensures that the contents of \dedalus{s} is the first \dedalus{p} fact to arrive.  Thus, the second rule induces multiple ultimate models if \dedalus{p\_edb} has more than one element.  However, all ultimate models satisfy the integrity constraint. \paa{not sure why this is interesting.  you are just saying hey, there's
this nice property called confluence, and here's an arbitrary constraint, and note that the arbitrary constraint
doesn't imply confluence.}

\wrm{Define a replication protocol; explain when adding a replication protocol to a program preserves EC -- downstream confluence requirement, no upstream requirements.  replication protocol must not use negation??}

\begin{lemma}
If a program $P$ satisfies an integrity constraint $I$, then any program obtained by adding replication rules to $P$ is eventually consistent with respect to $I$.
\end{lemma}
\begin{proof}
Sketch: due to the restricted nature of replication rules (a replication rule does not introduce new facts into a predicate) and functional dependencies (they cannot constrain locations), replication rules cannot violate functional dependencies.
\end{proof}
