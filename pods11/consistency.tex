\section{Eventual Consistency}

In the previous section, we relaxed confluence to allow greater availability.

However, many distributed systems are of such a large scale that replication of functionality is required to ensure good performance, fault tolerance, and availability.  This symmetry property implies a spectrum of natural correctness criteria called {\em consistency} properties.  In particular, {\em eventual consistency} is defined in the distributed systems domain as all replicas will eventually have a piece of data after the last update is made.

\wrm{Note that we're ignoring failure in this section}

We formalize the notion of consistency using {\em constraints}.

\begin{definition}
A {\em constraint} is a rule whose head consists of a special predicate called \dedalus{fail()}.  We say a constraint is {\em violated} if it is satisfiable in any ultimate model.  Since constraints are not meant to be executed, we do not require them to unify on location attributes \wrm{explain why this is not a problem}.
\end{definition}

In order to talk about eventual consistency, we need to differentiate replicated data from partitioned data, and define a set of replicas.  It seems sensible to do this on the predicate level, rather than generalizing to replicated subsets of predicates.  We augment the definition of a \lang program to include a set of {\em replicated predicates}, and a set of {\em replicas} represented by a unary \dedalus{replica} predicate.

\begin{definition}
\label{def:ec}
A \lang program is {\em eventually consistent} if it is consistent under the following constraint, for all replicated predicates \dedalus{p}:

\begin{Dedalus}
fail() <- p(#Y,\dbar{X}), !p(#Z,\dbar{X}), replica(Y), replica(Z);
\end{Dedalus}

In other words, the constraint is violated whenever a fact in a replicated predicate exists at some replica, but does not exist at some other replica.
\end{definition}

\wrm{this definition corresponds to peter's citation}

Note that an eventually consistent program is not necessarily confluent---for example, symmetrically replicating the results of a nondeterministic operation---and a confluent program is not necessarily eventually consistent---for example, a program that deterministically improperly replicates.  Like confluence, however, eventual consistency is undecidable.

%\paa{this is too specific; there is more than one way to skin a cat.  why do we need to define replication in terms of participating rules?}
%means that all replicas eventually have the same replicated state, for any nondeterministic choices of time.  In other words, every ultimate model has the symmetry property that the contents of any replicated predicate is equivalent at all the replicas.

%\begin{lemma}
%In general, proving constraint satisfiability for all EDBs is undecidable.
%\end{lemma}
%\begin{proof}
%Proved in~\cite{qs-datalog} for Datalog programs with IDB negation; any Datalog program has a corresponding \lang program consisting of the original rules converted into deductive \lang rules in the obvious way.
%\end{proof}

\begin{lemma}
In particular, proving constraint satisfiability for the constraint listed in Definition~\label{def:ec} is undecidable.
\end{lemma}
\begin{proof}
Proof sketch: Assume two different 2CMs are modeled at two different replicas.  Deciding eventual consistency implies we can decide whether the two 2CMs accept the same input, which is undecidable.
\end{proof}
%\paa{not sure I get it.  We are asking if a program is EC wrt a particular set of known constraints (those that 
%axiomatize ``replication'').  this is not tantamount to inferring FDs -- but it is query satisfiability, right?}

%Adding {\em replication} \wrm{define} to a confluent program yields an eventually consistent program.  However, there are some eventually consistent programs that are not confluent.

%\begin{example}
%An eventually consistent program that is not confluent.
%
%\begin{Dedalus}
%p(X)@async <- p_edb(X);
%s(X) <- p(X), !s(_);
%r(#R, X) <- replica(R), s(X);
%\end{Dedalus}
%\end{example}

%The above program is eventually consistent under the integrity constraint \dedalus{fail() <- r(\_, X), r(\_, Y), X != Y;}, but it is not confluent: the second rule ensures that the contents of \dedalus{s} is the first \dedalus{p} fact to arrive.  Thus, the second rule induces multiple ultimate models if \dedalus{p\_edb} has more than one element.  However, all ultimate models satisfy the integrity constraint. \paa{not sure why this is interesting.  you are just saying hey, there's
%this nice property called confluence, and here's an arbitrary constraint, and note that the arbitrary constraint
%doesn't imply confluence.}

How can conservative checks and coordination help us enforce eventual consistency?  One way is to insert a replication protocol into a \lang program.  Note that just as the coordination protocols we insert may be too conservative in waiting, the replication protocols we insert may conservatively send too many network messages.  


\begin{definition}
The {\em replication rule} for a predicate \dedalus{p}, where \dedalus{rep\_p} is a fresh predicate symbol not otherwise used in the program, is:

\begin{Dedalus}
rep_p(#R,\dbar{X})@async <- replica(#R), p(\dbar{X});
\end{Dedalus}
\end{definition}

\begin{definition}
A program is {\em downstream confluent} with respect to a predicate \dedalus{p} if \wrm{removing all rules and predicates yields a confluent program, and any EDB in the new program that's above an async edge in the original program should be delivered by async} yields a confluent program.
\end{definition}

We can instrument an arbitrary \lang program to enable eventual consistency by inserting a replication rule for all predicates \dedalus{p}.


We must then rewrite the program above \dedalus{p} to use \dedalus{rep\_p} wherever \dedalus{p} was required.  It must also be the case that the program above \dedalus{p} is confluent (of course this does not imply the program as a whole is confluent).  We require confluence in order to ensure determinism at each replica.  We disallow recursion through replication.  If these conditions are met, the program is eventually consistent.  Note that this definition is flexible enough to admit any scheme where clients are updating and querying replicas.

\wrm{examples?}
\wrm{define downstream confluence}

\begin{theorem}
If a program $P$ is rewritten with replication using the above procedure, it is eventually consistent.
\end{theorem}
\begin{proof}
Sketch: it is easy to verify that \dedalus{rep\_p} is correctly replicated for all replicated predicates \dedalus{p}; thus eventual consistency constraints are satisfied.
\end{proof}
