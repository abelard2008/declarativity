\section{Eventual Consistency}

In distributed systems, non-determinism that introduces different ultimate models is often accepted, as long as each ultimate model satisfies a certain property.  We formalize this notion through {\em constraints}.

\begin{definition}
A {\em constraint} is a rule that defines \dedalus{fail()}.  We say a constraint is {\em violated} if the ultimate model contains \dedalus{fail()}; otherwise the constraint is {\em satisfied}
\end{definition}

Any functional dependency may be encoded as a set of constraints.  The proof is straightforward so we omit it and instead provide the following example:

\begin{example}
A set of constraints expressing that the last two arguments of predicate \dedalus{p} are functionally dependent on the first two.

\begin{Dedalus}
fail() <- p(A,B,C,_), p(A,B,D,_), C != D;
fail() <- p(A,B,_,C), p(A,B,_,D), C != D;
\end{Dedalus}
\end{example}

\begin{definition}
A {\em replication rule} is a rule that 
\end{definition}

\begin{definition}
A \lang program is {\em eventually consistent} with respect to a set of constraints over replicated state if the constraints are satisfied.
\end{definition}

%means that all replicas eventually have the same replicated state, for any non-deterministic choices of time.  In other words, every ultimate model has the symmetry property that the contents of any replicated predicate is equivalent at all the replicas.

\begin{lemma}
Eventual consistency of a \lang program is undecidable
\end{lemma}
\begin{proof}
Proof sketch: convert Datalog program to \lang program that for a given key, replicates each different value to a different node; do this for all possible keys and values (exponentialy many).  Ask if each program is eventually consistent.  At the end, you've inferred functional dependencies in a Datalog program, which we know is undecidable.
\end{proof}

Adding {\em replication} \wrm{define} to a confluent program yields an eventually consistent program.  However, there are some eventually consistent programs that are not confluent.

\begin{example}
An eventually consistent program that is not confluent.

\begin{Dedalus}
p(X)@async <- p_edb(X);
s(X) <- p(X), !s(_);
r(#R, X) <- replica(R), s(X);
\end{Dedalus}
\end{example}

The above program is eventually consistent under the integrity constraint \dedalus{fail() <- r(\_, X), r(\_, Y), X != Y;}, but it is not confluent: the second rule ensures that the contents of \dedalus{s} is the first \dedalus{p} fact to arrive.  Thus, the second rule induces multiple ultimate models if \dedalus{p\_edb} has more than one element.  However, all ultimate models satisfy the integrity constraint.

\begin{lemma}
If a program $P$ satisfies an integrity constraint $I$, then any program obtained by adding replication rules to $P$ is eventually consistent with respect to $I$.
\end{lemma}

