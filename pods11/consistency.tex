\section{Replica Consistency}
\label{sec:consistency}

In the previous section, we provided tests and constructions to ensure a very strong notion of consistency: confluence.  This addresses many of the concerns that arise from the non-deterministic scheduling inherent in distributed computing, and encompasses traditional mechanisms like coordination protocols in a model-theoretic framework where we can prove desirable properties.

As a separate matter, many distributed systems replicate some or all of their functionality to provide lower variance in response time, and higher availability.  
To reason about whether such replication is implemented correctly, we may formalize many
natural correctness criteria as distributed {\em replica consistency} properties.
In particular, in the distributed systems domain {\em eventual consistency} of replicated data is defined by asserting that all distributed copies of a fact will eventually have the same value after the last update is made. \jmh{I tweaked the previous sentence, make sure you're OK with.  Question in my mind is what is the object that you want to say is being replicated: a fact or a collection?  I settled on fact.}

\wrm{Note that we're ignoring failure in this section}

We formalize the notion of replica consistency using Dedalus {\em constraints}.  In the remainder of this section, when we use the term consistency we refer to replica consistency.

\begin{definition}
A Dedalus {\em constraint} is a rule whose head consists of a special predicate called \dedalus{fail()}.  We say a constraint is {\em violated} if it is satisfiable in any ultimate model.  Since constraints are not meant to be executed, we do not require them to unify on location attributes \wrm{explain why this is not a problem}.  \paa{presumably because we are interested
in showing conservatively that certain constraints are unsatisfiable, rather than having them
``fire'' at runtime... but we never actually do so, right?}
\end{definition}

In order to talk about eventual consistency, we need to differentiate between replicated 
%data from partitioned \jmh{non-replicated?} 
and local
data, and define a set of replicas.  
%\jmh{For simplicity of notation, and without loss of generality, we define replicas on the predicate level?}  
%It seems sensible to do this on the predicate level, rather than generalizing to replicated subsets of predicates.  
For simplicity of notation, and without loss of generality, we define replicas on the predicate level rather than generalizing to replicated subsets of predicates.  
We note that partitioning of predicates, which can lead to finer-grained replication, 
entails an orthogonal set of correctness criteria which can likewise be formulated as
distributed constraints.
We augment the definition of a \lang program to include a set of {\em replicated predicates}, and a set of {\em replicas} represented by a unary \dedalus{replica} predicate.  
%\jmh{Argue no loss of generality w.r.t a setting where the replicas differ per predicate or per fact?}

\begin{definition}
\label{def:ec}
A \lang program is {\em eventually consistent} if it is consistent under the following constraint, for all replicated predicates \dedalus{p}:

\begin{Dedalus}
fail() <- p(#Y,\dbar{X}), !p(#Z,\dbar{X}), replica(Y), replica(Z);
\end{Dedalus}

In other words, the constraint is violated whenever a fact in a replicated predicate exists at some replica, but does not exist at some other replica.
\end{definition}

\wrm{this definition corresponds to peter's citation} \jmh{This is instantaneous consistency, not eventual consistency.  No?}
\paa{true.  perhaps what we really are interested in isn't the unsatisfiability of fail(), but the
fact that it never occurs in an ultimate model -- i.e., it is ``eventually always false.''}


%\jmh{The next para doesn't read nice}
%Note that an eventually consistent program is not necessarily confluent---for example, %symmetrically replicating the results of a nondeterministic operation---and a confluent program is not necessarily eventually consistent---for example, a program that deterministically improperly replicates.  Like confluence, however, eventual consistency is undecidable.

Note that an eventually consistent program is not necessarily confluent, and that
a confluent program is not necessarily eventually consistent.  For example, a program
that symmetrically replicates the consequences of nondeterministic operations satisfies
the consistency constraints but certainly has multiple ultimate models.  Further, a confluent
program may incorrectly specify replication logic.  \jmh{If the logic is incorrectly specified, is it really replication?  I think you want to say that a confluent program may violate replica constraints.}

\jmh{more importantly, I think we *should* discuss the connection between replica consistency and confluence: downstream confluence.  Can we say that replication requires a restricted confluence guarantee, which can be guaranteed by a restricted monotonicity test?  This properly sets up general confluence as a stronger guarantee in certain ways than replica consistency -- it requires confluence to cover all predicates, not just a chosen subset.  Note that the EC folks probably don't care about downstream confluence beyond the guarded persistence of the replication channel.  So we're exposing a spectrum of ``how much program logic do you care about here''.  This does more to keep CALM.}


Like confluence, eventual consistency is undecidable.

%\paa{this is too specific; there is more than one way to skin a cat.  why do we need to define replication in terms of participating rules?}
%means that all replicas eventually have the same replicated state, for any nondeterministic choices of time.  In other words, every ultimate model has the symmetry property that the contents of any replicated predicate is equivalent at all the replicas.

%\begin{lemma}
%In general, proving constraint satisfiability for all EDBs is undecidable.
%\end{lemma}
%\begin{proof}
%Proved in~\cite{qs-datalog} for Datalog programs with IDB negation; any Datalog program has a corresponding \lang program consisting of the original rules converted into deductive \lang rules in the obvious way.
%\end{proof}

%\jmh{Why does lemma start with "In particular"?}
\begin{lemma}
%In particular, proving constraint satisfiability for the constraint listed in Definition~\label{def:ec} is undecidable.
It is undecidable for general \lang programs whether the constraint shown in Definition~\label{def:ec} is unsatisfiable.
\end{lemma}
\begin{proof}
Proof sketch: Assume two different 2CMs are modeled at two different replicas.  Deciding eventual consistency implies we can decide whether the two 2CMs accept the same input, which is undecidable.
\end{proof}
%\paa{not sure I get it.  We are asking if a program is EC wrt a particular set of known constraints (those that 
%axiomatize ``replication'').  this is not tantamount to inferring FDs -- but it is query satisfiability, right?}

%Adding {\em replication} \wrm{define} to a confluent program yields an eventually consistent program.  However, there are some eventually consistent programs that are not confluent.

%\begin{example}
%An eventually consistent program that is not confluent.
%
%\begin{Dedalus}
%p(X)@async <- p_edb(X);
%s(X) <- p(X), !s(_);
%r(#R, X) <- replica(R), s(X);
%\end{Dedalus}
%\end{example}

%The above program is eventually consistent under the integrity constraint \dedalus{fail() <- r(\_, X), r(\_, Y), X != Y;}, but it is not confluent: the second rule ensures that the contents of \dedalus{s} is the first \dedalus{p} fact to arrive.  Thus, the second rule induces multiple ultimate models if \dedalus{p\_edb} has more than one element.  However, all ultimate models satisfy the integrity constraint. \paa{not sure why this is interesting.  you are just saying hey, there's
%this nice property called confluence, and here's an arbitrary constraint, and note that the arbitrary constraint
%doesn't imply confluence.}

How can conservative checks and coordination help us enforce eventual consistency?  One way is to insert a \jmh{provably correct?} replication protocol into a \lang program.  Note that just as \jmh{awk} the coordination protocols we insert may be too conservative in waiting, the replication protocols we insert may conservatively send too many network messages.  


\begin{definition}
The {\em replication rule} for a predicate \dedalus{p}, where \dedalus{rep\_p} is a fresh predicate symbol not otherwise used in the program, is:
\begin{Dedalus}
rep_p(#R,\dbar{X})@async <- replica(R), p(\dbar{X});
\end{Dedalus}
\end{definition}

%\begin{definition}
%A program is {\em downstream confluent} with respect to a predicate \dedalus{p} if %\wrm{removing all rules and predicates yields a confluent program, and any EDB in the new %program that's above an async edge in the original program should be delivered by async} yields %a confluent program.
%\end{definition} 
%\jmh{The above makes no sense to me.}

Consider a \lang program $d$ with a replicated predicate \dedalus{p}, and a subprogram
$d'$ obtained by removing from $d$ all rules upon which \dedalus{p} transitively 
depends, and adding a single async rule with \dedalus{p} in the head, in the form:

\begin{Dedalus}
p(\dbar{X})@async <- p_edb(\dbar{X});
\end{Dedalus}

If $d'$ is confluent, we say that $d$ is {\em downstream confluent} with respect to 
\dedalus{p}.

We can instrument an arbitrary \lang program to enable eventual consistency by inserting a replication rule for all predicates \dedalus{p}, provided that the program is downstream
confluent for all such \dedalus{p}.

We must then rewrite the program above \dedalus{p} to 
%wherever \dedalus{p} was required. \jmh{something about rhs's} 
replace any references to \dedalus{p} in rule subogals to \dedalus{rep\_p}.
%It must also be the case that the program above \dedalus{p} is confluent (of course this does 
%not imply the program as a whole is confluent).  \jmh{above?  huh?}  
We require confluence in order to ensure determinism at each replica.  We disallow recursion through replication.  If these conditions are met, the program is eventually consistent.  Note that this definition is flexible enough to admit any scheme where clients are updating and querying replicas.  \jmh{I assume the preceding para will be rewritten.}

\wrm{examples?}
\wrm{define downstream confluence}

\begin{theorem}
If a program $P$ is rewritten with replication using the above procedure, it is eventually consistent.
\end{theorem}
\begin{proof}
Sketch: it is easy to verify that \dedalus{rep\_p} is correctly replicated for all replicated predicates \dedalus{p}; thus eventual consistency constraints are satisfied.
\end{proof}
