\section{Correctness Criteria}

We introduce two correctness criteria for distributed systems: eventual consistency and confluence.

\subsection{Confluence}

{\em Confluence} means that there is a unique ultimate model.

When does a \lang program have a unique ultimate model?  While it is the presence of choice or asynchrony that causes multiple stable models, these multiple stable models sometimes give rise to a unique ultimate model.

\subsection{Eventual Consistency}

{\em Eventual consistency} means that all replicas eventually have the same replicated state, for any non-deterministic choices of time.  In other words, every ultimate model has the symmetry property that the contents of any replicated predicate is equivalent at all the replicas.  This is equivalent to the definition in (cite Peter's paper about EC).  Vogels' presented several operational definitions of eventual consistency \wrm{which are basically totally different, do we include here or not?  to discuss tomorrow}

\subsection{Space-Time Duality}

\wrm{discuss this more tomorrow}

%Eventual consistency and confluence are duals.
%Every eventually consistent program P has a confluent dual P', and every confluent program P' has an eventually consistent dual P.  Roughly, the transform is as follows.  We take our program, and have it only performs one node of the replication (nondeterministically commits to a node via committed choice???), and convert nondeterministic choice into replication (only a finite number of meaningful interleavings of messages -- how do we discover???), then this program is confluent iff the original program is E.C.


\begin{lemma}
Confluence of a \lang program is undecidable.
\end{lemma}
\begin{proof}
Our proof proceeds via construction of a two counter machine in \lang, inspired by the construction in \wrm{cite Levy} used to show that query satisfiability for Datalog with recursion and stratified negation is undecidable.  The construction is as follows:

The following relations are part of the program:
\dedalus{cnfg(S,C1,C2)}: Configurations of the machine, where \dedalus{S} is the state, and \dedalus{C1} and \dedalus{C2} are the values of the two counters.
\dedalus{fin\_succ(X,Y)}; A finite prefix of the successor relation, which is used for addition and subtraction of the counter values.

\wrm{fill in more code here}

The two counter machine performs committed choice after each transition to decide whether to halt in its current state or keep going.  The idea is that confluence is a property over all inputs to the two counter machine, and all choices of time.  So if, for some prefix of the infinite successor order, the two counter machine's early halting makes a difference in acceptance/rejectance only if the TM does not accept the empty language.  Therefore, if we can declare this program confluent, we have decided whether a 2cm accepts the empty language (which is a known undecidable problem). 

\end{proof}

%\begin{corollary}
%Eventual consistency of a \lang program is undeicdable.
%\end{corollary}
%\wrm{We need a bit more work in defining the spacetime duality to see if that's fully general.  If so, then there's a bijection between \lang programs defined by this duality, and the corollary will hold I think.}

The undecidability of the fully general cases leads us to consider subsets of the language, and conservative checks on the fully general class of programs (ala stratification).

\subsection{More Conservative Conditions}

Since \lang forces locality in time, the only source of non-determinism is non-determinism in co-occurence of truth of predicates.  This intuition implies a very natural conservative and statically checkable condition: force everything to eventually co-occur, and prevent observation of states where things have not yet co-occured.  The first property is asured by persisting all async messages.  The second is assured by ensuring that the EDB is related {\em monotonically} with the ultimate model.

\begin{definition}
If a {\em monotonic property} is true at time \dedalus{T}, then it is true at any time \dedalus{S > T}.
\end{definition}

An example of a monotonic property would be a persistent fact, or the negation of a fact that is never true.  Intuitively, a monotonic property represents some knowledge that never becomes untrue as we learn more knowledge.

\begin{definition}
A \lang program is {\em monotonic} if for all facts in the ultimate model, the element of the trace corresponding to the first time the fact was true before being henceforth true was computed by only monotonic properties. \wrm{may need some slight tweaking}
\end{definition}

\begin{example}
Example of a logically monotonic Dedalus program:\\
\begin{Dedalus}
node(X)@next <- node(X);
resposne(X)@next <- response(X);
all_responded() <- !not_responded(_);
not_responded(X) <- node(X), !response(X);
all_responded()@next <- all_responded();
\end{Dedalus}
\end{example}

The above program is monotonic. There is only one possible nonempty ultimate model, which contains \dedalus{all\_responded()}, and this fact is implied by a predicate \dedalus{!not\_responded(\_)}, which is monotonic because it is {\em r-positive} \wrm{cite Immerman} (i.e. the negation depth is even).  Note that the program is also confluent, because for any EDB, there is a unique ultimate model: either every node has an associated response, leading to a model with \dedalus{all\_responded()}, or there exists some node without an associated response, leading to an empty ultimate model.

We will see that all logically monotonic programs are confluent.  However, there are some non-logically-monotonic programs that are also confluent.

\begin{lemma}
A monotonic property must be true in all traces of a program, given an EDB.
\end{lemma}
\begin{proof}
Proof sketch: assume a monotonic property is true in one trace and false in another trace.  This means the monotonic property can differentiate between the two traces.  But since all async facts are persisted, all messages eventually rendezvous.  Thus, the monotonic property must be able to observe the condition that some event has not yet occured (but will eventually occur).  Monotonic properties cannot observe this though, becuase the property will be eventually untrue (when the thing that has not yet occured eventually occurs), thus it is not monotonic.
\end{proof}

\begin{corollary}
Logical monotonicity is a sufficient condition for confluence.
\end{corollary}
\begin{proof}
Proof sketch: if the ultimate model is populated only by monotonic properties, which are true in all traces, then there is a unique ultimate model.
\end{proof}

We now show that logical monotonicity is not necessary for confluence:

\begin{example}
Example of a confluent Dedalus program that is not logically monotonic:\\
\begin{Dedalus}
//client
b(#s,I)@async :- b_edb(I);

//server
b(N,I)@next <- b(N,I), !dequeued(I);
b_lt(i,j) <- b(_,i), b(_,j), i < j;
dequeued(i)@next <- b(_,i), !b_lt(_,i);
odd()@next <- odd(), !dequeued(_);
odd()@next <- dequeued(), even();
even() <- !odd();
\end{Dedalus}
\end{example}

The ultimate model contains \dedalus{odd()} if there are an odd number of \dedalus{b\_edb(I)} facts, and \dedalus{even()} otherwise.  Thus it is confluent.  However, the program is not logically monotonic because neither \dedalus{dequeued()} nor \dedalus{!dequeued()} are monotonic, so \dedalus{even()} is not supported by only monotonic properties, thus the program is not logically monotonic.

\wrm{Example of a Dedalus program that is nonconfluent (and thus not logically monotonic)}

\wrm{Making that program both monotonic and confluent via the addition of coordination}

\wrm{Logical monotonicity is undecidable?  Maybe a reduction from query satisfiability or something?}

