\section{Correctness Criteria}

We introduce two correctness criteria for distributed systems: eventual consistency and confluence.

\subsection{Confluence}

{\em Confluence} means that there is a unique ultimate model.

When does a \lang program have a unique ultimate model?  While it is the presence of choice or asynchrony that causes multiple stable models, these multiple stable models sometimes give rise to a unique ultimate model.

\wrm{Want to say something about a fully general (incl. recursion thru negation) model-theoretic condition for confluence.  Either say ``this is hard'', and provide some intuition or a proof that it reduces to some well known hard problem, or come up with such a condition.}

\subsection{Eventual Consistency}

{\em Eventual consistency} means that all replicas eventually have the same replicated state, for any non-deterministic choices of time.  In other words, every ultimate model has the symmetry property that the contents of any replicated predicate is equivalent at all the replicas.  This is equivalent to the definition in (cite Peter's paper about EC).  Vogels' presented several operational definitions of eventual consistency which we contrast below:

(Todo)

Eventual consistency and confluence are duals in the following sense.  Every eventually consistent program P has a confluent dual P', and every confluent program P' has an eventually consistent dual P.  Roughly, the transform is as follows.  We take our program, and have it only performs one node of the replication (nondeterministically commits to a node via committed choice???), and convert nondeterministic choice into replication (only a finite number of meaningful interleavings of messages -- how do we discover???), then this program is confluent iff the original program is E.C.


\begin{lemma}
Confluence of a \lang program is undecidable.
\end{lemma}
\begin{proof}
Our proof proceeds via construction of a Turing Machine in \lang, similar to the construction in \wrm{cite Levy}.  \wrm{We provide a review here so people don't have to go look at that other paper.} The Turing Machine performs committed choice after each transition to decide whether to halt in its current state or keep going.  The idea is that confluence is a property over all inputs to the Turing Machine, and all choices of time.  So if, for some prefix of the infinite successor order, the Turing Machine's early halting makes a difference in acceptance/rejectance only if the TM does not accept the empty language.  Therefore, if we can declare this program confluent, we have decided whether a TM accepts the empty language (which is a known undecidable problem).
\wrm{expand this with actual code when i feel like it}
\end{proof}

\begin{corollary}
Eventual consistency of a \lang program is undeicdable.
\end{corollary}
\wrm{We need a bit more work in defining the spacetime duality to see if that's fully general.  If so, then there's a bijection between \lang programs defined by this duality, and the corollary will hold I think.}

The undecidability of the fully general cases leads us to consider the following interesting cases:

\wrm{Conservative checks on the fully general class of programs, ala stratification}
\wrm{Sound and complete checks on a subset of the language (\lang without recursion thru negation) -- note that the Turing Machine construction uses recursion thru negation for committed choice.}
