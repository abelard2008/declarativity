\section{Correctness Criteria}

We introduce two correctness criteria for distributed systems: eventual consistency and confluence.

\subsection{Confluence}

{\em Confluence} means that there is a unique ultimate model.

When does a \lang program have a unique ultimate model?  While it is the presence of choice or asynchrony that causes multiple stable models, these multiple stable models sometimes give rise to a unique ultimate model.

\subsection{Eventual Consistency}

{\em Eventual consistency} means that all replicas eventually have the same replicated state, for any non-deterministic choices of time.  In other words, every ultimate model has the symmetry property that the contents of any replicated predicate is equivalent at all the replicas.  This is equivalent to the definition in (cite Peter's paper about EC).  Vogels' presented several operational definitions of eventual consistency \wrm{which are basically totally different, do we include here or not?  to discuss tomorrow}

%\subsection{Space-Time Duality}

\wrm{discuss the space-time duality more tomorrow}

%Eventual consistency and confluence are duals.
%Every eventually consistent program P has a confluent dual P', and every confluent program P' has an eventually consistent dual P.  Roughly, the transform is as follows.  We take our program, and have it only performs one node of the replication (nondeterministically commits to a node via committed choice???), and convert nondeterministic choice into replication (only a finite number of meaningful interleavings of messages -- how do we discover???), then this program is confluent iff the original program is E.C.

\begin{lemma}
Confluence of a \lang program is undecidable.
\end{lemma}
\begin{proof}
Our proof proceeds via construction of a two counter machine in \lang, inspired by the construction in \wrm{cite Undecidable Optimization Problems for Database Logic programs}.  We briefly review two counter machines.  A two counter machine's state is captured in the state of its two counters (natural numbers), and in its control state.  A two counter machine has a transition function, which can be characterized as follows:

$$\delta: \Sigma \times \{=, >\} \times \{=, >\} \rightarrow \Sigma \times \{inc, dec\} \times \{inc, dec\}$$

$\Sigma$ is a finite set of states (for simplicity we assume a finite subset of the natural numbers), $=$ indicates a counter is equal to zero, and $>$ indicates a counter is greater than zero.  $inc$ and $dec$ indicate that a counter should be incremented, or decremented respectively.

We represent the state of a two counter machine using the \dedalus{cnfg(T,S,C1,C2)} relation, where \dedalus{T} represents ``time'' (note this is not the same as the timestamp attribute), \dedalus{S} is the state (in $\Sigma$), and \dedalus{C1} and \dedalus{C2} are the values of the two counters.  In order to support $inc$ and $dec$, we would like to make use of the \dedalus{succ} relation.  However, \lang conventions forbid the use of this infinite relation outside of the timestamp attribute.  Thus, we posit the \dedalus{fin\_succ(X,Y)} EDB relation, which represents a finite prefix of the successor relation.  Since it is EDB, its contents may be arbitrary.  If \dedalus{fin\_succ} is malformed, then the machine's execution may be incorrect.  In particular, our model of the machine may accept an input, whereas the actual machine would not have accepted that input.  We illustrate how to constrain the contents of \dedalus{fin\_succ} below:

\begin{Dedalus}
malformed() <- fin_succ(_,0);
malformed() <- fin_succ(X,Y), fin_succ(X,Z), Y != Z;
malformed() <- fin_succ(Y,X), fin_succ(Z,X), Y != Z;
malformed() <- fin_succ(X,Y), X >= Y;
\end{Dedalus}

For a given EDB, the two counter machine either halts in the accepting state or halts in a non-accepting state.  It cannot run forever since the EDB (in particular, the \dedalus{fin\_succ} relation) is finite.

We construct a \lang program that nondeterministically decides to either run the machine on the input provided (and for the length of \dedalus{fin\_succ} provided, or declare that the machine will never accept without running it.  If the machine ever accepts some input, then we would like this to induce two different ultimate models -- one generated by a trace where we run the machine and it accepts, and one generated by a trace where we decide to not run the machine, and thus we implicitly reject.  We describe the program below.

Initially, we nondeterministically decide whether to run the machine or not, by sending two messages (0 and 1) to a remote node (\dedalus{decider}).  If both message arrive simultaneously, then the decider responds to run the machine.  Otherwise, the decider responds to declare failure:

\begin{Dedalus}
//send two messages to the decider
message(#decider, 0)@async. 
message(#decider, 1)@async.

//decider responds to computer
run_machine(#computer)@async <- message(_, 0), message(_, 1);
declare_failure(#computer)@async <- message(_, 0), !message(_, 1);
declare_failure(#computer)@async <- !message(_, 0), message(_, 1);
\end{Dedalus}

Each mapping in the transition function is expressed by a \lang rule with \dedalus{!malformed()} and \dedalus{!declare\_failure()} in its body.  For example, the rule $\delta(3, > =) = (7, inc, dec)$ would be represented as:

\begin{Dedalus}
cnfg(S,7,D1,D2) <- cnfg(T,3,C1,C2), C1 > 0, C2 == 0, fin_suc(T, S), fin_succ(C1, D1), fin_succ(D2, C2), !malformed(), !declare_failure();
\end{Dedalus}

We declare success or failure as follows:

\begin{Dedalus}
reject() <- !accept();
accept() <- cnfg(20,_,_); //assuming 20 is the accepting state
accept()@next <- accept();
\end{Dedalus}

If we choose to declare failure, or the machine halts in a non-accepting state, whether it is due to incompleteness or malformedness \dedalus{fin\_succ}, or actual halting, then the ultimate model will contain \dedalus{reject}.  If the machine halts in an accepting state, then the ultimate model will contain \dedalus{accept}.  Thus, if we can decide confluence of this program, then we can decide whether a two-counter machine halts on any input \wrm{undecidable for TMs, dunno about 2CMs, but I highly suspect so.  If need be, we can change this 2CM to a TM}.
\end{proof}

%\begin{corollary}
%Eventual consistency of a \lang program is undeicdable.
%\end{corollary}
%\wrm{We need a bit more work in defining the spacetime duality to see if that's fully general.  If so, then there's a bijection between \lang programs defined by this duality, and the corollary will hold I think.}

The undecidability of the fully general cases leads us to consider conservative checks on the fully general class of programs.  One promising avenue is stratification analyses from logic programming.

\subsection{More Conservative Conditions}

Since \lang forces locality in time, the only source of non-determinism is non-determinism in co-occurence of truth of predicates.  This intuition implies a very natural conservative and statically checkable condition: force everything to eventually co-occur, and prevent observation of states where things have not yet co-occured.  The first property is asured by persisting all async messages.  The second is assured by ensuring that the EDB is related {\em monotonically} with the ultimate model.

\begin{definition}
If a {\em monotonic property} is true at time \dedalus{T}, then it is true at any time \dedalus{S > T}.
\end{definition}

An example of a monotonic property would be a persistent fact, or the negation of a fact that is never true.  Intuitively, a monotonic property represents some knowledge that never becomes untrue as we learn more knowledge.

\begin{definition}
A \lang program is {\em monotonic} if for all facts in the ultimate model, the element of the trace corresponding to the first time the fact was true before being henceforth true was computed by only monotonic properties. \wrm{may need some slight tweaking}
\end{definition}

\begin{example}
Example of a logically monotonic Dedalus program:\\
\begin{Dedalus}
node(X)@next <- node(X);
resposne(X)@next <- response(X);
all_responded() <- !not_responded(_);
not_responded(X) <- node(X), !response(X);
all_responded()@next <- all_responded();
\end{Dedalus}
\end{example}

The above program is monotonic. There is only one possible nonempty ultimate model, which contains \dedalus{all\_responded()}, and this fact is implied by a predicate \dedalus{!not\_responded(\_)}, which is monotonic because it is {\em r-positive} \wrm{cite Immerman} (i.e. the negation depth is even).  Note that the program is also confluent, because for any EDB, there is a unique ultimate model: either every node has an associated response, leading to a model with \dedalus{all\_responded()}, or there exists some node without an associated response, leading to an empty ultimate model.

We will see that all logically monotonic programs are confluent.  However, there are some non-logically-monotonic programs that are also confluent.

\begin{lemma}
A monotonic property must be true in all traces of a program, given an EDB.
\end{lemma}
\begin{proof}
Proof sketch: assume a monotonic property is true in one trace and false in another trace.  This means the monotonic property can differentiate between the two traces.  But since all async facts are persisted, all messages eventually rendezvous.  Thus, the monotonic property must be able to observe the condition that some event has not yet occured (but will eventually occur).  Monotonic properties cannot observe this though, becuase the property will be eventually untrue (when the thing that has not yet occured eventually occurs), thus it is not monotonic.
\end{proof}

\begin{corollary}
Logical monotonicity is a sufficient condition for confluence.
\end{corollary}
\begin{proof}
Proof sketch: if the ultimate model is populated only by monotonic properties, which are true in all traces, then there is a unique ultimate model.
\end{proof}

We now show that logical monotonicity is not necessary for confluence:

\begin{example}
Example of a confluent Dedalus program that is not logically monotonic:\\
\begin{Dedalus}
//client
b(#s,I)@async :- b_edb(I);

//server
b(N,I)@next <- b(N,I), !dequeued(I);
b_lt(i,j) <- b(_,i), b(_,j), i < j;
dequeued(i)@next <- b(_,i), !b_lt(_,i);
odd()@next <- odd(), !dequeued(_);
odd()@next <- dequeued(), even();
even() <- !odd();
\end{Dedalus}
\end{example}

The ultimate model contains \dedalus{odd()} if there are an odd number of \dedalus{b\_edb(I)} facts, and \dedalus{even()} otherwise.  Thus it is confluent.  However, the program is not logically monotonic because neither \dedalus{dequeued()} nor \dedalus{!dequeued()} are monotonic, so \dedalus{even()} is not supported by only monotonic properties, thus the program is not logically monotonic.

\wrm{Example of a Dedalus program that is nonconfluent (and thus not logically monotonic)}

\wrm{Making that program both monotonic and confluent via the addition of coordination}

\wrm{Logical monotonicity is undecidable?  Maybe a reduction from query satisfiability or something?}

