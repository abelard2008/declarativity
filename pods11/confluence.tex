\section{Confluence}

For many distributed computations, achieving a deterministic answer (ultimate model) independent of any network nondeterminism is desirable.

\begin{definition}
A \lang program is {\em confluent} if, for any EDB, it has a unique ultimate model.
\end{definition}

Datalog programs without negation are trivially confluent, as they are certain to have
only one stable model.  The same is true of both negation-free and temporally stratified \lang programs that do not use the  {\em choice} construct.  Cast in operational terms this is
unsurprising: programs with no sources of nondeterminism have deterministic executions.

Any \lang programs that use {\em async} rules have an infinite 
number of stable models, but as we will see, in many cases these correspond to a
unique ultimate model.
In general, however, \lang programs are not necessarily confluent even in the absence of negation.

\begin{example}
\label{ex:nonconfluent}
A non-confluent \lang program.

\begin{Dedalus}
p(x)@async <- p_edb(X);
q(X)@next <- p(X), !q(_);
q(X)@next <- q(X);
\end{Dedalus}
\end{example}

In the above program, assume the EDB contains facts \dedalus{p\_edb(1)} and \dedalus{p\_edb(2)}.  If the non-deterministic choice of \dedalus{async} chooses an earlier timestamp for \dedalus{p(1)} than \dedalus{p(2)}, then the ultimate model will consist of the single fact \dedalus{q(1)}.  Similarly, if \dedalus{p(2)} is assigned an earlier timestamp than \dedalus{p(1)}, then the ultimate model will consist of the single fact \dedalus{q(2)}.  If \dedalus{p(1)} and \dedalus{p(2)} are asigned the same timestamp, then the ultimate model will consist of the two facts \dedalus{q(1)} and \dedalus{q(2)}.  Since the program does not have a unique ultimate model for this EDB, it is non-confluent.

Unfortunately, confluence is undecidable for \lang programs, as the following Lemma shows.

\begin{lemma}
\label{lem:confluence-undecidable}
Confluence of a \lang program is undecidable.
\end{lemma}
\begin{proof}
We reduce the undecidable problem of determining whether a two-counter machine accepts any input to confluence of a \lang program.  See appendix for details.
\end{proof}

Fortunately, as we will show, there is a rich class of programs that can be statically detected as confluent.  Furthermore, many other programs have a ``natural'' ultimate model that corresponds to intuition; we show how to induce this ultimate model by augmenting the program.

\subsection{Sources of difluence}

First, we provide some intuition for the sources of difluence in \lang programs.  In Example~\ref{ex:nonconfluent}, we saw a \lang program that was difluent because the ultimate model consisted of the first batch of messages in the \dedalus{p} predicate.

\begin{example}
\label{ex:nonconfluent2}
A \lang program in which difluence is caused by negating an incomplete set.

\begin{Dedalus}
q(X)@async <- q_edb(X);
r(X)@async <- r_edb(X);
p(X) <- q(X), !r(X);
p(X)@next <- p(X);
\end{Dedalus}
\end{example}

The above example is difluent because if an \dedalus{r} fact is assigned an earlier timestamp than its corresponding \dedalus{q} fact, the ultimate model contains no corresponding \dedalus{p} fact; otherwise, the ultimate model contains the \dedalus{p} fact.
In operational terms, \dedalus{r} and \dedalus{q} do not commute.

\begin{example}
A difluent \lang program without negation.

\begin{Dedalus}
q(X)@async <- q_edb(X);
r(X)@async <- r_edb(X);
p(X) <- q(X), r(X);
p(X)@next <- p(X);
\end{Dedalus}
\end{example}

The above example illustrates that even without negation, a \lang program may induce multiple ultimate models.

\begin{definition}
A \lang program is {\em negation-free} if the \dedalus{!} symbol does not appear in the program.
\end{definition}

\begin{definition}
A \lang program has {\em guarded asynchrony} if all \dedalus{async} predicates are persisted.
\end{definition}

\begin{lemma}
\label{lem:guarding}
A negation-free \lang program with guarded asynchrony is confluent.
\end{lemma}
\begin{proof}
Sketch: only possible way two ultimate models are different is if two facts (or predicates, e.g. ``!'' on facts) join in one trace, but not the other.  If the program has guarded asynchrony, then it is impossible for a join to succeed in one trace and not another.


\paa{a great windy attempt at proof}
Towards a proof by contradiction, consider a negation-free \lang program that 
induces more than one ultimate model.  There must be a ground atom $a$ for a predicate $p$
that is true in one but
not in another model, and $p$ must be persistent, or it would not be
in the ultimate model.  Consider a derivation of $a$: a finite tree of applications of
implication whose leaves are EDB atoms.  If none of the implications involve a nondeterministic
choice of timestamp via an {\em async} rule, then certainly there is only one stable model of the
program, so there must be at least one {\em async} rule.  If $p$ is derived directly from 
an {\em async} rule via a series of derivation steps without any joins, then every stable
model will have an identical tuple in $p$, modulo time, and hence the same ultimate model.
Therefore, $a$ must have at least one join in its derivation following an {\em async} rule,
which suceeded in this stable model but did not succeed in another.  Guarded joins always
eventually succeed, and by assumption, every {\em async}-derived predicate is guarded.
Hence $a$ must exist in all ultimate models.

\end{proof}


If either qualification is false, problems can result, as we have previously illustrated.


\subsection{Monotonic Properties}

We can generalize Lemma~\ref{lem:guarding} by the notion of a {\em monotonic property}.

\begin{definition}
If a {\em monotonic property} is true at time \dedalus{T}, then it is true at any time \dedalus{S > T}.
\end{definition}

An example of a monotonic property would be a persistent fact, or the negation of a fact that is never true.  Intuitively, a monotonic property represents some knowledge that never becomes untrue as we learn more knowledge.

\begin{definition}
A \lang program is {\em monotonic} if for all facts in any ultimate model, the element of the trace corresponding to the first time the fact was true before being henceforth true was computed by only monotonic properties. \wrm{may need some slight tweaking}
\end{definition}

\begin{example}
Example of a logically monotonic Dedalus program:\\
\begin{Dedalus}
node(X)@next <- node(X);
response(X)@next <- response(X);
all_responded() <- !not_responded(_);
not_responded(X) <- node(X), !response(X);
all_responded()@next <- all_responded();
\end{Dedalus}
\end{example}

The above program is monotonic. There is only one possible nonempty ultimate model, which contains \dedalus{all\_responded()}, and this fact is implied by a predicate \dedalus{!not\_responded(\_)}, which is monotonic because it is {\em positive} (i.e. the negation depth is even).  \paa{this suggests that we can test if programs are monotonic, though everything up till now has been an attempt to define montonicity semantically...} Note that the program is also confluent, because for any EDB, there is a unique ultimate model: either every node has an associated response, leading to a model with \dedalus{all\_responded()}, or there exists some node without an associated response, leading to an empty ultimate model.

We will see that all logically monotonic programs are confluent.  However, some programs that are not logically monotonic are confluent.

\begin{lemma}
If a monotonic property is true in any trace of a program, given an EDB, it is true in all traces.
\end{lemma}
\begin{proof}
Proof sketch: assume a monotonic property is true in one trace and false in another trace.  This means the monotonic property can differentiate between the two traces.  But since all async facts are persisted, all messages eventually rendezvous.  Thus, the monotonic property must be able to observe the condition that some event has not yet occured (but will eventually occur).  Monotonic properties cannot observe this though, becuase the property will be eventually untrue (when the thing that has not yet occured eventually occurs), thus it is not monotonic.
\end{proof}

\begin{corollary}
Logical monotonicity is a sufficient condition for confluence.
\end{corollary}
\begin{proof}
Proof sketch: If a particular ultimate model is populated by atoms that depend only on monotonic properties, then those atoms occur in any ultimate model of the program.  If all ultimate models
are populated in such a way, they are indeed all the same, unique ultimate model.
%which are true in all traces, then there is a unique ultimate model.

\end{proof}

We now show that logical monotonicity is not necessary for confluence:

\begin{example}
A confluent Dedalus program that is not logically monotonic.

\begin{Dedalus}
//client
b(#s,I)@async :- b_edb(I);

//server
b(N,I)@next <- b(N,I), !dequeued(I);
b_lt(i,j) <- b(_,i), b(_,j), i < j;
dequeued(i)@next <- b(_,i), !b_lt(_,i);
odd()@next <- odd(), !dequeued(_);
odd()@next <- dequeued(), even();
even() <- !odd();
\end{Dedalus}
\wrm{or, just consider the 2 counter machine...?}
\end{example}

The ultimate model contains \dedalus{odd()} if there are an odd number of \dedalus{b\_edb(I)} facts, and \dedalus{even()} otherwise.  Thus it is confluent.  However, the program is not logically monotonic because neither \dedalus{dequeued()} nor \dedalus{!dequeued()} are monotonic, so \dedalus{even()} is not supported by only monotonic properties, thus the program is not logically monotonic.

\subsection{Perfect Ultimate Model}
Programs that are not confluent often have a single ``natural'' ultimate model that corresponds to intuition, similarly to the way that Datalog programs with negation have a model called the {\em perfect model} which corresponds to intuition.  For various uses of negation, we will define a {\em perfect ultimate model}, and present a rewrite technique that adds {\em coordination} to a \lang program to convert it into a confluent \lang program that computes the {\em perfect ultimate model} (which is one of the original program's ultiamte models).

Consider the following example, which is analogous to example~\ref{ex:nonconfluent2} above:

\begin{example}
\label{ex:sayers}
A non-confluent \lang program.

\begin{Dedalus}
//sayer
statement(#L, S, X)@async <- statement_edb(#S, X),
                             listener(L);
s_false(#L, S, X)@async <- statement_edb(#S, X),
                           false_edb(#S, X),
                           listener(L);

//listener
true(X) <- statement(_, S, X), !s_false(_, S, X);
false(X) <- statement(_, S, X), s_false(_, S, X);
statement(L, S, X)@next <- statement(L, S, X);
s_false(L, S, X)@next <- s_false(L, S, X);
true(X)@next <- true(X);
\end{Dedalus}
\end{example}

Intuitively this program represents a group of nodes (the ``sayers'') making statements to another group of nodes called ``listeners''.  The sayers also occasionally remark that a statement is false (but a sayer may only declare one of his statements to be false -- not the statement of another sayer).  One may expect the contents of \dedalus{true} to contain all statements that are not \dedalus{false}.  However, this is not necessarily the case.  Recall that the un-sugared version of the third rule is:

\begin{Dedalus}
true(X,T) <- statement(X,T), !false(X,T);
\end{Dedalus}

Thus, the contents of \dedalus{true} at time \dedalus{T} is those items in \dedalus{statement} at time \dedalus{T} that are not in \dedalus{false} at time \dedalus{T}.  So in fact, the contents of \dedalus{true} in the ultimate model is ``everything stated that was ever not false''.  Such counter-intuitive results are enabled because the closed-world assumption is being applied to incomplete sets.

\begin{definition}
The {\em temporal flattening} of a \lang program is the original program with all inductive and asynchronous rules made atemporal.
\end{definition}

Note that the temporal flattening of a \lang program is a Datalog program.

\begin{definition}
The {\em perfect ultimate model} of a \lang program whose temporal flattening is syntactically stratified is the ultimate model induced by ensuring that for every predicate that appears negated in the program, all facts in that predicate are known before the negation is applied.  In other words, one must have ``complete information'' before applying the closed-world assumption for negation.  This intuitively corresponds to the notion of stratified evaluation for Datalog programs, where a fixpoint is computed for each stratum in stratum order.
%\wrm{make more formal}  \paa{this is an incomplete definition, right?  we are also interested in
%programs which when temporally flattened are not syntactically stratifiable, yet have a single ultimate model 
%corresponding to their ``coordinated'' evaluation(s)}
\end{definition}

\begin{definition}
The {\em perfect ultimate model} of a \lang program whose temporal flattening is universally constraint stratified~\cite{ross-ucs} is the ultimate model induced by ensuring that for every predicate that appears negated in the program subsets are completed in the partial order associated with the stratification.
\end{definition}

There is always a stable model representing the perfect ultimate model of a \lang program whose flattening is syntactically stratified, because there is no recursion through negation, and Lemma~\ref{cron} tells us that any choice of timestamps is permissible in this case.

In Example~\ref{ex:sayers}, the perfect ultimate model is represented by any stable model where no \dedalus{false} message arrives after a \dedalus{statement} message with the same value.  In particular, we can modify the program to be confluent with the perfect ultimate model by ensuring that negation is not applied until the \dedalus{false} set is complete.  It turns out we can generalize this into an algorithm for all \lang programs whose temporal flattening is syntactically stratified.

We add the following two rules to compute counts of false messages at each sayer, and each listener:

\begin{Dedalus}
count_false_sent(#L, S, count<X>) <- false_edb(S, X),
                                     listener(L);
count_false_recv(S, count<X>) <- s_false(_, S, X);
\end{Dedalus}

Furthermore, we replace the rule above that defines \dedalus{true} with the one below:

\begin{Dedalus}
true(X) <- statement(_, S, X), !s_false(_, S, X),
           count_false_recv(S, X),
           count_false_sent(_, S, X);
\end{Dedalus}

Now, independent of the assignment of timestamps, no statement from a sayer \dedalus{S} is considered to be true by any listener unless the listener has complete information about which statements are false (i.e., the counts match). 

\wrm{Note, however, that it's fine for the receiver count to have intermediate values, as these are not persisted.}
\wrm{Example that shows coordination across all nodes?}

\wrm{Talk about generalizing this test for universal constraint stratification}

\subsubsection{Coordination}
Given any \lang program without recursion through negation, we can automatically instrument it with coordination to achieve the ultimate model, using the following algorithm:

1. Build a predicate dependency graph of the program. \wrm{explain the PDG earlier}
2. Let \dedalus{p} be an asynchronous predicate, from which a negated or aggregated predicate is reachable above.
3. Consider all asynchronous rules with \dedalus{p} in the head.  Change the head predicate name to \dedalus{p\_local} where that is a fresh predicate name, and drop the \dedalus{\#} sign from the location specifier.
4. Add the following rules to the program, where \dedalus{p\_count\_send}, \dedalus{p\_count\_recv}, \dedalus{p\_incomplete}, \dedalus{p\_complete}, and \dedalus{p\_send} are fesh predicate names.

\noindent
\begin{Dedalus}
p_count_send(#Y,Src,count<*>)@async <- p_local(Y,\(\bar{X}\)),
                                       local(Src);
p_send(#Y,Src,\(\bar{X}\))@async <- p_local(Y,\(\bar{X}\)), local(Src);
p(Y,\(\bar{X}\)) <- p_send(Y,_,\(\bar{X}\));
p_count_recv(Src,count<*>) <- p_send(_,Src,\(\bar{X}\));
p_incomplete() <- node(Src), !p_count_recv(Src, _);
p_incomplete() <- node(Src), !p_count_send(_,Src,_);
p_incomplete() <- p_count_recv(Src, C1),
                  p_count_send(_, Src, C2), C1 < C2;
p_complete() <- !p_incomplete();
\end{Dedalus}
5. Add \dedalus{p\_complete()} to the body of any rule that applies negation to any predicate above \dedalus{p}.

Note that this process introduces additional asynchronous edges.  These asynchronous edges need not be coordinated \wrm{in fact, due to the syntactic restrictions in the foundation, they CAN'T be coordinated, becuase that would entail taking the count of a count}.


\subsubsection{Non-Deterministic Coordination}

Consider what happens when we admit transient and permanent failures of nodes and channels to the model.  It is now the case that nodes may forever wait for a message that will never arrive.  Thus, achieving the perfect ultimate model comes at the expense of liveness.  It may be desirable to accept that the message will never arrive, and proceed with the computation.

Example~\ref{ex:nonconfluent} models exactly this -- the first batch of \dedalus{p} facts are sealed in \dedalus{q}, and any further \dedalus{p} facts are ignored.  Any ingored \dedalus{p} facts correspond to ``lost'' \dedalus{p} facts, due to either transient or permanent channel or node failure.  It is easy to see that each possible ultimate model represents a possible failure scenario, and each combination of node and channel failures is represented, including the scenario with no failures~\footnote{In practical systems, we may want to model specific real-time constraints -- for example, we declare the set closed after a certain number of seconds have elapsed.  We can easily express this by adding the notion of a ``timer'' (a fact inserted into the queue at intervals measured on a wall clock) to our operational semantics.}.

We can instrument any \lang program without recursion through negation with non-deterministic coordination, using the following algorithm:

\wrm{expand sketch}
1. Build a predicate dependency graph of the program.
2. Let \dedalus{p} be an asynchronous predicate from which a negated or aggregated predicate is reachable above.
3. Consider all asynchronous rules with \dedalus{p} in the head.  Change the head predicate name to \dedalus{p\_send} where that is a fresh predicate name.
4. Insert the following rule
\begin{Dedalus}
p(\(\bar{X}\)) <- p_send(\(\bar{X}\)), !p(\(\bar{_}\));
\end{Dedalus}

We consider example~\ref{ex:sayers} above.  Some ultimate models do not correspond to plausible failure scenarios -- for example, any ultimate model where a \dedalus{statement} is both \dedalus{true} and \dedalus{false}.  The instrumented version of the example would add the following rule:

\begin{Dedalus}
c_false(L, S, X)@next <- s_false(L, S, X),
                         !c_false(_, _, _);
\end{Dedalus}

And would replace any instance of the predicate \dedalus{s\_false} in the ``listener'' rules with \dedalus{c\_false}.
