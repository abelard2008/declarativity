\section{Confluence}

For many distributed computations, achieving a deterministic answer (ultimate model) independent of any network nondeterminism is ideal.

\begin{definition}
A \lang program is {\em confluent} if, for any EDB, it has a unique ultimate model.
\end{definition}

In general, \lang programs are not necessarily confluent.

\begin{example}
\label{ex:nonconfluent}
A non-confluent \lang program.

\begin{Dedalus}
p(x)@async <- p_edb(X);
q(X)@next <- p(X), !q(_);
q(X)@next <- q(X);
\end{Dedalus}
\end{example}

In the above program, assume the EDB contains facts \dedalus{p\_edb(1)} and \dedalus{p\_edb(2)}.  If the non-deterministic choice of \dedalus{async} chooses an earlier timestamp for \dedalus{p(1)} than \dedalus{p(2)}, then the ultimate model will consist of the single fact \dedalus{q(1)}.  Similarly, if \dedalus{p(2)} is assigned an earlier timestamp than \dedalus{p(1)}, then the ultimate model will consist of the single fact \dedalus{q(2)}.  If \dedalus{p(1)} and \dedalus{p(2)} are asigned the same timestamp, then the ultimate model will consist of the two facts \dedalus{q(1)} and \dedalus{q(2)}.  Since the program does not have a unique ultimate model for this EDB, it is non-confluent.

Unfortunately, confluence is undecidable for \lang programs, as the following Lemma shows.

\begin{lemma}
\label{lem:confluence-undecidable}
Confluence of a \lang program is undecidable.
\end{lemma}
\begin{proof}
We reduce the undecidable problem of determining whether a two-counter machine accepts any input to confluence of a \lang program.  See appendix for details.
\end{proof}

Fortunately, as we show, there is a rich class of programs that can be statically detected as confluent.  Furthermore, many other programs have a ``natural'' ultimate model that corresponds to intuition; we show how to induce this ultimate model by augmenting the program.

First, we provide some intuition for the sources of non-confluence in \lang programs.  In Example~\ref{ex:nonconfluent}, we saw a \lang program that was non-confluent because the ultimate model consisted of the first batch of messages in the \dedalus{p} predicate.

\begin{example}
\label{ex:nonconfluent2}
Another non-confluent \lang program.

\begin{Dedalus}
q(X)@async <- q_edb(X);
r(X)@async <- r_edb(X);
p(X) <- q(X), !r(X);
p(X)@next <- p(X);
\end{Dedalus}
\end{example}

The above example is non-confluent becuase if an \dedalus{r} fact is assigned an earlier timestamp than its corresponding \dedalus{q} fact, the ultimate model contains no corresponding \dedalus{p} fact; otherwise, the ultimate model contains the \dedalus{p} fact.

\begin{example}
A non-confluent \lang program without negation.

\begin{Dedalus}
q(X)@async <- q_edb(X);
r(X)@async <- r_edb(X);
p(X) <- q(X), r(X);
p(X)@next <- p(X);
\end{Dedalus}
\end{example}

The above example illustrates that even without negation, multiple ultimate models may be induced.

\begin{definition}
A \lang program is {\em negation-free} if the \dedalus{!} symbol does not appear in the program.
\end{definition}

\begin{definition}
A \lang program has {\em guarded asynchrony} if all \dedalus{async} predicates are persisted.
\end{definition}

\begin{lemma}
A negation-free \lang program with guarded asynchrony is confluent.
\end{lemma}
\begin{proof}
Sketch: only possible way two ultimate models are different is if two facts (or predicates, e.g. ``!'' on facts) join in one trace, but not the other.  If the program has guarded asynchrony, then it is impossible for a join to succeed in one trace and not another.
\end{proof}

If either qualification is false, problems can result, as we have previously illustrated.


We can generalize the above example by the notion of a {\em monotonic property}.

\begin{definition}
If a {\em monotonic property} is true at time \dedalus{T}, then it is true at any time \dedalus{S > T}.
\end{definition}

An example of a monotonic property would be a persistent fact, or the negation of a fact that is never true.  Intuitively, a monotonic property represents some knowledge that never becomes untrue as we learn more knowledge.

\begin{definition}
A \lang program is {\em monotonic} if for all facts in any ultimate model, the element of the trace corresponding to the first time the fact was true before being henceforth true was computed by only monotonic properties. \wrm{may need some slight tweaking}
\end{definition}

\begin{example}
Example of a logically monotonic Dedalus program:\\
\begin{Dedalus}
node(X)@next <- node(X);
response(X)@next <- response(X);
all_responded() <- !not_responded(_);
not_responded(X) <- node(X), !response(X);
all_responded()@next <- all_responded();
\end{Dedalus}
\end{example}

The above program is monotonic. There is only one possible nonempty ultimate model, which contains \dedalus{all\_responded()}, and this fact is implied by a predicate \dedalus{!not\_responded(\_)}, which is monotonic because it is {\em positive} (i.e. the negation depth is even).  Note that the program is also confluent, because for any EDB, there is a unique ultimate model: either every node has an associated response, leading to a model with \dedalus{all\_responded()}, or there exists some node without an associated response, leading to an empty ultimate model.

We will see that all logically monotonic programs are confluent.  However, there are some non-logically-monotonic programs that are also confluent.

\begin{lemma}
A monotonic property must be true in all traces of a program, given an EDB.
\end{lemma}
\begin{proof}
Proof sketch: assume a monotonic property is true in one trace and false in another trace.  This means the monotonic property can differentiate between the two traces.  But since all async facts are persisted, all messages eventually rendezvous.  Thus, the monotonic property must be able to observe the condition that some event has not yet occured (but will eventually occur).  Monotonic properties cannot observe this though, becuase the property will be eventually untrue (when the thing that has not yet occured eventually occurs), thus it is not monotonic.
\end{proof}

\begin{corollary}
Logical monotonicity is a sufficient condition for confluence.
\end{corollary}
\begin{proof}
Proof sketch: if the ultimate model is populated only by monotonic properties, which are true in all traces, then there is a unique ultimate model.
\end{proof}

We now show that logical monotonicity is not necessary for confluence:

\begin{example}
A confluent Dedalus program that is not logically monotonic.

\begin{Dedalus}
//client
b(#s,I)@async :- b_edb(I);

//server
b(N,I)@next <- b(N,I), !dequeued(I);
b_lt(i,j) <- b(_,i), b(_,j), i < j;
dequeued(i)@next <- b(_,i), !b_lt(_,i);
odd()@next <- odd(), !dequeued(_);
odd()@next <- dequeued(), even();
even() <- !odd();
\end{Dedalus}
\wrm{or, just consider the 2 counter machine...?}
\end{example}

The ultimate model contains \dedalus{odd()} if there are an odd number of \dedalus{b\_edb(I)} facts, and \dedalus{even()} otherwise.  Thus it is confluent.  However, the program is not logically monotonic because neither \dedalus{dequeued()} nor \dedalus{!dequeued()} are monotonic, so \dedalus{even()} is not supported by only monotonic properties, thus the program is not logically monotonic.

\subsection{Perfect Ultimate Model}
Programs that are not confluent often have a single ``natural'' ultimate model that corresponds to intuition, similarly to the way that Datalog programs with negation have a model called the {\em perfect model} which corresponds to intuition.  For various uses of negation, we will define a {\em perfect ultimate model}, and present a rewrite technique that adds {\em coordination} to a \lang program to convert it into a confluent \lang program that computes the {\em perfect ultimate model} (which is one of the original program's ultiamte models).

Consider the following example, which is analogous to example~\ref{ex:nonconfluent2} above:

\begin{example}
\label{ex:sayers}
A non-confluent \lang program.

\begin{Dedalus}
//sayer
statement(#L, S, X)@async <- statement_edb(#S, X),
                             listener(L);
s_false(#L, S, X)@async <- statement_edb(#S, X),
                           false_edb(#S, X),
                           listener(L);

//listener
true(X) <- statement(_, S, X), !s_false(_, S, X);
false(X) <- statement(_, S, X), s_false(_, S, X);
statement(L, S, X)@next <- statement(L, S, X);
s_false(L, S, X)@next <- s_false(L, S, X);
true(X)@next <- true(X);
\end{Dedalus}
\end{example}

Intuitively this program represents a group of nodes (the ``sayers'') making statements to another group of nodes called ``listeners''.  The sayers also occasionally remark that a statement is false (but a sayer may only declare one of his statements to be false -- not the statement of another sayer).  One may expect the contents of \dedalus{true} to contain all statements that are not \dedalus{false}.  However, this is not necessarily the case.  Recall that the un-sugared version of the third rule is:

\begin{Dedalus}
true(X,T) <- statement(X,T), !false(X,T);
\end{Dedalus}

Thus, the contents of \dedalus{true} at time \dedalus{T} is those items in \dedalus{statement} at time \dedalus{T} that are not in \dedalus{false} at time \dedalus{T}.  So in fact, the contents of \dedalus{true} in the ultimate model is ``everything stated that was ever not false''.  Such counter-intuitive results are enabled because the closed-world assumption is being applied to incomplete sets.

\begin{definition}
The {\em deductive reduction} of a \lang program is the program with all inductive and asynchronous rules replaced with deductive rules.
\end{definition}

Note that the deductive reduction of a \lang program is a Datalog program.

\begin{definition}
The {\em perfect ultimate model} of a \lang program whose deductive reduction is syntactically stratified (i.e. the \lang program has no recursion through negation) is the ultimate model you get by ``ensuring that a set is completed before it is negated''. \wrm{make more formal}
\end{definition}

Clearly, the perfect ultimate model is one of the ultimate models -- in the above program, it is represented by any stable model where no \dedalus{false} message arrives after a \dedalus{statement} message with the same value.

In particular, it is represented by any stable model where no \dedalus{false} message arrives after the first \dedalus{statement} message has arrived.  We show an example of how this condition can be emulated by modifying the program.

We add the following two rules to compute counts of false messages at each sayer, and each listener:

\begin{Dedalus}
count_false_sent(#L, S, count<X>) <- false_edb(S, X),
                                     listener(L);
count_false_recv(S, count<X>) <- s_false(_, S, X);
\end{Dedalus}

Furthermore, we replace the rule above that defines \dedalus{true} with the one below:

\begin{Dedalus}
true(X) <- statement(_, S, X), !s_false(_, S, X),
           count_false_recv(S, X),
           count_false_sent(_, S, X);
\end{Dedalus}

Now, independent of the assignment of timestamps, no statement from a sayer \dedalus{S} is considered to be true by any listener unless the listener has complete information about which statements are false (i.e., the counts match). 

\wrm{Note, however, that it's fine for the receiver count to have intermediate values, as these are not persisted.}
\wrm{Example that shows coordination across all nodes?}

\wrm{Talk about generalizing this test for universal constraint stratification}

\subsubsection{Coordination}
Given any \lang program without recursion through negation, we can automatically instrument it with coordination to achieve the ultimate model, using the following algorithm:

\wrm{expand sketch -- break out algorithm environment?}
1. Build a predicate dependency graph of the program.
2. For any asynchronous edge that can reach a predicate with negation or aggregation, have each node send a count of messages in the async predicate, and coordinate over all nodes, as above.

Note that this process introduces additional asynchronous edges.  These asynchronous edges need not be coordinated \wrm{in fact, due to the syntactic restrictions in the foundation, they CAN'T be coordinated, becuase that would entail taking the count of a count}.


\subsubsection{Non-Deterministic Coordination}

Consider what happens when we admit transient and permanent failures of nodes and channels to the model.  It is now the case that nodes may forever wait for a message that will never arrive.  Thus, achieving the perfect ultimate model comes at the expense of liveness.  It may be desirable to accept that the message will never arrive, and proceed with the computation.

Example~\ref{ex:nonconfluent} models exactly this -- the first batch of \dedalus{p} facts are sealed in \dedalus{q}, and any further \dedalus{p} facts are ignored.  Any ingored \dedalus{p} facts correspond to ``lost'' \dedalus{p} facts, due to either transient or permanent channel or node failure.  It is easy to see that each possible ultimate model represents a possible failure scenario, and each combination of node and channel failures is represented, including the scenario with no failures~\footnote{In practical systems, we may want to model specific real-time constraints -- for example, we declare the set closed after a certain number of seconds have elapsed.  We can easily express this by adding the notion of a ``timer'' (a fact inserted into the queue at intervals measured on a wall clock) to our operational semantics.}.

We can instrument any \lang program without recursion through negation with non-deterministic coordination, using the following algorithm:

\wrm{expand sketch}
1. Build a predicate dependency graph of the program.
2. For any asynchronous edge that can reach a predicate with negation or aggregation, drop in the pattern of example~\ref{ex:nonconfluent}.

We consider example~\ref{ex:sayers} above.  Some ultimate models do not correspond to plausible failure scenarios -- for example, any ultimate model where a \dedalus{statement} is both \dedalus{true} and \dedalus{false}.  The instrumented version of the example would add the following rule:

\begin{Dedalus}
c_false(L, S, X)@next <- s_false(L, S, X),
                         !c_false(L, S, _);
\end{Dedalus}

And would replace any instance of the predicate \dedalus{s\_false} in the ``listener'' rules with \dedalus{c\_false}.


\wrm{connect with Paxos/2PC???}
