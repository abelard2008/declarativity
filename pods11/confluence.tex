\section{Confluence}

\begin{definition}
A \lang program is {\em confluent} if it has a unique ultimate model.
\end{definition}

\begin{lemma}
\label{lem:confluence-undecidable}
Confluence of a \lang program is undecidable.
\end{lemma}
\begin{proof}
See appendix.
\end{proof}

This undecidability result sets the stage for various conservative conditions to guarantee confluence.  Furthermore, we explain how some non-confluent programs have an ``intuitive'' or ``natural'' unique ultimate model that can be induced by augmenting the program with additional logic.

First, we explain the sources of non-confluence in \lang programs.

\begin{definition}
A \lang program is {\em negation-free} if the \dedalus{!} symbol does not appear in the program.
\end{definition}

\begin{definition}
A \lang program has {\em guarded asynchrony} if all \dedalus{async} predicates are persisted.
\end{definition}

\begin{lemma}
A negation-free \lang program with guarded asynchrony is confluent.
\end{lemma}
\begin{proof}
Sketch: only possible way two ultimate models are different is if two facts (or predicates, e.g. ``!'' on facts) join in one trace, but not the other.  If the program has guarded asynchrony, then it is impossible for a join to succeed in one trace and not another.
\end{proof}

If either qualification is false, problems can result, as illustrated in the following two examples.

\begin{example}
A non-confluent \lang program with negation and guarded asynchrony.

\begin{Dedalus}
q(X)@async <- q_edb(X);
r(X)@async <- r_edb(X);
p(X) <- q(X), !r(X);
p(X)@next <- p(X);
\end{Dedalus}
\end{example}

In the above example, if the timestamp of a \dedalus{q} fact is chosen later than the timestamp of its corresponding \dedalus{r} fact, then \dedalus{p} is in the ultimate model.  Otherwise, \dedalus{p} is not in the ultimate model.

\begin{example}
A non-confluent negation-free \lang program without guarded asynchrony.

\begin{Dedalus}
q(X)@async <- q_edb(X);
r(X)@async <- r_edb(X);
p(X) <- q(X), r(X);
p(X)@next <- p(X);
\end{Dedalus}
\end{example}

In the above example, if the timestamp of a \dedalus{q} fact is the same as the timestamp of its corresponding \dedalus{r} fact, then \dedalus{p} is in the ultimate model.  Otherwise \dedalus{p} is not in the ultimate model.

We can generalize the above example by the notion of a {\em monotonic property}.

\begin{definition}
If a {\em monotonic property} is true at time \dedalus{T}, then it is true at any time \dedalus{S > T}.
\end{definition}

An example of a monotonic property would be a persistent fact, or the negation of a fact that is never true.  Intuitively, a monotonic property represents some knowledge that never becomes untrue as we learn more knowledge.

\begin{definition}
A \lang program is {\em monotonic} if for all facts in any ultimate model, the element of the trace corresponding to the first time the fact was true before being henceforth true was computed by only monotonic properties. \wrm{may need some slight tweaking}
\end{definition}

\begin{example}
Example of a logically monotonic Dedalus program:\\
\begin{Dedalus}
node(X)@next <- node(X);
response(X)@next <- response(X);
all_responded() <- !not_responded(_);
not_responded(X) <- node(X), !response(X);
all_responded()@next <- all_responded();
\end{Dedalus}
\end{example}

The above program is monotonic. There is only one possible nonempty ultimate model, which contains \dedalus{all\_responded()}, and this fact is implied by a predicate \dedalus{!not\_responded(\_)}, which is monotonic because it is {\em r-positive} \wrm{cite Immerman} (i.e. the negation depth is even).  Note that the program is also confluent, because for any EDB, there is a unique ultimate model: either every node has an associated response, leading to a model with \dedalus{all\_responded()}, or there exists some node without an associated response, leading to an empty ultimate model.

We will see that all logically monotonic programs are confluent.  However, there are some non-logically-monotonic programs that are also confluent.

\begin{lemma}
A monotonic property must be true in all traces of a program, given an EDB.
\end{lemma}
\begin{proof}
Proof sketch: assume a monotonic property is true in one trace and false in another trace.  This means the monotonic property can differentiate between the two traces.  But since all async facts are persisted, all messages eventually rendezvous.  Thus, the monotonic property must be able to observe the condition that some event has not yet occured (but will eventually occur).  Monotonic properties cannot observe this though, becuase the property will be eventually untrue (when the thing that has not yet occured eventually occurs), thus it is not monotonic.
\end{proof}

\begin{corollary}
Logical monotonicity is a sufficient condition for confluence.
\end{corollary}
\begin{proof}
Proof sketch: if the ultimate model is populated only by monotonic properties, which are true in all traces, then there is a unique ultimate model.
\end{proof}

We now show that logical monotonicity is not necessary for confluence:

\begin{example}
Example of a confluent Dedalus program that is not logically monotonic:\\
\begin{Dedalus}
//client
b(#s,I)@async :- b_edb(I);

//server
b(N,I)@next <- b(N,I), !dequeued(I);
b_lt(i,j) <- b(_,i), b(_,j), i < j;
dequeued(i)@next <- b(_,i), !b_lt(_,i);
odd()@next <- odd(), !dequeued(_);
odd()@next <- dequeued(), even();
even() <- !odd();
\end{Dedalus}
\wrm{or, just consider the 2 counter machine...?}
\end{example}

The ultimate model contains \dedalus{odd()} if there are an odd number of \dedalus{b\_edb(I)} facts, and \dedalus{even()} otherwise.  Thus it is confluent.  However, the program is not logically monotonic because neither \dedalus{dequeued()} nor \dedalus{!dequeued()} are monotonic, so \dedalus{even()} is not supported by only monotonic properties, thus the program is not logically monotonic.

\wrm{Example of a Dedalus program that is nonconfluent (and thus not logically monotonic)}

\subsection{Coordination}
Programs that are not confluent often have a single ``natural'' ultimate model that corresponds to intuition, similarly to the way that Datalog programs with negation have a model called the {\em perfect model} which corresponds to intuition.  For various uses of negation, we will define a {\em perfect ultimate model}, and present a rewrite technique that adds {\em coordination} to a \lang program to convert it into a confluent \lang program that computes the {\em perfect ultimate model} (which is one of the original program's ultiamte models).

\wrm{describe coordination protocols as ``all-in'' protocols}

\wrm{Achieving the perfect ultimate model may lead to liveness problems (if we admit losses?)}

\wrm{introduce timers/boomerangs into ``all-in'' which lead to non-determinism in coordination.  tie into usages of paxos/2pc?}

Programs with non-deterministic coordination are no longer confluent.
