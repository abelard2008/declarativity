\section{Introduction}

The discourse in the distributed systems literature is about ensuring that programs can only result in desirable behaviors.  The tradition of protocols for coordination is all about enforcing these properties, not checking them.

Moreover, the need for these properties is usually motivated by reasoning about
read/write conflicts, making worst-case assumptions about the semantics of dataflows
dependent on those reads and writes.  \wrm{for example...}

One might ask instead the more general question of when coordination protocols are
needed, and whether a more refined understanding of program logic can obviate the need
for coordination in more cases than read-write analyses might suggest.  We attack this
question on a number of fronts:

We provide a formal description of \lang, a logic language for distributed systems, which captures the salient issues in asynchronous distributed systems: things \paa{events? deductions?} may be non-atomic, and things may be out-of-order.  \lang attractively formalizes these two issues by adding a notion of ``time'' to logic languages.  We also present an operational characterization of distributed systems, and prove that \lang models exactly \paa{a superset of} the executions that arise in the real world.

We identify a broad range of programs--all of monotonic Dedalus--in which traditional
distributed systems coordination protocols are completely unnecessary, since we show
these programs are confluent regardless of the ordering of reads and writes. Given the
expressive power of this class, we essentially are providing a formal argument for the
popular notion that ``it is often OK to do without coordination in distributed systems''. This line of reasoning also provides a conservative syntactic  check (monotonicity) for confluence in a distributed logic program written in a language like Dedalus or Bloom.

Unfortunately, we show that confluence is undecidable for the family of Dedalus
programs including negation.  In the presence of negation, we turn our attention to the
problem of using coordination in a judicious way.  We identify families of coordinated
Dedalus programs that are confluent, which correspond to familiar notions of stratified
evaluation of Datalog.  We show how to coerce arbitrary Dedalus programs into
coordinated Dedalus programs.  Etc..
