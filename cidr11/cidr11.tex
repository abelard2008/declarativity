\documentclass{acm_proc_article-sp}

\usepackage[usenames, dvipsnames]{color}
\usepackage{times}
\usepackage{xspace}
\usepackage{textcomp}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{url}
\usepackage{amsmath, amssymb}
\usepackage[protrusion=true,expansion=true]{microtype}
\usepackage{comment}
\usepackage{alltt}
\usepackage{appendix}
%\usepackage{algorithm}
%\usepackage{algorithmic}
\usepackage{booktabs}

%\linespread{0.975}

\usepackage{txfonts}
%\newcommand{\DT}{\mathcal{T}}
%\newcommand{\DS}{\mathcal{S}}
\newcommand{\DT}{T}
\newcommand{\DS}{S}
\newcommand{\Consts}{\mathcal{C}}
\newcommand{\Vars}{\mathcal{A}}
%\newcommand{\pos}{\protect{$_{pos}$}}
%\newcommand{\nega}{\protect{$_{neg}$}}
% RCS: Would like to use the above ones, but can't get them to work in Dedalus env.
\newcommand{\pos}{\_pos}
\newcommand{\nega}{\_neg}

\newcommand{\jmh}[1]{{\textcolor{red}{#1 -- jmh}}}
\newcommand{\paa}[1]{{\textcolor{blue}{#1 -- paa}}}
\newcommand{\rcs}[1]{{\textcolor{green}{#1 -- rcs}}}
\newcommand{\nrc}[1]{{\textcolor{magenta}{#1 -- nrc}}}
\newcommand{\wrm}[1]{{\color{BurntOrange}{#1 -- wrm}}}
\newcommand{\smallurl}[1]{{\small \url{#1}}}

\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{observation}{Observation}

%\def\slang{synchronous Dedalus\xspace}
\def\lang{\textsc{Dedalus}\xspace}
\def\slang{\textsc{Dedalus\ensuremath{_{{0}}}}\xspace}
%\def\synclang{{Dedalus\ensuremath{_{\large 0}}}\xspace}
\newcommand{\naive}      {na\"{\i}ve\xspace}
\newcommand{\Naive}      {Na\"{\i}ve\xspace}
%dedalus environment for code

\newenvironment{Dedalus}{
\vspace{0.5em}\begin{minipage}{0.95\textwidth}%\linespread{1.3}
\begin{alltt}\fontsize{9pt}{9pt}\selectfont}
{\end{alltt}\end{minipage}\vspace{0.5em}}

\newcommand{\dedalus}[1]{\texttt{\fontsize{9pt}{9pt}\selectfont #1}}

\begin{document}

\title{Consistency Analysis in Bloom: A Logical Approach}
\numberofauthors{4}

\author{
\alignauthor
Peter Alvaro
\alignauthor
Neil Conway
\alignauthor
Joseph M. Hellerstein
\and
\alignauthor
William R. Marczak
}

%\conferenceinfo{POPL '11}{Austin, TX, USA} 
%\copyrightyear{2011} 
%\copyrightdata{[to be supplied]}

%\title{Computation and Controlled Coincidence in Dedalus} 
%%Format\titlenote{(Produces the permission block, copyright information and page numbering). For use with ACM\_PROC\_ARTICLE-SP.CLS V2.6SP. Supported by ACM.}}
%
% You need the command \numberofauthors to handle the "boxing"
% and alignment of the authors under the title, and to add
% a section for authors number 4 through n.

%\numberofauthors{4}

%\authorinfo{Peter Alvaro$^\ast$ \quad William R. Marczak$^\ast$ \quad Neil
%Conway$^\ast$ \quad Joseph M. Hellerstein$^\ast$ \\ \quad David Maier$^\dagger$
%\quad Russell Sears$^\ddagger$ \quad Rastislav Bod\'{i}k$^\ast$}
%{$^\ast$University of California, Berkeley \quad $^\dagger$Portland State University \quad $^\ddagger$Yahoo! Research}
%{\{paa, wrm, nrc, hellerstein, bodik\}@cs.berkeley.edu \quad maier@cs.pdx.edu \quad sears@yahoo-inc.com}
% \authorinfo{William R. Marczak}
%            {University of California, Berkeley}
%            {wrm@cs.berkeley.edu}
% \authorinfo{Neil Conway}
%            {University of California, Berkeley}
%            {nrc@cs.berkeley.edu}
% \authorinfo{Joseph M. Hellerstein}
%            {University of California, Berkeley}
%            {hellerstein@cs.berkeley.edu}
%\authorinfo{David Maier}
%           {Portland State University}
%           {maier@cs.pdx.edu}
%\authorinfo{Russell Sears}
%           {Yahoo! Research}\emph{}
%           {sears@yahoo-inc.com}
% \authorinfo{Rastislav Bodik}
%            {University of California, Berkeley}
%            {bodik@cs.berkeley.edu}
\maketitle

\begin{abstract} 
%\jmh{I excised the POPL abstract that was pasted here.  I think we need a clean slate.  The last paragraph of the intro is probably close to what we want.}

% NEW
Applications that manage replicated state have consistency
requirements \nrc{Awkward: we actually want to say something like they ``must
  ensure that consistency is maintained.''}. Distributed transactions allow atomic, arbitrary updates of
replicated state, but they can also greatly increase messaging costs and may harm
partition tollerance. This has motivated the recent interest in ``eventually
consistent'' distributed protocols, which only require that all messages
eventually reach their destinations. However, building such an eventually
consistent system is a challenging task: the designer must ensure that
application semantics are insensitive to arbitrary message delay and reordering.

In this paper, we introduce \emph{Bloom}, a new language for distributed
programming, and a suite of analysis techniques intended to simplify the design
of distributed systems with ``loose'' consistency requirements.

% OLD
All applications that manage replicated state have consistency requirements.
Distributed transactions allow atomic, arbitrary updates of replicated state,\wrm{confluence seems
to be missing here.  also, i don't need transactional consistency if i never
read, for example.}, but require consensus protocols like two-phase commit,
whose message delays can greatly increase transaction time. Distributed system
designers must choose between \wrm{maybe one way to change
this is to say -- as an alternative to these expensive strong consistency things,
many have advocated a programming style that only guarantees message delivery,
and relies on the programmer to manage confluence via a custom protocol}
expensive consistency measures and ``eventually consistent'' infrastructures,
which ensure that all messages reach their destinations without guarantees
about timing or order.  Arguing the correctness of such applications often
involves showing that high-level application semantics are insensitive to the
order of physical I/O to an underlying data store \wrm{i don't know much about databases, but when i hear ``physical I/O to a data store'' i imagine some disk head bouncing around a disk doing I/Os.  this seems irrelevant to me -- i think the important part is showing that the program is a determinstic function of the program inputs -- in other words, insensitive to any re-ordering, delay, or co-incidence on the channel} (e.g., a shopping cart
application may be built atop a loosely consistent key/value store because the
operations of updating a cart are commutative).  This places a significant
burden on the programmer \wrm{because the programmer doesn't have any tools to assist them with this}, and the end result is an informal consistency
argument.  In this paper, we introduce a distributed programming language that
is order-independent by default\nrc{Should we name the language? Do we want to
  say this paper ``introduces'' the new lang?}, encouraging a style of programming that is
insensitive to reordering and message delay.  Using the CALM conjecture \wrm{better be a theorem, becuase we need to prove it in this paper},
which establishes a connection between logical monotonicity,
%nondeterminism in message delay
and deterministic program results in the face of channel re-ordering, we provide
a full-program static analysis to check for confluence.\nrc{Confluence has not
  been defined.}  The analysis
guarantees consistency of distributed state \wrm{still uncomfortable here -- if the analysis returns ``true'', your distributed state is not necessarily consistent.  maybe you replicate to N replicas, but all clients read from replica 1.  in that case, the state need only be consistent at replica 1.  also, if you add coordination, you might make your program confluent (such as in the previous example) but without coordinating distributed state},
or identify ``points of order'' where it may be necessary to constrain the
order of certain operations \wrm{in other words -- it may be necessary to defer visibility of updates} to ensure consistency by augmenting the program
with coordination protocols \wrm{not sure what a coordination protocol is}.
To demonstrate these techniques, we implement several variants of a distributed ``shopping
cart'' application, apply our analysis technique to do XYZ, and evaluate the
performance of the resulting programs.

\end{abstract}

\input{intro}
\input{calm}
\input{lang}
\input{analysis}
\input{case}
\input{eval}
\input{conclusion}

%\scriptsize
%\begin{spacing}{0.9}
\bibliographystyle{abbrv}
\bibliography{cidr11,declarativity}
%\end{spacing}

%%\appendix
%%\input{appendix}

%%\input{attic}

\end{document}
