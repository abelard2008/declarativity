\section{Bud: Bloom Under Development}
\label{sec:lang}
At base, distributed programs are parallel algorithms, and parallel programming is well known to be hard---even in the absence of distributed issues like component failure and message reordering.  Bloom is based on the observation that many of the fundamental problems with parallel programming come from a legacy of assumptions regarding classical von Neumann machine architectures.  In the von Neumann model, state is captured in an ordered array of addresses, and computation is expressed via an ordered list of instructions.  Traditional programming grew out of these assumptions about order.  It is no surprise therefore that popular languages are a bad match to parallel and distributed platforms, where order enforcement is complex to program and expensive to execute.\nrc{The end of this paragraph seems inconsistent to me: if ``traditional'' (imperative?) programming is all about order, why does it follow that ``order enforcement is complex to program and expensive to execute''?}

Bloom is designed to encourage a programming style that is ``disorderly'' by default.  State is captured in unordered collections, akin to relational and key-value models.  Computation is expressed in logic: an unordered set of declarative rules, each consisting of an unordered set of predicates.  As we discuss below, mechanisms for imposing order are available when needed, but the programmer is provided with tools to evaluate the need for these mechanisms as special-case behaviors, rather than a default model.  The result is code that parallelizes naturally with a minimum of coordination overhead.

\jmh{Can put this somewhere as space permits: Conventional wisdom in certain quarters says that rule-based languages become untenable for large programs that evolve over time, since the interactions among rules becomes too difficult to understand.  We believe this understandable concern is an artifact of the immaturity of many of those early rule languages, which tried to paper over important imperative aspects of their semantics.  In fact, we demonstrate below that the pure logic-programming roots of Bloom allow programmers to reason about important issues in a much deeper way than traditional imperative languages.}  
 
Unlike earlier efforts including active database languages~\cite{widom1996active}, the well-known Prolog language, and our own Overlog language for distributed systems~\cite{p2}, Bloom is {\em purely declarative}: the syntax of a program contains the full specification of its semantics, and there is no need for the programmer to understand or reason about the behavior of the evaluation engine.  

The prototype version of Bloom we describe here is embodied in an implementation we call {\em Bud} (Bloom Under Development).  Bud is a dialect of the popular Ruby scripting language, and is evaluated by a stock Ruby interpreter via a {\bf Bud} Ruby class.  Relative to other logic languages, we feel it has a familiar and programmer-friendly flavor, and we hope that the learning curve will be quite flat for programmers familiar with modern scripting languages.
%nrc: Cut because it seemed unimportant
%Future versions of Bloom may do away with some of the syntactic idiosyncracies of Ruby, but it has been useful to stay grounded in the specific syntax of one widely-accepted language, at least in our early work.
In the remainder of the paper, when we refer to Bloom we mean the language supported by the current Bud prototype.

\noindent{\bf Bloom Basics}\\
\noindent
Bloom is based on a formal temporal logic called Dedalus~\cite{dedalus-techr}, the details of which are beyond the scope of this paper.  Bloom programs are bundles of declarative statements akin to SQL views or Datalog rules.  Bloom statements can only reference data that is local to a node, and the Bloom evaluator at a given node operates independently of any other node.  Intuitively, one can think of Bloom evaluation at a given node proceeding in atomic rounds or ``timesteps.'' \jmh{We should try to replace the below with a declarative intuition, see if it works OK.  Kind of a copout to use an imperative one.}  A single timestep can be thought of operationally as follows: (a) inbound messages are dequeued and appended to local tables, (b) local Bloom statements are evaluated to fixpoint on local data, and (c) outbound messages are sent over the network, and new facts are appended to local tables.  This is an intuitive and operational {\em metaphor} for the meaning of a Bloom program; the actual semantics are purely declarative temporal logic, as described in the Dedalus paper~\cite{dedalus-techr}.

\noindent{\bf State in Bloom}\\
\noindent
Bloom programs can manage state in three core collection types: {\bf scratch}, {\bf table}, and {\bf channel}. Each object of these types has a relational-style schema of named columns, including an optional subset of those columns that forms a primary key.  In Bud, the type system for the columns is taken from Ruby, so it is possible to have a column based on any Ruby class the programmer cares to define or import.  Similar to other object-relational ADT schemes a la Postgres~\cite{postgres-adt}, column types can be manipulated using their own (non-destructive) methods, but the Bloom language has no knowledge of those types and can only operate on the column values as opaque objects.  

{\bf scratch} collections provide transient persistence: their contents are preserved only within a single Bloom timestep.  This provides a natural construct for inbound network messages that are to be handled atomically without having to write rules to ``delete'' them at the end of a timestep.  It also provides a syntax for views and other logical ``macros'' that are not intended to persist.  By contrast, the contents of {\bf table} collections persist across timesteps until the end of that timestep in which they are chosen for ``deletion.''  Technically, facts in Bloom are never deleted: they officially still ``exist'' in prior timesteps, but are not propagated into the next timestep and hence do not satisfy the predicates of Bloom statements in the next timestep.  This has a flavor of versioned storage, where \jmh{I don't like the rest of this sentence} only the most recent version of a collection is visible in the language.  More importantly, Bloom is {\em side-effect free}, which removes many of the complexities involved in reasoning about earlier stateful rule languages.  The paper on Dedalus discusses these points in more detail~\cite{dedalus-techr}.

{\bf channel} collections provide a logical foundation for the dataflow partitioning familiar from parallel databases and MapReduce engines.  In the specification of a {\bf channel}, one attribute must be designated as the {\em location specifier}; the type of that attribute must correspond to a unique network address (in our current implementation, this is an [IP,port] pair suitable for delivery via UDP).  \jmh{shorten rest of this paragraph}
At the beginning and end of each timestep, the channel relation contains only facts whose location specifier corresponds to the local node's address.  During the evaluation of Bloom statements, new facts may be derived in a {\bf channel} collection with different values in the location specifier attribute.  Those facts are sent to their intended destination by the runtime at the end of the timestep.  (In the Dedalus logic underlying Bloom, the model is that each of these facts will appear in the collection, but the timestep associated with the fact's existence is non-deterministically specified, and may be infinitely far in the future~\cite{dedalus-techr}.)

{\bf Bloom Statements}\\
\noindent
Statements in Bloom are akin to rules in Datalog, or views in SQL.  They consist of declarative relational statements that define the contents of derived relations.  As in Datalog or SQL, the output of a statement may be referenced recursively in its input, and statements may be mutually recursive.  Programmers declare Bloom statements within methods of a Bud subclass definition that are flagged with the \texttt{declare} modifier.  The semantics of a Bloom program are defined by the union of all the \texttt{declare} methods; the use of multiple methods is important only inasmuch as it interacts with Ruby's object-oriented features, as we describe shortly.

Bloom statements have the form \emph {$<$collection-variable$>$ $<$op$>$ $<$collection-expression$>$}, where the right- and left-hand sides specify collection types, and the infix operator is one of \texttt{<=}, \texttt{<+} or \texttt{<-}.

The collections in the Bloom prototype are based on a class called \texttt{BudCollection}, which imports Ruby's built-in \texttt{Enumerable} module.  The left-hand side of a Bloom statement is a Ruby  \texttt{BudCollection} object. The right-hand side is a Ruby expression that evaluates to an instance of \texttt{BudCollection}; these expressions are formed via methods on \texttt{BudCollection} objects.  Ruby's \texttt{map} method is used to declare scalar operations on all tuples of a \texttt{BudCollection}, including relational selection and projection.    \jmh{Refer to a line in an example.}  \texttt{BudCollection} provides a \texttt{group} method akin to SQL's \texttt{GROUP BY} syntax.  \jmh{also aggs, built-in and user-defined}    \jmh{Refer to a line in an example.}   Bud provides a subclass of \texttt{BudCollection} called \texttt{Join}, which essentially specifies an unnamed, derived {\bf scratch} collection.  The constructor of the \texttt{Join} subclass is parameterized by the relevant properties of a join: a list of two or more input relations, an optional set of equijoin attributes, and an optional set of non-equijoin predicates to filter the results.  

\jmh{need to intro the Bud operators \texttt{<=} (deduction), \texttt{<+} (induction) and \texttt{<-} (deletion).}

These constructs form the core of the Bloom language; database theory tells us that the combination of these constructs and an unbounded number of timesteps provides Turing-complete expressibility~\cite{christospaper}.  Bud also includes some additional convenience methods that provide macros over these methods.  More importantly, Bud takes advantage of the features of Ruby to enrich its declarative constructs with familiar programming metaphors that are popular with software developers.  Bud classes, like any Ruby classes, can be specialized via subclassing.  In particular, \texttt{declare} methods can be overridden in subclasses or in specific instances (via Ruby metaprogramming), allowing for selective rewriting of encapsulated bundles of statements.  We have found that the combination of Bloom's logic programming with Ruby's Object-Oriented inheritance and overriding has been quite natural.

{\bf Bud Implementation}\\
Bud was intended to be a lightweight rapid prototype of Bloom: a first effort at embodying the Dedalus logic in a syntax familiar to programmers.  Bud currently consists of under 1400 lines of Ruby code, developed in approximately two programmer-months of part-time effort.\footnote{The Bud gem depends on seven additional publicly-available Ruby gems for event handling (\texttt{EventMachine}), marshalling (\texttt{MsgPack}), metaprogramming (\texttt{ruby2ruby}, \texttt{ParseTree}, \texttt{sexp\_path}) and syntax niceties (\texttt{superators}, \texttt{anise}).}  This was possible in large part because modern scripting languages are moving closer to declarative programming, with rich support for collection types.  Like any rapid prototype, Bud is functional but not particularly efficient.  We plan to address runtime efficiency issues as we continue refining the syntax of Bloom and improving our ability to do code analysis of the sort described in the rest of the paper.

A Bud program is just a Ruby class definition.  To make it operational, a small amount of imperative Ruby code is needed to instantiate an instance of the class and invoke the Bud \texttt{run} method.  This imperative code is then executed on as many machines as desired; messages targeted at those nodes are handled according to the Bud specification.  In addition to the \texttt{run} method, the Bud class also has a \texttt{tickle} method that can be used to force evaluation of a single timestep; this is useful for debugging Bloom code with standard Ruby debugging tools, or for executing a Bud specification that is intended as a ``one-shot'' query.

\jmh{This paragraph could be chopped}
Because Bud is pure Ruby, some programmers may choose to embed it as a Domain-Specific Language within traditional imperative Ruby code.  In fact, nothing prevents a subclass of Bud from having both Bloom code in \texttt{declare} methods, and imperative code in traditional Ruby methods.  This is a fairly common usage model, akin to using the Rails package for local data management via declarative SQL alongside imperative Ruby. A mixture of declarative Bloom methods and imperative Ruby allows the full range of existing Ruby code---including the extensive RubyGems repositories---to be combined with checkable distributed Bloom programs. The analyses we describe in the remaining sections still apply in these cases; the imperative Ruby code interacts with the Bloom logic in the same way as any external agent sending network messages.