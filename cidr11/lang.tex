\section{Bud: Bloom Under Development}
\label{sec:lang}
% At base, distributed programs are parallel algorithms, and parallel programming
% is well known to be hard---even in the absence of distributed issues like
% component failure and message reordering.
Bloom is based on the conjecture that many of the fundamental problems with
parallel programming come from a legacy of assumptions regarding classical von
Neumann architectures.  In the von Neumann model, state is captured in an
ordered array of addresses, and computation is expressed via an ordered list of
instructions.  Traditional imperative programming grew out of these pervasive
assumptions about order.  Therefore, it is no surprise that popular imperative
languages are a bad match to parallel and distributed platforms, which make few
guarantees about order of execution and communication. By contrast, set-oriented
approaches like SQL and batch dataflow approaches like MapReduce translate
better to architectures with loose control over ordering.

Bloom is designed in the tradition of programming styles that are ``disorderly'' by nature.  State is captured in unordered relations.  Computation is expressed in logic: an unordered set of declarative rules, each consisting of an unordered set of predicates.  As we discuss below, mechanisms for imposing order are available when needed, but the programmer is provided with tools to evaluate the need for these mechanisms as special-case behaviors, rather than a default model.  The result is code that runs naturally on distributed machines with a minimum of coordination overhead.
 
Unlike earlier efforts such as Prolog, active database languages,
and our own Overlog language for distributed systems~\cite{p2}, Bloom is {\em purely declarative}: the syntax of a program contains the full specification of its semantics, and there is no need for the programmer to understand or reason about the behavior of the evaluation engine.  Bloom is based on a formal temporal logic called Dedalus~\cite{dedalus}.

The prototype version of Bloom we describe here is embodied in an implementation we call {\em Bud} (Bloom Under Development).  Bud is a subset of the popular Ruby scripting language and is evaluated by a stock Ruby interpreter via a \textbf{Bud} Ruby class.  Compared to other logic languages, we feel it has a familiar and programmer-friendly flavor, and we believe that its learning curve will be quite flat for programmers familiar with modern scripting languages.
%nrc: Cut because it seemed unimportant
%Future versions of Bloom may do away with some of the syntactic idiosyncracies of Ruby, but it has been useful to stay grounded in the specific syntax of one widely-accepted language, at least in our early work.
%In the remainder of the paper, when we refer to Bloom we mean the language supported by the current Bud prototype.

\vspace{9pt}\noindent\textbf{Bloom Basics}\\
Bloom programs are bundles of declarative statements about collections of ``facts'' or tuples, akin to SQL views or Datalog rules.  Bloom statements can only reference data that is local to a node.  Bloom rules are defined with respect to atomic ``timesteps,'' which can be implemented via successive rounds of evaluation. In each timestep, certain ``ground facts'' exist in collections due to persistence or the arrival of messages from outside agents (e.g., the network or system clock).  The statements in a Bloom program specify the derivation of additional facts, which can be declared to exist either in the current timestep, at the very next timestep, or at some time in the future at a remote node.  A Bloom program also specifies the way that facts persist (or do not persist) across consecutive timesteps on a single node.  Bloom is a side-effect free language with no ``mutable state'': if a fact is defined at a given timestep, its existence at that timestep cannot be refuted by any expression in the language.  This technicality is key to avoiding many of the complexities involved in reasoning about earlier ``stateful'' rule languages.  The paper on Dedalus discusses these points in more detail~\cite{dedalus}.

\begin{figure}
	\begin{small}
	\begin{tabular}{|l|p{2.55in}|}
		\hline
		Type & Behavior\\
		\hline
		\textbf{table} & A collection whose contents persist across timesteps.\\
		\textbf{scratch} & A collection whose contents persist for only one timestep.\\
		\textbf{channel} & A scratch collection with one attribute designated as the {\em location specifier}. Tuples ``appear'' at the address stored in their location specifier.\\
    \textbf{interface} & A scratch collection specially designated as a point of dataflow composition with other modules.  An interface is typed as either \texttt{input} or \texttt{output}, and may only compose with an interface of the opposite type.\\
		\textbf{periodic} & A scratch collection of key-value pairs (\texttt{id}, \texttt{timestamp}).  The spec for a \textbf{periodic} is parameterized by a \texttt{period} in seconds; the runtime system arranges (in a best-effort manner) for tuples to ``appear'' in this collection approximately every \texttt{period} seconds, with a unique \texttt{id} and the current wall-clock time.\\
		\hline
	\end{tabular}

	\vspace{2em}
	
	\begin{tabular}{|c|l|p{2in}|}
		\hline
		Op & Valid lhs types & Meaning\\
				\hline 
		\texttt{=} & \textbf{scratch} & rhs defines the contents of the lhs for the current timestep.  lhs must not appear in lhs of any other statement.\\
		\texttt{$<$=} & \textbf{table}, \textbf{scratch} & lhs includes the content of the rhs in the current timestep.\\
		\texttt{$<$+} & \textbf{table}, \textbf{scratch} & lhs will include the content of the rhs in the next timestep.\\
		              %& \textbf{channel} &  next timestep; remote \textbf{channel} tuples subject to delay.\\
		\texttt{$<$-} & \textbf{table} & tuples in the rhs will be missing from the lhs at the start of  the next timestep.\\
		\texttt{$<\sim$} & \textbf{channel} & tuples in the rhs will appear in the (remote) lhs at some future time.\\
		\hline
	\end{tabular}
	\end{small}
	\caption{Bloom collection types and operators.}
	\label{tab:bloom}
\end{figure}

\vspace{9pt}\noindent\textbf{State in Bloom}\\
Bloom programs manage state using five collection types described in
the top of Figure~\ref{tab:bloom}. Each object of these types is defined with a
relational-style schema of named columns, including an optional subset of those
columns that forms a primary key.  
Line~\ref{line:dec_chan} of
Figure~\ref{fig:declarations} shows the definition of a \textbf{channel} with 6
columns \texttt{server}, \texttt{client}, \texttt{session}, \texttt{reqid}, \texttt{item} and \texttt{action}; the
primary key is \texttt{(server, client, session, reqid)}. \texttt{server} is annotated with the location
specifier ``@,''
indicating that tuples inserted into the channel will appear at the address
in the first attribute of the tuple.
In Bud, the type system for the
columns is taken from Ruby, so it is possible to have a column based on any Ruby
class the programmer cares to define or import.  In Bud, a tuple in a Bloom
collection is simply a Ruby array containing as many elements as the columns of
the collection's schema.  As in other object-relational ADT schemes like
Postgres~\cite{postgres-adt}, column values can be manipulated using their own
(non-destructive) methods, but the Bloom language has no knowledge of those
types and can only reference the column values as opaque objects.

The persistence of a tuple is determined by the type of the collection that
contains the tuple. \textbf{scratch} collections are handy for transient data
like network messages, intermediate results, and ``macro'' definitions that
enable code reuse. The contents of a \textbf{table} persist across consecutive
timesteps (until that persistence is interrupted via a Bloom statement
containing the \texttt{$<$-} operator described below). Although there are
precise declarative semantics for this persistence~\cite{dedalus}, it is
convenient to think operationally as follows: \textbf{scratch} collections are
``emptied'' before each timestep begins, \textbf{table}s are ``stored''
collections (akin to tables in SQL), and the \texttt{$<$-} operator represents
batch ``deletion'' before the beginning of the next timestep.

The facts of the ``real world,'' including network messages and the passage of
wall-clock time, are captured via \textbf{channel} and \textbf{periodic}
collections; these are \textbf{scratch} collections whose contents ``appear''
at non-deterministic timesteps. 
% From a semantic point of view, all real-world non-determinism is captured
% here as \emph{ temporal} non-determinism: the non-determinstic Bloom timestep
% in which each fact eventually ``appears''.  
The paper on Dedalus delves deeper into the logical semantics of this
non-determinism~\cite{dedalus}.  Note that failure of nodes or
communication is captured here: it can be thought of as the repeated
``non-appearance'' of a fact at every timestep.  Again, it is convenient to
think operationally as follows: facts in a \textbf{channel} are delivered to
the address in their location specifier via a best-effort unordered network
protocol like UDP, and the definition of a \textbf{periodic} collection
instructs the runtime to ``inject'' facts at regular wall-clock intervals to
``drive'' further derivations.

Bloom programs compose with other Bloom programs and with external callers at unidirectional
\textbf{scratch} collections called \textbf{interfaces}.  A well-formed composition pairs
every input and output with an interface of the complementary kind.  Line~\ref{line:dec_in_interface} in 
Figure~\ref{fig:declarations} defines an input interface with the same schema as the \texttt{action\_msg}
channel.

\begin{comment}
\begin{figure}[t]
\begin{scriptsize}
\begin{verbatim}
 1      class SimplePQueue < Bud
 2      def state
 3        table :q, ['id'], ['payload']
 4        table :min_id, ['id']
 5        table :log, ['id'], ['payload']
 6        scratch :newmins, ['id'], ['payload']
 7        channel :output, 0, ['addr', 'id'], ['payload']
 8      end
 9    
10      declare
11      def dequeue
12        # find min_id value, agg across all items (group=nil)
13        min_id <= q.group(nil, min(q.id))
14    
15        # find the q items with min_id via natural join
16        mins = natjoin [q, min_id] {|q, m| q }
17    
18        # idempotence: ignore items with id previously logged
19        newmins <= mins.map do |q| 
20          q unless log.map{|p| p.id}.include? q.id
21        end
22
23        # in the next timestep, add newmins to log, delete from q
24        log <+ newmins.map{|h| [h.id]}
25        q <- mins.map {|q| q}
26      
27        # ship the min items via the output channel
28        output <+ mins.map{|q| ['192.168.1.1:12345'] + q}
29      end
30    end
\end{verbatim}
\vspace{-10pt}
\caption{Example Bloom code for dequeuing items from a priority queue.}
\label{fig:queue}
\end{scriptsize}
\vspace{-2pt}
\end{figure}

\end{comment}

\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
module CartProtocol
  def state
    super
    channel :action_msg, (*\label{line:dec_chan}*)
      ['@server', 'client', 'session', 'reqid'], ['item', 'action']
    channel :checkout_msg,
      ['@server', 'client', 'session', 'reqid']
    channel :response_msg,
      ['@client', 'server', 'session', 'item'], ['cnt']
  end
end

module CartClientProtocol
  def state
    super
    interface input, :client_action, (*\label{line:dec_in_interface}*)
      ['server', 'session', 'reqid'], ['item', 'action'] 
    interface input, :client_checkout, ['server', 'session', 'reqid']
    interface output, :client_response, 
      ['client', 'server', 'session'], ['item', 'cnt']
  end
end
\end{lstlisting}
\vspace{-10pt}
\caption{Example Bloom collection declarations.}
\label{fig:declarations}
\end{scriptsize}
\vspace{-2pt}
\end{figure}

\vspace{9pt}\noindent \textbf{Bloom Statements}\\
Statements in Bloom are akin to rules in Datalog or views in SQL.  They consist
of declarative relational statements that define the contents of derived
collections.  The syntax is:\\ \noindent
\mbox{\hspace{0.25in}\emph{$<$collection-variable$>$ $<$op$>$
$<$collection-expression$>$}}\\ \noindent In the Bud prototype, both sides of
the operator are instances of (a subclass of) a Ruby class called
\texttt{BudCollection}, which inherits Ruby's built-in \texttt{Enumerable}
module supporting typical collection methods.  Figure~\ref{tab:bloom} describes
the five operators that can be used to define the contents of the left-hand
side (lhs) in terms of the right-hand side (rhs).

As in Datalog or SQL, the lhs of a statement may be referenced recursively in
its rhs, or recursion can be defined mutually across statements.  The rhs
typically includes methods of \texttt{BudCollection} objects.  Most common is
the \texttt{map} method of Ruby's \texttt{Enumerable} module, which is used to
specify scalar operations on all tuples of a \texttt{BudCollection}, including
relational selection and projection. For example,
lines~\ref{line:dis_action_msg_beg}--\ref{line:dis_action_msg_end} of Figure~\ref{fig:pdg-disorderly} project the
\texttt{action\_msg} collection to its \texttt{session}, \texttt{item},
\texttt{action} and \texttt{reqid} fields.  \texttt{BudCollection} defines a
\texttt{group} method akin to SQL's \texttt{GROUP BY}, supporting the standard
SQL aggregates; for example, lines~\ref{line:dis_count_reqid_beg}--\ref{line:dis_count_reqid_end} of
Figure~\ref{fig:pdg-disorderly} compute the count 
of unique \texttt{reqid} values for every combination of values for
\texttt{session}, \texttt{item} and \texttt{action}.
Multiway joins are specified using the \texttt{join} method, which produces an anonymous \textbf{scratch} collection that can
be used in the rhs of a statement.\footnote{For clarity, we write out the join condition explicitly. Bloom provides syntax sugar for common join types (e.g., natural join).}
Line~\ref{line:dis_join_action_msg_member} of Figure~\ref{fig:pdg-disorderly}
shows a join between \texttt{action\_msg} and \texttt{member}.

\begin{figure}[t]
\begin{scriptsize}
\begin{lstlisting}
module CartClient
  include CartProtocol
  include CartClientProtocol

  declare
  def client
    action_msg <~ client_action.map do |a| 
      [a.server, @addy, a.session, a.reqid, a.item, a.action] (*\label{line:des_client_action}*)
    end
    checkout_msg <~ client_checkout.map do |a| 
      [a.server, @addy, a.session, a.reqid]
    end
    client_response <= response_msg.map {|r| r }
  end
end

\end{lstlisting}
\vspace{-10pt}
\caption{Shopping cart client implementation}
\label{fig:cart_client}
\end{scriptsize}
\vspace{-2pt}
\end{figure}



 % The constructor of the \texttt{Join} subclass is parameterized by the relevant properties of a join: a list of two or more input relations, and an optional set of predicates to filter the results.  


Programmers declare Bloom statements within methods of a Bud subclass
definition that are flagged with the \texttt{declare} modifier (e.g.,
line~\ref{line:des_declare} of Figure~\ref{fig:pdg-destructive}). The semantics
of a Bloom program are defined by the union of all the \texttt{declare}
methods; the order of statements is immaterial. Dividing statements into multiple
methods improves the readability of the program and allows use of Ruby's method
overriding and inheritance features, as described below.

%; the use of multiple methods is important only inasmuch as it interacts with Ruby's object-oriented features, as we describe next.

The constructs above form the core of the Bloom language.
% nrc: I think this is tangential anyway; removing for now
% ; database theory tells us that the combination of these constructs and an unbounded number of timesteps provides Turing-complete expressibility~\cite{Papadimitriou85}.  
% \jmh{Actually no ... papadimitriou85 ``a note on the expressive power of prolog'' shows that Datalog neg with finite successor is exactly PTIME.  If we can't get the right ref for this assertion, just remove it.}
% \wrm{Wow you guys are citation aces, I couldn't find this paper online.  Anyway, it's not turing complete if we view time as a stage/iteration variable -- i.e. FOL with "as much time as you need to compute" only gets us PSPACE.  However, if we view time as data (i.e. allow the infinite successor relation into the Herbrand universe), then we get turing completeness.}
Bud also includes some additional convenience methods that provide macros over these methods, and admits the use of simple side-effect-free Ruby expressions within statements.  More importantly, Bud takes advantage of the features of Ruby to enrich its declarative constructs with familiar programming metaphors that are popular with software developers.  Like any Ruby class, a Bud class can be specialized via subclassing.  In particular, \texttt{declare} methods can be overridden in subclasses or in specific instances, allowing for selective rewriting of encapsulated bundles of statements.%  We have found that the combination of Bloom's logic programming with Ruby's object-oriented inheritance and method overriding has been both natural and useful.

% TODO: work on this
\vspace{9pt}\noindent \textbf{Bloom Interfaces}\\
While subclassing is appropriate in certain contexts, Bud supports more general abstraction and reuse via 
Ruby's mixin functionality.  Modules defining collections and rules may be freely combined, subject to the restriction
that the dataflow be fully specified by connecting all input and output interfaces.  A common pattern is the
specification of abstract interfaces like those in Figure~\ref{fig:declarations}, which may be concretized by 
mixing in rules that connect input to output interfaces with Bud rules.  Figure~\ref{fig:cart_client} supplies
a simple concrete implementation of the CartClient protocol specified in Figure~\ref{fig:declarations}, leaving
unspecified the server logic that reads \texttt{action\_msg} and \texttt{checkout\_msg} and writes to
\texttt{response\_msg}.


%\jmh{Can remove this paragraph is we're short on space, but it's a critique we will definitely hear.}
%nrc: Cut this for space; also because omitting this won't cause the submission to be rejected.
\begin{comment}
Conventional wisdom in certain quarters says that rule-based languages are untenable for large programs that evolve over time, since the interactions among rules become too difficult to understand.  We believe this concern is an artifact of early rule languages that mixed apparently declarative syntax with imperative constructs and assumptions.  In fact, we demonstrate below that the pure logic-programming roots of Bloom can allow programmers to reason about many program interactions in a much deeper way than traditional imperative languages.
\end{comment}
%\input{destructive}

\vspace{9pt}\noindent \textbf{Bud Implementation}\\
Bud was intended to be a lightweight rapid prototype of Bloom: a first effort at embodying the Dedalus logic in a syntax familiar to programmers.  Bud consists of less than 1400 lines of Ruby code, developed in approximately two person-months of part-time effort.
%\footnote{The Bud gem depends on seven additional publicly-available Ruby gems for network event handling (\texttt{EventMachine}, \texttt{MsgPack}), metaprogramming (\texttt{ruby2ruby}, \texttt{ParseTree}, \texttt{sexp\_path}) and syntax niceties (\texttt{superators}, \texttt{anise}).}  This was possible in large part because modern scripting languages are moving closer to declarative programming, with rich support for collection types.  Like any rapid prototype, Bud is functional but not particularly efficient.  We plan to address runtime efficiency issues as we continue refining the syntax of Bloom and improving our ability to do code analysis of the sort described in the rest of the paper.


A Bud program is just a Ruby class definition.  To make it operational, a small amount of imperative Ruby code is needed to create an instance of the class and invoke the Bud \texttt{run} method.  This imperative code can then be launched on as many nodes as desired (e.g., via the popular Capistrano package for Ruby deployments).  Messages targeted at those nodes are handled according to the Bud specification.  As an alternative to the \texttt{run} method, the Bud class also provides a \texttt{tick} method that can be used to force evaluation of a single timestep; this is useful for debugging Bloom code with standard Ruby debugging tools, or for executing a Bud specification that is intended as a ``one-shot'' query.

Because Bud is pure Ruby, some programmers may choose to embed it as a Domain-Specific Language within traditional imperative Ruby code.  In fact, nothing prevents a subclass of Bud from having both Bloom code in \texttt{declare} methods and imperative code in traditional Ruby methods.  This is a fairly common usage model, akin to using the Ruby on Rails package to integrate declarative data management statements with imperative Ruby. A mixture of declarative Bloom methods and imperative Ruby allows the full range of existing Ruby code---including the extensive RubyGems repositories---to be combined with checkable distributed Bloom programs. The analyses we describe in the remaining sections still apply in these cases; the imperative Ruby code interacts with the Bloom logic in the same way as any external agent sending network messages.
