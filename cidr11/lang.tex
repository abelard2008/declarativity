\section{Bud: Bloom Under Development}
\label{sec:lang}
At base, distributed programs are parallel algorithms, and parallel programming is well known to be hard---even in the absence of distributed issues like component failure and message reordering.  Bloom is based on the observation that many of the fundamental problems with parallel programming come from a legacy of assumptions regarding classical von Neumann machine architectures.  In the von Neumann model, state is captured in an ordered array of addresses, and computation is expressed via an ordered list of instructions.  Traditional imperative programming grew out of these assumptions about order.  It is no surprise therefore that popular imperative languages are a bad match to parallel and distributed platforms, which make few guarantees about order of execution and communication. By contrast, set-oriented approaches like SQL and batch dataflow approaches like MapReduce translate better to architectures with loose control over ordering.

Bloom is designed in the tradition of programming style that are ``disorderly'' by default.  State is captured in unordered collections, akin to relational and key-value models.  Computation is expressed in logic: an unordered set of declarative rules, each consisting of an unordered set of predicates.  As we discuss below, mechanisms for imposing order are available when needed, but the programmer is provided with tools to evaluate the need for these mechanisms as special-case behaviors, rather than a default model.  The result is code that runs naturally on distributed machines with a minimum of coordination overhead.
 
Unlike earlier efforts including Prolog, active database languages%~\cite{widom1996active} 
and our own Overlog language for distributed systems~\cite{p2}, Bloom is {\em purely declarative}: the syntax of a program contains the full specification of its semantics, and there is no need for the programmer to understand or reason about the behavior of the evaluation engine.  Bloom is based on a formal temporal logic called Dedalus~\cite{dedalus-techr}.

The prototype version of Bloom we describe here is embodied in an implementation we call {\em Bud} (Bloom Under Development).  Bud is a constrained subset of the popular Ruby scripting language, and is evaluated by a stock Ruby interpreter via a \textbf{Bud} Ruby class.  Relative to other logic languages, we feel it has a familiar and programmer-friendly flavor, and we hope that the learning curve will be quite flat for programmers familiar with modern scripting languages.
%nrc: Cut because it seemed unimportant
%Future versions of Bloom may do away with some of the syntactic idiosyncracies of Ruby, but it has been useful to stay grounded in the specific syntax of one widely-accepted language, at least in our early work.
%In the remainder of the paper, when we refer to Bloom we mean the language supported by the current Bud prototype.

\noindent\textbf{Bloom Basics}\\
\noindent
Bloom programs are bundles of declarative statements akin to SQL views or Datalog rules.  Bloom statements can only reference data that is local to a node.  Bloom rules are defined with respect to atomic ``timesteps'', which can be implemented via successive rounds of evaluation. In each timestep, certain ``ground'' facts exist in collections due to persistence or the arrival of messages from outside agents (e.g., the network or system clock).  The statements in a Bloom program specify the derivation of additional facts, which can be declared to exist either in the current timestep, at the very next timestep, or at some time in the future a remote node.  A Bloom program also specifies the way that facts persist (or do not persist) across consecutive timesteps on a single node.  Bloom is a side-effect free language, with no ``mutable state'': if a fact is defined at a given timestep, its existence at that timestep cannot be refuted.  This technicality is key to avoiding many of the complexities involved in reasoning about earlier ``stateful'' rule languages.  The paper on Dedalus discusses these points in more detail~\cite{dedalus-techr}.

\begin{figure}
	\begin{small}
	\begin{tabular}{|l|p{2.55in}|}
		\hline
		type & persistence and other notes\\
		\hline
		\textbf{table} & A collection whose contents persist across timesteps.\\
		\textbf{scratch} & A collection whose contents persist for only one timestep.\\
		\textbf{channel} & A scratch collection with one attribute designated as the {\em location specifier}. Tuples ``appear'' at the address stored in their location specifier.\\
		\textbf{periodic} & A scratch collection of key-value pairs (\texttt{id}, \texttt{period}).  The spec for a \textbf{periodic} is parameterized by a \texttt{period} in seconds; the runtime system arranges (in a best-effort manner) for tuples to ``appear'' in this collection approximately every \texttt{period} seconds, with a unique \texttt{id} and the current system time.\\
		\hline
	\end{tabular}

	\vspace{2em}
	
	\begin{tabular}{|c|l|p{2in}|}
		\hline
		op & valid lhs types & meaning\\
				\hline 
		\texttt{=} & \textbf{scratch} & rhs defines the contents of the lhs for the current timestep.  lhs must not appear in lhs of any other statement.\\
		\texttt{$<$=} & \textbf{table}, \textbf{scratch} & lhs includes the content of the rhs in the current timestep.\\
		\texttt{$<$+} & \textbf{table}, \textbf{scratch}, & lhs will include the content of the rhs in the\\
		              & \textbf{channel} &  next timestep; remote \textbf{channel} tuples subject to delay.\\
		\texttt{$<$-} & \textbf{table} & tuples in the rhs will be missing from the lhs at the start of  the next timestep.\\
		\hline
	\end{tabular}
	\end{small}
	\caption{The Bloom collection types and operators.}
	\label{tab:bloom}
\end{figure}

\noindent\textbf{State in Bloom}\\
\noindent
Bloom programs manage state using four collection types described in the top of Figure~\ref{tab:bloom}. Each object of these types is defined with a relational-style schema of named columns, including an optional subset of those columns that forms a primary key.  Line 3 of Figure~\ref{fig:queue} shows a Bloom state definition for a table with 2 columns \texttt{id} and \texttt{payload}; \texttt{id} is the primary key.  In Bud, the type system for the columns is taken from Ruby, so it is possible to have a column based on any Ruby class the programmer cares to define or import.  Similar to other object-relational ADT schemes a la Postgres~\cite{postgres-adt}, column types can be manipulated using their own (non-destructive) methods, but the Bloom language has no knowledge of those types and can only reference the column values as opaque objects.  

Persistence in Bloom is determined by the type of the collection.  \textbf{scratch} collections are handy for transient data like network messages or tuples in view definitions.  The contents of a \textbf{table} persist across consecutive timesteps until that persistence is interrupted via a Bloom statement containing the \texttt{$<$-} operator described below. Although there are precise declarative semantics for this persistence~\cite{dedalus-techr}, it is convenient and not misleading to think operationally as follows: \textbf{scratch} collections are ``emptied'' before each timestep; Bloom \textbf{table}s are ``stored'' collections, and the \texttt{$<$-} operator (like SQL's \texttt{DELETE}) represents batch ``deletion'' before the beginning of the next timestep.

The facts of the ``real world,'' including message delays and clock events that mark the passage of wall-clock time, are captured via the specification of \textbf{channel} and \textbf{periodic} collections; these are \textbf{scratch} collections whose contents ``appear'' at non-deterministic timesteps. 
% From a semantic point of view, all real-world non-determinism is captured here as \emph{ temporal} non-determinism: the non-determinstic Bloom timestep in which each fact eventually ``appears''.  
Again, the paper on Dedalus delves deeper into the logical semantics of this non-determinism~\cite{dedalus-techr}.  Note that ``failure'' of nodes or communication is captured here; it can be thought of as the repeated ``non-appearance'' of a fact at every timestep.  Again, it is convenient and reasonable to think operationally as follows: facts in a \textbf{channel} are delivered to the address in their location specifier via a best-effort unordered network protocol like UDP; the specification of a \textbf{periodic} instructs the runtime to ``inject'' facts at regular wall-clock intervals to ``drive'' further derivations.

\begin{figure}[t]
\begin{scriptsize}
\begin{verbatim}
 1      class SimplePQueue < Bud
 2      def state
 3        table :q, ['id'], ['payload']
 4        table :min_id, ['id']
 5        table :log, ['id'], ['payload']
 6        scratch :newmins, ['id'], ['payload']
 7        channel :output, 0, ['addr', 'id'], ['payload']
 8      end
 9    
10      declare
11      def dequeue
12        # find min_id value, agg across all items (group=nil)
13        min_id <= q.group(nil, min(q.id))
14    
15        # find the q items with min_id via natural join
16        mins = natjoin [q, min_id] {|q, m| q }
17    
18        # idempotence: ignore items with id previously logged
19        newmins <= mins.map do |q| 
20          q unless log.map{|p| p.id}.include? q.id
21        end
22
23        # in the next timestep, add newmins to log, delete from q
24        log <+ newmins.map{|h| [h.id]}
25        q <- mins.map {|q| q}
26      
27        # ship the min items via the output channel
28        output <+ mins.map{|q| ['192.168.1.1:12345'] + q}
29      end
30    end
\end{verbatim}
\vspace{-10pt}
\caption{Example Bloom code for dequeuing items from a priority queue.}
\label{fig:queue}
\end{scriptsize}
\vspace{-2pt}
\end{figure}


\textbf{Bloom Statements}\\
\noindent
Statements in Bloom are akin to rules in Datalog, or views in SQL.  They consist of declarative relational statements that define the contents of derived relations.  The syntax is:\\
\noindent
\mbox{\hspace{0.25in}\emph{$<$collection-variable$>$ $<$op$>$ $<$collection-expression$>$}}\\
\noindent
In the Bud prototype, both sides of the operator are instances of (a subclass of) a Ruby class called \texttt{BudCollection}, which inherits Ruby's built-in \texttt{Enumerable} module supporting typical collection methods.  Figure~\ref{tab:bloom} describes the four operators that can be used to define the contents of the left-hand side (lhs) in terms of the right-hand side (rhs).

As in Datalog or SQL, the lhs of a statement may be referenced recursively in its rhs, or recursion can be defined mutually across statements.  The rhs typically includes methods of \texttt{BudCollection} objects.  
Most common is the \texttt{map} method of Ruby's \texttt{Enumerable} module, which is used to specify scalar operations on all tuples of a \texttt{BudCollection}, including relational selection and projection. For example, line 24 of Figure~\ref{fig:queue} projects the \texttt{newmins} collection to its \texttt{id} field.  \texttt{BudCollection} defines a \texttt{group} method akin to SQL's \texttt{GROUP BY}, supporting the standard SQL aggregates; line 13 of Figure~\ref{fig:queue} provides an example computing the minimum \texttt{id} across all tuples in collection \texttt{q}.  User-defined aggregates can be specified via a \texttt{reduce} method from Ruby \texttt{Enumerable}.  Multiway joins are specified via a subclass of \texttt{BudCollection} called \texttt{Join}, which produces an anonymous \textbf{scratch} collection that can be used in the rhs of a statement. Line 16 of Figure~\ref{fig:queue} gives an example of the natural join (equijoin on matching column names, in this case \texttt{id}.)
 % The constructor of the \texttt{Join} subclass is parameterized by the relevant properties of a join: a list of two or more input relations, and an optional set of predicates to filter the results.  


Programmers declare Bloom statements within methods of a Bud subclass definition that are flagged with the \texttt{declare} modifier (Figure~\ref{fig:queue}, line 10).  The order of statements is immaterial.  The semantics of a Bloom program are defined by the union of all the \texttt{declare} methods; the use of multiple methods is important only inasmuch as it interacts with Ruby's object-oriented features, as we describe next.

The constructs above form the core of the Bloom language; database theory tells us that the combination of these constructs and an unbounded number of timesteps provides Turing-complete expressibility~\cite{Papadimitriou85}.  
\jmh{Actually no ... papadimitriou85 ``a note on the expressive power of prolog'' shows that Datalog neg with finite successor is exactly PTIME.  If we can't get the right ref for this assertion, just remove it.}
\wrm{Wow you guys are citation aces, I couldn't find this paper online.  Anyway, it's not turing complete if we view time as a stage/iteration variable -- i.e. FOL with "as much time as you need to compute" only gets us PSPACE.  However, if we view time as data (i.e. allow the infinite successor relation into into the Herbrand universe), then we get turing completeness.}
Bud also includes some additional convenience methods that provide macros over these methods.  More importantly, Bud takes advantage of the features of Ruby to enrich its declarative constructs with familiar programming metaphors that are popular with software developers.  Bud classes, like any Ruby classes, can be specialized via subclassing.  In particular, \texttt{declare} methods can be overridden in subclasses or in specific instances (via Ruby metaprogramming), allowing for selective rewriting of encapsulated bundles of statements.  We have found that the combination of Bloom's logic programming with Ruby's object-oriented inheritance and method overriding has been quite natural.

Conventional wisdom in certain quarters says that rule-based languages are untenable for large programs that evolve over time, since the interactions among rules become too difficult to understand.  We believe this concern is an artifact of early rule languages that mixed apparently declarative syntax with imperative constructs and assumptions.  In fact, we demonstrate below that the pure logic-programming roots of Bloom can in some cases allow programmers to reason about program interactions in a much deeper way than traditional imperative languages.

\textbf{Bud Implementation}\\
Bud was intended to be a lightweight rapid prototype of Bloom: a first effort at embodying the Dedalus logic in a syntax familiar to programmers.  Bud currently consists of under 1400 lines of Ruby code, developed in approximately two programmer-months of part-time effort.
%\footnote{The Bud gem depends on seven additional publicly-available Ruby gems for network event handling (\texttt{EventMachine}, \texttt{MsgPack}), metaprogramming (\texttt{ruby2ruby}, \texttt{ParseTree}, \texttt{sexp\_path}) and syntax niceties (\texttt{superators}, \texttt{anise}).}  This was possible in large part because modern scripting languages are moving closer to declarative programming, with rich support for collection types.  Like any rapid prototype, Bud is functional but not particularly efficient.  We plan to address runtime efficiency issues as we continue refining the syntax of Bloom and improving our ability to do code analysis of the sort described in the rest of the paper.

\jmh{The next two paragraphs could be chopped}
A Bud program is just a Ruby class definition.  To make it operational, a small amount of imperative Ruby code is needed to instantiate an instance of the class and invoke the Bud \texttt{run} method.  This imperative code is then executed on as many machines as desired; messages targeted at those nodes are handled according to the Bud specification.  In addition to the \texttt{run} method, the Bud class also has a \texttt{tickle} method that can be used to force evaluation of a single timestep; this is useful for debugging Bloom code with standard Ruby debugging tools, or for executing a Bud specification that is intended as a ``one-shot'' query.

Because Bud is pure Ruby, some programmers may choose to embed it as a Domain-Specific Language within traditional imperative Ruby code.  In fact, nothing prevents a subclass of Bud from having both Bloom code in \texttt{declare} methods, and imperative code in traditional Ruby methods.  This is a fairly common usage model, akin to using the Rails package for local data management via declarative SQL alongside imperative Ruby. A mixture of declarative Bloom methods and imperative Ruby allows the full range of existing Ruby code---including the extensive RubyGems repositories---to be combined with checkable distributed Bloom programs. The analyses we describe in the remaining sections still apply in these cases; the imperative Ruby code interacts with the Bloom logic in the same way as any external agent sending network messages.
