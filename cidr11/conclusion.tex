\section{Conclusion and Additional Material}
\label{sec:conclusion}
In this short submission we make three main points.  First, we present the CALM principle, which connects the common practice of eventual consistency in distributed programming to a strong theoretical foundation in database theory.  Second, we show that we can bring that theory to bear on the practice of software development, via ``disorderly'' programming patterns, and automatic analysis techniques for  identifying and enforcing only the required points of order in a program. Finally, we present our Bloom prototype as an example of a practically-minded declarative programming language, with an evolutionary implementation that leverages familiar syntax and tools from Ruby, providing robust integration with the imperative programming environment of Ruby as needed.

In terms of connecting best-practice distributed programming to database theory, we have more ideas we hope to present in a full paper.  Chief among these is to provide programmer tools for \emph{managing inconsistency} without introducing coordination.  Helland reflects on his experience programming with patterns of ``memories, guesses and apologies''.  We believe we can convert many of these lessons into programming tools.  We provide a sketch here.

In declarative terms, ``guaranteed'' facts at any site have direct monotonic conclusions at any time.  ``Guesses'' may arise either at the inputs to a program (e.g. from noisy sensors or untrusted software), or via non-monotonic deductions made without coordination (e.g. assumptions about the state of distributed sets).  It can be useful to tag program inputs as either ``guarantees'' or ``guesses'', and propagate those tags through program logic in the manner of ``taint tracking'' in program security~\cite{taint}.  Moreover, using techniques from this paper we can automatically identify when program logic turns ``guarantees'' into ``guesses'': this happens at points of order that are not resolved via coordination.    
By logging guesses that cross interface boundaries, we can also implement Helland's idea of ``memories''.  If at a coarser time-scale, the logic of a program can establish the veracity of previous guesses (e.g. via periodic background coordination, or customer complaints), exception-handling rules can be invoked to ``make apologies'': contact customers, issue refunds, pay penalties, etc.  

We believe we can provide tools to codify these patterns, and help programmers implement verifiably correct management of inconsistency when needed.  We can automatically rewrite Bloom programs to propagate ``guess taint'' (in the spirit of identifying security risks), ``certificates of guarantee'' (in the spirit of deploying trustworthy software components), and other provenance information.  We can also automatically generate logic for logging ``memories'' of guesses at interface boundaries.  The logic of ``apologies'' for an application would need to be specified by the programmer, but we believe we can help here as well.  We can generate code scaffolds to help programmers specify background processes to resolve guesses, and apology logic for guesses that were incorrect.  We also hope to provide analysis techniques that can check the consistency of the high-level workflow: i.e., that the user behavior, the background guess resolution, and the apology logic eventually lead to a consistent resolution of the business rules at both the user and system sides.

\jmh{Another challenge: we don't really say how we discourage a programmer from a destructive implementation, or help them migrate from that implementation to a better one.  Ideally we'd find ways to ``push back'' coordination requirements to local nodes and/or points of the program that don't have latency constraints.}