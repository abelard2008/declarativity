\section{Conclusion and Discussion}
\label{sec:conclusion}
In this short submission, we make three main contributions.  First, we present
the CALM principle, which connects the common practice of eventual consistency
in distributed programming to a strong theoretical foundation in database
theory.  Second, we show that we can bring that theory to bear on the practice
of software development, via ``disorderly'' programming patterns and automatic
analysis techniques for identifying the points of
order in a program. Finally, we present our Bloom prototype as an example of a
practically-minded declarative programming language, with an initial
implementation as a Domain-Specific Language within Ruby.

We have more ideas about codifying best practices of distributed programming in software tools, which we hope to present in a full paper.  Chief among these is to provide programmer tools for \emph{managing inconsistency}, rather than resolving it via coordination.  Helland and Campbell reflect on their experience programming with patterns of ``memories, guesses and apologies''~\cite{quicksand}.  We provide a sketch here of ideas for converting these patterns into developer tools.

%Declarative programs typically assume ``guaranteed'' base facts, and use rules to define ``guaranteed'' derived monotonic.  
``Guesses''---facts that may not be true---may arise at the inputs to a program, e.g., from noisy sensors or untrusted software or users.  But Helland and Campbell's use of the term corresponds in our analysis to unresolved points of order: non-monotonic logic that makes decisions without full knowledge of its input sets.  We can rewrite the schemas of Bloom collections to include an additional attribute marking each fact as a ``guarantee'' or ``guess,'' and automatically augment user code to propagate those labels through program logic in the manner of ``taint checking'' in program security~\cite{taint,asbestos}.  Moreover, by identifying unresolved points of order, we can identify when program logic derives ``guesses'' from ``guarantees,'' and rewrite user code to label data appropriately.

By rewriting programs to log guesses that cross interface boundaries, we can also implement Helland and Campbell's idea of ``memories'': a log of guesses that were sent outside the system.  If at a coarser time-scale, the logic of a program can establish the veracity of previous guesses (e.g., via periodic background coordination or external inputs), exception-handling rules can be invoked to send confirmations or ``make apologies'': contact customers, issue refunds, etc.

Most of these patterns can be implemented as automatic program rewrites.  We
cannot fully automate the generation of ``apologies,'' since they are typically
application-specific.  But we believe we can help there too, by generating code
scaffolds for apology generation and issuance.  These could include background
process scaffolds for resolving guesses via long-timescale coordination, and
apology scaffolds for joining guesses that were incorrect with the history of
messages that require apologies.  More ambitiously, we hope to provide analysis
techniques that can prove the consistency of the high-level workflow: i.e.,
prove that any combination of user behavior, background guess resolution, and
apology logic will eventually lead to a consistent resolution of the business
rules at both the user and system sides.
