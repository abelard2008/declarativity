\section{Related Work}
\label{sec:relwork}
The shopping cart case study in Section~\ref{sec:case} was motivated by the
Amazon Dynamo paper~\cite{dynamo}, as well as the related discussion by Helland
and Campbell~\cite{quicksand}. Systems with loose consistency requirements have
been explored in depth by both the systems and database management communities; we include some typical references below~\cite{sagas,gray1996dangers,leases,bayou}, but do not hope to provide an exhaustive survey here.

The Bloom language is inspired by earlier work that attempts to integrate
databases and programming languages.  This includes early research such as Gem~\cite{gem}, and more recent
object-relational mapping layers like Ruby on Rails.  Unlike these efforts, Bloom is targeted at the development of both distributed infrastructure and distributed applications, so it does not make any assumptions about the presence of a database system ``underneath it''.  Given the Bud prototype implementation in Ruby, it is tempting to integrate Bud with Rails; we have left this for future work.

There is a long history of attempts to design programming languages more
suitable to parallel and distributed systems; for example, Argus~\cite{argus}
and Linda~\cite{linda}.  Again, we do not hope to survey that literature here.  More pragmatically, Erlang is an oft-cited choice for distributed programming in recent years.  Erlang's features and design style encourage the use of asynchronous lightweight ``actors''.  As mentioned previously, we did a simple Bloom prototype DSL in Erlang (which we cannot help but call ``Bloomerlang''), and there is a natural correspondence between Bloom-style distributed rules and Erlang actors.  However there is no requirement for Erlang programs to be written in the disorderly style of Bloom. It is not obvious that typical Erlang programs are significantly more amenable to a useful points-of-order analysis than programs written in any other functional language, like Scala or Haskell.  For example, ordered lists are basic constructs in functional languages, and without program annotation or deeper analysis than we need to do in Bloom, any code that modifies lists would need be marked as a point of order, much like our destructive shopping cart.  We believe that Bloom's ``disorderly by default'' style encourages more disorderly programming; we know that its roots in database theory bore fruit in terms of our analysis.  While we would be happy to see the analysis ``ported'' to currently popular distributed programming environments, it may be that design patterns using Bloom-esque disorderly programming are the natural way to achieve this.

