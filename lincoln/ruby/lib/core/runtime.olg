program runtime;

/*
import java.lang.String;
import java.lang.Integer;
import java.lang.Float;
import jol.types.basic.TupleSet;
import jol.types.basic.Tuple;
import jol.types.table.TableName;
*/

/* global::schedules things from the global::schedule queue (attaches strata to each tuple). */
define(queue, {Float, Integer, String, TableName, TupleSet, TupleSet});

/* Insertion queue: (Time, Strata, ProgramName, TableName, Tuples) */
define(insertionQueue, keys(), {Float, Integer, String, TableName, TupleSet});

/* Deletion queue: (Time, ProgramName, TableName, Tuples) */
define(deletionQueue,  keys(), {Float, String, TableName, TupleSet});

/* Evaluator output: evaluation(Time, ProgramName, TableName, Insertions, Deletions) */
define(evaluation, {Float, String, TableName, TupleSet, TupleSet});

/* Evaluator input: execute(Time, ProgramName, TableName, Insertions, Deletions) */
define(execute,    {Float, String, TableName, TupleSet, TupleSet});

/* Committer output: delta(Time, ProgramName, TableName, Insertions, Deletions) */ 
define(delta, {Float, String, TableName, TupleSet, TupleSet});

/* Committer input: runnable(Time, ProgramName, TableName, Insertions, Deletions) */ 
define(runnable,   {Float, String, TableName, TupleSet, TupleSet});

/* Current strata: strata(Program, Time, Strata) */
define(strata,  keys(0,1), {String, Float, Integer});

/* Predicate/TableName priority/strata: priority(Program, TableName, Strata) */
define(priority, keys(0,1), {String, TableName, Integer});

/* Remove insertion post evaluation. */
delete
insertionQueue(Time, Strata, Program, Name, Insertions) :-
    runnable(Time, Program, Name, Insertions, _),
    insertionQueue(Time, Strata, Program, Name, Insertions);

/* Remove deletion post evaluation. */
delete
deletionQueue(Time, Program, Name, Deletions) :-
    runnable(Time, Program, Name, _, Deletions);

/* Reglobal::schedule delta. */
global::schedule(Time, Program, Name, Insertions, Deletions) :-
	evaluation(Time, Program, Name, Insertions, Deletions),
	Insertions.size() > 0;

global::schedule(Time, Program, Name, Insertions, Deletions) :-
  evaluation(Time, Program, Name, Insertions, Deletions),
	Deletions.size() > 0;
	
/* Evaluate the program with the given insertions OR deletions. */
evaluator
evaluation(Time, Program, Name, Insertions, Deletions) :-
	evaluator(execute(Time, Program, Name, Insertions, Deletions));
	
/* NOTE: We do not global::schedule public deletions!! */
publicEval
execute(Time, Program2, Name, Insertions, null) :-
	delta(Time, Program1, Name, Insertions, Deletions),
	bootstrap::query(Program2, Rule, Public, Delete, Event, Input, Output, Object),
	Public == true, Input == Name, Program1 != Program2;

/* Execute on the intended program. */
localEval
execute(Time, Program, Name, Insertions, Deletions) :-
	delta(Time, Program, Name, Insertions, Deletions);

/* Flusher the insertions OR deletions, pass deltas to evaluator. */
commit 
delta(Time, Program, Name, Insertions, Deletions) :-
	flusher(runnable(Time, Program, Name, Insertions, Deletions));

/* Identify the runnable tuples. */
insertion_runnable 
runnable(Time, Program, Name, Insertions, null) :-
	strata(Program, Time, Strata),
	insertionQueue(Time, Strata, Program, Name, Insertions);

/* Execute all deletions when insertion count goes to 0. 
   Deletions executed and deletions deltas global::scheduled for 
   next global::clock. */
deletion_runnable 
runnable(Time+1, Program, Name, null, Deletions) :-
	deletionQueue(Time, Program, Name, Deletions);


/* Determine the current strata in the current time for all 
   programs that have something global::scheduled. */
strata 
strata(Program, Time, min<Stratum>) :-
	insertionQueue(Time, Stratum, Program, Name, Insertions);

init_insertion_queue
insertionQueue(Time, Strata, Program, Name, Insertions) :-
	queue(Time, Strata, Program, Name, Insertions, _),
	compiler::program(Program, Owner, Object),
	Insertions != null, Insertions.size() > 0;
	
init_deletion_queue
deletionQueue(Time, Program, Name, Deletions) :-
	queue(Time, Strata, Program, Name, Insertions, Deletions),
	compiler::program(Program, Owner, Object),
	Deletions != null, Deletions.size() > 0;
	
/* Queue up global::scheduled items in current global::clock. */
q1_rule
queue(Time, Strata, Program, Name, Insertions, Deletions) :-
	global::clock(Location, Time),
	global::schedule(Time, Program, Name, Insertions, Deletions),
	priority(Program, Name, Strata);
	
q2_rule
queue(Time, 0, Program, Name, Insertions, Deletions) :-
	global::clock(Location, Time),
	global::schedule(Time, Program, Name, Insertions, Deletions),
	notin priority(Program, Name, _);

/* Clean up queued programs. */
sched_deleter
delete
global::schedule(Time, Program, Name, Insertions, Deletions) :-
	global::clock#delete(Location, Time),
	global::schedule(Time, Program, Name, Insertions, Deletions);

/*******************************************************************/
/*** Periodic global::scheduler                                           **/

define(schedulePeriodic, {String, Float, Float, Float, Float, String});

/* schedule next periodic. */
renewPeriodic
schedulePeriodic(Id, Period, TTL, Time+Period, Count+1, Program) :-
	global::clock#insert(Location, Time),
	global::periodic(Id, Period, TTL, Time, Count, Program),
	Count < TTL;
			
initPeriodic 
schedulePeriodic(Id, Period, TTL, Time+1+Offset, Count+1, Program) :-
	config(Time, Program, Object),
	global::periodic(Id, Period, TTL, Offset, Count, Program);
	
/* global::schedule the periodic and update its execution count. */
schedulePeriodic 
periodic(Id, Period, TTL, Time, Count, Program) :-
	periodicSchedule(schedulePeriodic(Id, Period, TTL, Time, Count, Program));


/*******************************************************************/
/*** Fact global::scheduler */

define(facts, {String, TableName, TupleSet});

collectFacts 
facts(Program, Name, tupleset<Tuple>) :-
	config(Time, Program, Object),
	compiler::fact(Program, Name, Tuple);
	
installFacts 
queue(Time, 0, Program, Name, Facts, null) :-
	facts(Program, Name, Facts), 
	global::clock(Location, Time), 
	Facts.setName(Name),
	Program == "compiler";
	
installFacts2 
global::schedule(TheTime, Program, Name, Facts, null) :-
	facts(Program, Name, Facts), Program != "compile",
	Facts.setName(Name),
	global::clock(Location, Time),
	TheTime := Time+1;
	
/*******************************************************************/
/*** global::schedule compile */

define(config, {Float, String, Program});

configProgram 
config(Time, Program, Object) :-
	bootstrap::compiler#insert(Program, Owner, File, Object),
	global::clock(Location, Time),
	Object.plan();
		
		
watch(runnable, d);

compileConfig 
global::schedule(Time, "compile", TupleName, Tuples, null) :-
	config(Time, Program, Object),
	TableName := TableName.new("compile", "config"),
	Obj := Object.tuple(),
	Tuples := TupleSet.new(TableName, Obj),
	TupleName := Tuples.name();
