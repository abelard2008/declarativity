// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 1.14.2,
// (C) 2004-2008 Robert Grimm,
// on Thursday, October 23, 2008 at 1:24:11 PM.
// Edit at your own risk.
// ===========================================================================

package jol.lang.parse;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Action;
import xtc.util.Pair;

import xtc.tree.Node;
import xtc.tree.GNode;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

/**
 * Packrat parser for grammar <code>jol.lang.parse.Parser</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 1.14.2, (C) 2004-2008 Robert Grimm.
 */
public final class Parser extends ParserBase {

  /** The OVERLOG_KEYWORDS set. */
  public static final Set<String> OVERLOG_KEYWORDS = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fRuleHead;
    Result fRuleBody;
    Result fTerm;
    Result fSchema;
    Result fPredicate;
    Result fExpression;
    Result fExpressionList;
    Result fExpressionList$$Star1;
    Result fUnaryExpression;
    Result fPostfixExpression;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fPrimaryExpression;
    Result fSymbol;
    Result fName;
    Result fWord;
    Result fTableName;
    Result fVariable;
    Result fLocation;
    Result fType;
    Result fTypeName;
    Result fConstant;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fFloatConstant;
    Result fIntegerConstant;
    Result fIntegerList;
    Result fIntegerList$$Star1;
    Result fStringConstant;
    Result fIntVector;
    Result fFloatVector;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class ParserColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public Parser(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public Parser(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new ParserColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Program.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pProgram(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pProgramName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pClauses(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyResult = pEndOfFile(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = GNode.create("Program", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.ProgramName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pProgramName(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("program")) {

      yyResult = pWord(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("program name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Clauses.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClauses(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pClause(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.create("Clauses", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Clause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClause(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Rule>.

    yyResult = pRule(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Watch>.

    yyResult = pWatch(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Timer>.

    yyResult = pTimer(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Load>.

    yyResult = pLoad(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Fact>.

    yyResult = pFact(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Import>.

    yyResult = pImport(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Define>.

    yyResult = pDefinition(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Load.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLoad(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("load")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pStringConstant(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pTableName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              final int yyChoice1 = yyResult.index;

              // Nested alternative 1.

              yyBase   = yyChoice1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(")")) {

                yyValue = GNode.create("Load", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }

              // Nested alternative 2.

              yyBase   = yyChoice1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(",")) {

                yyResult = pStringConstant(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$3 = yyResult.semanticValue();

                  yyBase   = yyResult.index;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue(")")) {

                    yyValue = GNode.create("Load", v$g$1, v$g$2, v$g$3);
                    yyValue.setLocation(location(yyStart));

                    return yyResult.createValue(yyValue, yyError);
                  } else {
                    yyError = yyError.select("')' expected", yyBase);
                  }
                }
              } else {
                yyError = yyError.select("',' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("load expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Import.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImport(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("import")) {

      yyResult = pTypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("Import", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("import expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Fact.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFact(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTableName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pExpressionList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("Fact", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Rule.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRule(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pWord(yyBase);
    if (yyResult.hasValue("public")) {
      final String v$el$1 = "public";

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("'public' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final String v$g$1 = yyOpValue1;

      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue("async")) {
        final String v$el$2 = "async";

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      } else {
        yyError = yyError.select("'async' expected", yyBase);
      }
      { // Start scope for v$g$2.
        final String v$g$2 = yyOpValue1;

        final int yyChoice1 = yyOption1;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyBase   = yyOption1;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue("delete")) {
          final String v$el$3 = "delete";

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        } else {
          yyError = yyError.select("'delete' expected", yyBase);
        }
        { // Start scope for v$g$4.
          final String v$g$4 = yyOpValue1;

          yyResult = pRuleHead(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$5 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(":-")) {

              yyResult = pRuleBody(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$6 = yyResult.semanticValue();

                yyValue = GNode.create("Rule", v$g$1, v$g$2, null, v$g$4, v$g$5, v$g$6);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("':-' expected", yyBase);
            }
          }
        } // End scope for v$g$4.

        // Nested alternative 2.

        yyResult = pName(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$7 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyBase   = yyOption1;
          yyResult = pWord(yyBase);
          if (yyResult.hasValue("delete")) {
            final String v$el$4 = "delete";

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$4;
          } else {
            yyError = yyError.select("'delete' expected", yyBase);
          }
          { // Start scope for v$g$8.
            final String v$g$8 = yyOpValue1;

            yyResult = pRuleHead(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$9 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(":-")) {

                yyResult = pRuleBody(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$10 = yyResult.semanticValue();

                  yyValue = GNode.create("Rule", v$g$1, v$g$2, v$g$7, v$g$8, v$g$9, v$g$10);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("':-' expected", yyBase);
              }
            }
          } // End scope for v$g$8.
        }
      } // End scope for v$g$2.
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.RuleHead.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRuleHead(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fRuleHead) 
      yyColumn.chunk1.fRuleHead = pRuleHead$1(yyStart);
    return yyColumn.chunk1.fRuleHead;
  }

  /** Actually parse jol.lang.parse.Parser.RuleHead. */
  private Result pRuleHead$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPredicate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("RuleHead", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.RuleBody.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRuleBody(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fRuleBody) 
      yyColumn.chunk1.fRuleBody = pRuleBody$1(yyStart);
    return yyColumn.chunk1.fRuleBody;
  }

  /** Actually parse jol.lang.parse.Parser.RuleBody. */
  private Result pRuleBody$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTermList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("RuleBody", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.TermList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTermList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTerm(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$l$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pTerm(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$l$2.
        final Pair<Node> v$l$2 = yyRepValue1.reverse();

        yyValue = new Pair<Node>(v$l$1, v$l$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$l$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Term.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTerm(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTerm) 
      yyColumn.chunk1.fTerm = pTerm$1(yyStart);
    return yyColumn.chunk1.fTerm;
  }

  /** Actually parse jol.lang.parse.Parser.Term. */
  private Result pTerm$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTableFunction(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pPredicate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pAssignment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pSelection(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Timer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTimer(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("timer")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pTableName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pIntegerConstant(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(",")) {

                yyResult = pIntegerConstant(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$3 = yyResult.semanticValue();

                  yyBase   = yyResult.index;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue(")")) {

                    yyValue = GNode.create("Timer", v$g$1, v$g$2, v$g$3);
                    yyValue.setLocation(location(yyStart));

                    return yyResult.createValue(yyValue, yyError);
                  } else {
                    yyError = yyError.select("')' expected", yyBase);
                  }
                }
              } else {
                yyError = yyError.select("',' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("timer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Definition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDefinition(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("define")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pTableName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pKeys(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(",")) {

                yyResult = pSchema(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$3 = yyResult.semanticValue();

                  yyBase   = yyResult.index;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue(")")) {

                    yyValue = GNode.create("Table", v$g$1, v$g$2, v$g$3);
                    yyValue.setLocation(location(yyStart));

                    return yyResult.createValue(yyValue, yyError);
                  } else {
                    yyError = yyError.select("')' expected", yyBase);
                  }
                }
              } else {
                yyError = yyError.select("',' expected", yyBase);
              }
            }

            // Nested alternative 2.

            yyResult = pSchema(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$4 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(")")) {

                yyValue = GNode.create("Event", v$g$1, v$g$4);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("definition expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Keys.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pKeys(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("keys")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pIntegerList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("Keys", v$g$1);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }

        // Nested alternative 2.

        yyBase   = yyChoice1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyValue = GNode.create("Keys", false);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("keys expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Schema.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSchema(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSchema) 
      yyColumn.chunk1.fSchema = pSchema$1(yyStart);
    return yyColumn.chunk1.fSchema;
  }

  /** Actually parse jol.lang.parse.Parser.Schema. */
  private Result pSchema$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pTypeDefList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("}")) {

          yyValue = GNode.create("Schema", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("schema expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.TypeDefList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeDefList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$l$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pType(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$l$2.
        final Pair<Node> v$l$2 = yyRepValue1.reverse();

        yyValue = new Pair<Node>(v$l$1, v$l$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$l$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Watch.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWatch(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("watch")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pTableName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyBase   = yyChoice1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("Watch", v$g$1);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }

          // Nested alternative 2.

          yyBase   = yyChoice1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pWatchFlow(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final String v$g$2 = yyResult.semanticValue();

              yyResult = pSpacing(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyBase   = yyResult.index;
                yyResult = pSymbol(yyBase);
                if (yyResult.hasValue(")")) {

                  yyValue = GNode.create("Watch", v$g$1, v$g$2);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                } else {
                  yyError = yyError.select("')' expected", yyBase);
                }
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("watch expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.WatchFlow.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWatchFlow(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case 'a':
        case 'd':
        case 'e':
        case 'i':
        case 'r':
        case 's':
        case 't':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("watch flow expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.TableFunction.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTableFunction(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTableName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pPredicate(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("TableFunction", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Predicate.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPredicate(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPredicate) 
      yyColumn.chunk1.fPredicate = pPredicate$1(yyStart);
    return yyColumn.chunk1.fPredicate;
  }

  /** Actually parse jol.lang.parse.Parser.Predicate. */
  private Result pPredicate$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pWord(yyBase);
    if (yyResult.hasValue("notin")) {
      final String v$el$1 = "notin";

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("'notin' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final String v$g$1 = yyOpValue1;

      yyResult = pTableName(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pEventModifier(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$3.
          final String v$g$3 = yyOpValue1;

          yyResult = pArguments(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$4 = yyResult.semanticValue();

            yyValue = GNode.create("Predicate", v$g$1, v$g$2, v$g$3, v$g$4);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for v$g$3.
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Assignment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignment(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVariable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":=")) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("Assignment", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':=' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Selection.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSelection(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Selection", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExpression) 
      yyColumn.chunk1.fExpression = pExpression$1(yyStart);
    return yyColumn.chunk1.fExpression;
  }

  /** Actually parse jol.lang.parse.Parser.Expression. */
  private Result pExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIfElseExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Expression", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.ExpressionList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressionList(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExpressionList) 
      yyColumn.chunk1.fExpressionList = pExpressionList$1(yyStart);
    return yyColumn.chunk1.fExpressionList;
  }

  /** Actually parse jol.lang.parse.Parser.ExpressionList. */
  private Result pExpressionList$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$l$1 = yyResult.semanticValue();

      yyResult = pExpressionList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$l$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$l$1, v$l$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal jol.lang.parse.Parser.ExpressionList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressionList$$Star1(final int yyStart) 
    throws IOException {

    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExpressionList$$Star1) 
      yyColumn.chunk1.fExpressionList$$Star1 = pExpressionList$$Star1$1(yyStart);
    return yyColumn.chunk1.fExpressionList$$Star1;
  }

  /** Actually parse jol.lang.parse.Parser.ExpressionList$$Star1. */
  private Result pExpressionList$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pExpressionList$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.IfElseExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIfElseExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <IfElse>.

    yyResult = pLogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("?")) {

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("IfElseExpression", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'?' expected", yyBase);
      }
    }

    // Alternative <Base>.

    yyResult = pLogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.LogicalOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalOrExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pLogicalAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pLogicalOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * jol.lang.parse.Parser.LogicalOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("||")) {

      yyResult = pLogicalAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.LogicalAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalAndExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pEqualityExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pLogicalAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * jol.lang.parse.Parser.LogicalAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&&")) {

      yyResult = pEqualityExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.EqualityExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pInequalityExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pEqualityExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * jol.lang.parse.Parser.EqualityExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pEqualityOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pInequalityExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("EqualityExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.EqualityOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityOperator(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Equal>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("==")) {
      yyValue = "==";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <NotEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("!=")) {
      yyValue = "!=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <LessGreater>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<>")) {
      yyValue = "<>";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("equality operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.InequalityExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInequalityExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pShiftExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pInequalityExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * jol.lang.parse.Parser.InequalityExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInequalityExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInequalityOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pShiftExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("InequalityExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.InequalityOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInequalityOperator(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Less>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<")) {
      yyValue = "<";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Greater>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">")) {
      yyValue = ">";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <LessEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<=")) {
      yyValue = "<=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <GreaterEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">=")) {
      yyValue = ">=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("inequality operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.ShiftExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pAdditiveExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pShiftExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal jol.lang.parse.Parser.ShiftExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pShiftOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pAdditiveExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("ShiftExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.ShiftOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftOperator(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Left>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<<")) {
      yyValue = "<<";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Right>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">>")) {
      yyValue = ">>";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("shift operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.AdditiveExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pMultiplicativeExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pAdditiveExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * jol.lang.parse.Parser.AdditiveExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pAdditiveOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pMultiplicativeExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("AdditiveExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.AdditiveOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveOperator(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Plus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("+")) {
      yyValue = "+";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Minus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("-")) {
      yyValue = "-";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("additive operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.MultiplicativeExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pUnaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pMultiplicativeExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * jol.lang.parse.Parser.MultiplicativeExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pMultiplicativeOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pUnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("MultiplicativeExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.MultiplicativeOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeOperator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Times>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*")) {
      yyValue = "*";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Over>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("/")) {
      yyValue = "/";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Modulo>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("%")) {
      yyValue = "%";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("multiplicative operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.UnaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnaryExpression(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fUnaryExpression) 
      yyColumn.chunk1.fUnaryExpression = pUnaryExpression$1(yyStart);
    return yyColumn.chunk1.fUnaryExpression;
  }

  /** Actually parse jol.lang.parse.Parser.UnaryExpression. */
  private Result pUnaryExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Cast>.

    yyResult = pCastExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <LogicalNot>.

    yyResult = pLogicalNegationExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Inclusive>.

    yyResult = pInclusiveExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Base>.

    yyResult = pPostfixExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.LogicalNegationExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalNegationExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("!")) {

      yyResult = pUnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("LogicalNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical negation expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.CastExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCastExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyResult = pUnaryExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("CastExpression", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("cast expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.InclusiveExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInclusiveExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPrimaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue("in")) {
        final String v$g$2 = "in";

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pRangeExpression(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("InclusiveExpression", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyResult = pVariable(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$4 = yyResult.semanticValue();

          yyValue = GNode.create("InclusiveExpression", v$g$1, v$g$2, v$g$4);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'in' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.RangeExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRangeExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLeftRangeOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$3 = yyResult.semanticValue();

            yyResult = pRightRangeOperator(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final String v$g$4 = yyResult.semanticValue();

              yyValue = GNode.create("RangeExpression", v$g$1, v$g$2, v$g$3, v$g$4);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.LeftRangeOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLeftRangeOperator(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Inclusive>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {
      yyValue = "[";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Exclusive>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {
      yyValue = "(";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("left range operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.RightRangeOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRightRangeOperator(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Inclusive>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("]")) {
      yyValue = "]";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Exclusive>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(")")) {
      yyValue = ")";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("right range operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.PostfixExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfixExpression(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPostfixExpression) 
      yyColumn.chunk1.fPostfixExpression = pPostfixExpression$1(yyStart);
    return yyColumn.chunk1.fPostfixExpression;
  }

  /** Actually parse jol.lang.parse.Parser.PostfixExpression. */
  private Result pPostfixExpression$1(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pPrimaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$7 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pPostfixExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$8 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$8, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$9.
        final Pair<Action<Node>> v$9 = yyRepValue1.reverse();

        yyValue = apply(v$9, v$g$7, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$9.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * jol.lang.parse.Parser.PostfixExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfixExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(".")) {

      yyResult = pName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("Reference", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pArguments(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("Method", v$1, v$g$3);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {

      yyResult = pConstant(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("ArrayIndex", v$1, v$g$4);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative 4.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("++")) {
      final String v$g$5 = "++";

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("Increment", v$1, v$g$5);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("--")) {
      final String v$g$6 = "--";

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("Decrement", v$1, v$g$6);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("postfix expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.PrimaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimaryExpression(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPrimaryExpression) 
      yyColumn.chunk2.fPrimaryExpression = pPrimaryExpression$1(yyStart);
    return yyColumn.chunk2.fPrimaryExpression;
  }

  /** Actually parse jol.lang.parse.Parser.PrimaryExpression. */
  private Result pPrimaryExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Alias>.

    yyResult = pAlias(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Variable>.

    yyResult = pVariable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Location>.

    yyResult = pLocation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <NewClass>.

    yyResult = pNewClass(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Aggregate>.

    yyResult = pAggregate(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Reference>.

    yyResult = pReferenceName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Constant>.

    yyResult = pConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Context>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("primary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Arguments.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArguments(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExpressionList(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyValue = GNode.create("Arguments", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(")")) {

        yyValue = GNode.create("Arguments", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("')' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("arguments expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.NewClass.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNewClass(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("new")) {

      yyResult = pTypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("NewClass", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("new class expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.ReferenceName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pReferenceName(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("ReferenceName", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Aggregate.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAggregate(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Generic>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("generic")) {
      final String v$g$1 = "generic";

      yyC = character(yyResult.index);
      if ('<' == yyC) {
        yyIndex = yyResult.index + 1;

        yyResult = pPostfixExpression(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyC = character(yyResult.index);
          if ('>' == yyC) {
            yyIndex = yyResult.index + 1;

            yyValue = GNode.create("Aggregate", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$3 = yyResult.semanticValue();

      yyC = character(yyResult.index);
      if ('<' == yyC) {
        yyIndex = yyResult.index + 1;

        final int yyChoice1 = yyIndex;

        // Nested alternative 1.

        yyResult = pAggregateVariable(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$4 = yyResult.semanticValue();

          yyC = character(yyResult.index);
          if ('>' == yyC) {
            yyIndex = yyResult.index + 1;

            yyValue = GNode.create("Aggregate", v$g$3, v$g$4);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }

        // Nested alternative 2.

        yyResult = pPostfixExpression(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$5 = yyResult.semanticValue();

          yyC = character(yyResult.index);
          if ('>' == yyC) {
            yyIndex = yyResult.index + 1;

            yyValue = GNode.create("Aggregate", v$g$3, v$g$5);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("aggregate expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.AggregateVariable.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAggregateVariable(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <LocationVariable>.

    yyResult = pLocation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Variable>.

    yyResult = pVariable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal jol.lang.parse.Parser.Alias.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAlias(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVariable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":=")) {

        yyC = character(yyResult.index);
        if ('$' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pIntegerConstant(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("Alias", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("':=' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("alias expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    int        yyRepetition2;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }

            // Nested alternative 2.

            yyRepetition1 = yyChoice2;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '/':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;

              switch (yyC) {
              case '*':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    final int yyChoice2 = yyRepetition2;

                    // Nested alternative 1.

                    yyC = character(yyChoice2);
                    if (-1 != yyC) {
                      yyIndex = yyChoice2 + 1;

                      switch (yyC) {
                      case '*':
                        {
                          yyPredMatched = false;

                          yyC = character(yyIndex);
                          if ('/' == yyC) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyRepetition2 = yyIndex;
                            continue;
                          } else {
                            yyError = yyError.select("spacing expected", yyStart);
                          }
                        }
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  yyBase = yyRepetition2;
                  yyC    = character(yyBase);
                  if ('*' == yyC) {
                    yyIndex = yyRepetition2 + 1;

                    yyC = character(yyIndex);
                    if ('/' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyRepetition1 = yyIndex;
                      continue;
                    } else {
                      yyError = yyError.select("'*/' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("'*/' expected", yyBase);
                  }
                }
                break;

              case '/':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    yyC = character(yyRepetition2);
                    if (-1 != yyC) {
                      yyIndex = yyRepetition2 + 1;

                      switch (yyC) {
                      case '\n':
                      case '\r':
                        /* No match. */
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  final int yyChoice2 = yyRepetition2;

                  // Nested alternative 1.

                  yyC = character(yyChoice2);
                  if (-1 != yyC) {
                    yyIndex = yyChoice2 + 1;

                    switch (yyC) {
                    case '\r':
                      {
                        final int yyChoice3 = yyIndex;

                        // Nested alternative 1.

                        yyC = character(yyChoice3);
                        if ('\n' == yyC) {
                          yyIndex = yyChoice3 + 1;

                          yyRepetition1 = yyIndex;
                          continue;
                        }

                        // Nested alternative 2.

                        yyRepetition1 = yyChoice3;
                        continue;
                      }

                    case '\n':
                      {
                        yyRepetition1 = yyIndex;
                        continue;
                      }

                    default:
                      /* No match. */
                    }
                  }

                  // Nested alternative 2.

                  yyPredResult = pEndOfFile(yyChoice2);
                  yyError      = yyPredResult.select(yyError);
                  if (yyPredResult.hasValue()) {

                    yyRepetition1 = yyChoice2;
                    continue;
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Spacing.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("end of file expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.Symbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSymbol) 
      yyColumn.chunk2.fSymbol = pSymbol$1(yyStart);
    return yyColumn.chunk2.fSymbol;
  }

  /** Actually parse Symbol.Symbol. */
  private Result pSymbol$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbolCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Symbol.SymbolCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbolCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '>':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '>':
              {
                yyValue = ">>";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '=':
              {
                yyValue = ">=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = ">";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '<':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '<':
              {
                yyValue = "<<";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '=':
              {
                yyValue = "<=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "<";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '+':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "+=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '+':
              {
                yyValue = "++";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "+";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '-':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "-=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '-':
              {
                yyValue = "--";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "-";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '*':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "*=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "*";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '/':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "/=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "/";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '%':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "%=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "%";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '&':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "&=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '&':
              {
                yyValue = "&&";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "&";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '^':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "^=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "^";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '|':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "|=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '|':
              {
                yyValue = "||";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "|";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = "==";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '!':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "!=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "!";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case ':':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case ':':
              {
                yyValue = "::";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '=':
              {
                yyValue = ":=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '-':
              {
                yyValue = ":-";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = ":";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case ';':
        {
          yyValue = ";";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ',':
        {
          yyValue = ",";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '.':
        {
          yyValue = ".";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '{':
        {
          yyValue = "{";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = "(";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = ")";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = "[";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '~':
        {
          yyValue = "~";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '?':
        {
          yyValue = "?";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '#':
        {
          yyValue = "#";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '_':
        {
          yyValue = "_";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("symbol characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Name.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pName(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fName) 
      yyColumn.chunk2.fName = pName$1(yyStart);
    return yyColumn.chunk2.fName;
  }

  /** Actually parse Identifier.Name. */
  private Result pName$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (! contains(OVERLOG_KEYWORDS, toText(yyValue))) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWord(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fWord) 
      yyColumn.chunk2.fWord = pWord$1(yyStart);
    return yyColumn.chunk2.fWord;
  }

  /** Actually parse Identifier.Word. */
  private Result pWord$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWordCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.WordCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWordCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      final char start = (char)yyC;

      if (Character.isJavaIdentifierStart(start)) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            final char part = (char)yyC;

            if (Character.isJavaIdentifierPart(part)) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("word characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.EventModifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEventModifier(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('#' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pEventType(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("event modifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.EventType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEventType(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Insert>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("insert")) {
      yyValue = "insert";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Delete>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("delete")) {
      yyValue = "delete";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("event type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.TableName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTableName(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTableName) 
      yyColumn.chunk2.fTableName = pTableName$1(yyStart);
    return yyColumn.chunk2.fTableName;
  }

  /** Actually parse Identifier.TableName. */
  private Result pTableName$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("::")) {

        yyResult = pName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String name = yyResult.semanticValue();

          if (name.length() > 0 && Character.isLowerCase(name.charAt(0))) {

            yyValue = GNode.create("TableName", v$g$1, name);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("'::' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String name = yyResult.semanticValue();

      if (name.length() > 0 && Character.isLowerCase(name.charAt(0))) {

        yyValue = GNode.create("TableName", name);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("table name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Variable.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariable(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fVariable) 
      yyColumn.chunk2.fVariable = pVariable$1(yyStart);
    return yyColumn.chunk2.fVariable;
  }

  /** Actually parse Identifier.Variable. */
  private Result pVariable$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String name = yyResult.semanticValue();

      if (name.length() > 0 && Character.isUpperCase(name.charAt(0))) {

        yyValue = GNode.create("Variable", name);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("_")) {
      final String v$g$1 = "_";

      yyValue = GNode.create("Variable", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*")) {
      final String v$g$2 = "*";

      yyValue = GNode.create("Variable", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("variable expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Location.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocation(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fLocation) 
      yyColumn.chunk2.fLocation = pLocation$1(yyStart);
    return yyColumn.chunk2.fLocation;
  }

  /** Actually parse Identifier.Location. */
  private Result pLocation$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('@' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pVariable(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("Location", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("location expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fType) 
      yyColumn.chunk2.fType = pType$1(yyStart);
    return yyColumn.chunk2.fType;
  }

  /** Actually parse Identifier.Type. */
  private Result pType$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Type>.

    yyResult = pTypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pDimensions(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyResult = pSpacing(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("Type", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.TypeName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeName(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fTypeName) 
      yyColumn.chunk2.fTypeName = pTypeName$1(yyStart);
    return yyColumn.chunk2.fTypeName;
  }

  /** Actually parse Identifier.TypeName. */
  private Result pTypeName$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Basic>.

    yyResult = pPrimitiveType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Class>.

    yyResult = pClassType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.PrimitiveType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimitiveType(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Byte>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("byte")) {
      final String v$g$1 = "byte";

      yyValue = GNode.create("PrimitiveType", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Short>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("short")) {
      final String v$g$2 = "short";

      yyValue = GNode.create("PrimitiveType", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Char>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("char")) {
      final String v$g$3 = "char";

      yyValue = GNode.create("PrimitiveType", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <String>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("string")) {
      final String v$g$4 = "string";

      yyValue = GNode.create("PrimitiveType", v$g$4);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Int>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("int")) {
      final String v$g$5 = "int";

      yyValue = GNode.create("PrimitiveType", v$g$5);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Long>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("long")) {
      final String v$g$6 = "long";

      yyValue = GNode.create("PrimitiveType", v$g$6);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Float>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("float")) {
      final String v$g$7 = "float";

      yyValue = GNode.create("PrimitiveType", v$g$7);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Double>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("double")) {
      final String v$g$8 = "double";

      yyValue = GNode.create("PrimitiveType", v$g$8);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Boolean>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("boolean")) {
      final String v$g$9 = "boolean";

      yyValue = GNode.create("PrimitiveType", v$g$9);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("primitive type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.Dimensions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimensions(final int yyStart) throws IOException {
    int                   yyC;
    int                   yyIndex;
    int                   yyRepetition1;
    boolean               yyRepeated1;
    Pair<Pair<Character>> yyRepValue1;
    int                   yyRepetition2;
    Pair<Character>       yyRepValue2;
    Node                  yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyC = character(yyRepetition1);
      if ('[' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyRepetition2 = yyIndex;
        yyRepValue2   = Pair.empty();
        while (true) {

          yyC = character(yyRepetition2);
          if (-1 != yyC) {
            yyIndex = yyRepetition2 + 1;
            final char v$el$2 = (char)yyC;

            if (('0' <= v$el$2) && (v$el$2 <= '9')) {

              yyRepetition2 = yyIndex;
              yyRepValue2   = new Pair<Character>(v$el$2, yyRepValue2);
              continue;
            }
          }
          break;
        }
        { // Start scope for v$el$1.
          final Pair<Character> v$el$1 = yyRepValue2.reverse();

          yyC = character(yyRepetition2);
          if (']' == yyC) {
            yyIndex = yyRepetition2 + 1;

            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            yyRepValue1   = new Pair<Pair<Character>>(v$el$1, yyRepValue1);
            continue;
          }
        } // End scope for v$el$1.
      }
      break;
    }

    if (yyRepeated1) {
      final Pair<Pair<Character>> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.create("Dimensions", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("dimensions expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Identifier.ClassType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassType(final int yyStart) throws IOException {
    int          yyC;
    int          yyIndex;
    Result       yyResult;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Node         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyC = character(yyRepetition1);
        if ('.' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyResult = pName(yyIndex);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final String v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<String> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.create("ClassType", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    yyError = yyError.select("class type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.Constant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstant(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fConstant) 
      yyColumn.chunk2.fConstant = pConstant$1(yyStart);
    return yyColumn.chunk2.fConstant;
  }

  /** Actually parse Constant.Constant. */
  private Result pConstant$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloatConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pLongConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pIntegerConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pStringConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 5.

    yyResult = pNullConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 6.

    yyResult = pBooleanConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 7.

    yyResult = pInfinityConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 8.

    yyResult = pVector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 9.

    yyResult = pMatrix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.FloatConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatConstant(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fFloatConstant) 
      yyColumn.chunk3.fFloatConstant = pFloatConstant$1(yyStart);
    return yyColumn.chunk3.fFloatConstant;
  }

  /** Actually parse Constant.FloatConstant. */
  private Result pFloatConstant$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloatingPointString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("FloatConstant", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.FloatList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatList(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloatConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$l$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyC = character(yyRepetition1);
        if (',' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyResult = pFloatConstant(yyIndex);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        }
        break;
      }
      { // Start scope for v$l$2.
        final Pair<Node> v$l$2 = yyRepValue1.reverse();

        yyValue = new Pair<Node>(v$l$1, v$l$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$l$2.
    }

    // Done.
    yyError = yyError.select("float list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.FloatingPointString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatingPointString(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyC = character(yyRepetition1);
      if ('.' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyRepetition1 = yyIndex;
        yyRepeated1   = false;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              {
                yyRepetition1 = yyIndex;
                yyRepeated1   = true;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        if (yyRepeated1) {

          yyOption1  = yyRepetition1;

          yyResult = pExponent(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }


          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case 'D':
            case 'F':
            case 'd':
            case 'f':
              {
                yyOption1  = yyIndex;
              }

            default:
              /* No match. */
            }
          }

          yyValue = difference(yyStart, yyOption1);

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyOption1  = yyRepetition1;

        yyResult = pExponent(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }


        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'D':
          case 'F':
          case 'd':
          case 'f':
            {
              yyOption1  = yyIndex;
            }

          default:
            /* No match. */
          }
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 3.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyResult = pExponent(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;

        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'D':
          case 'F':
          case 'd':
          case 'f':
            {
              yyOption1  = yyIndex;
            }

          default:
            /* No match. */
          }
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }

      // Nested alternative 2.

      yyOption1  = yyChoice1;

      yyResult = pExponent(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'D':
        case 'F':
        case 'd':
        case 'f':
          {
            yyValue = difference(yyStart, yyIndex);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }
    }

    // Done.
    yyError = yyError.select("floating point string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.Exponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'E':
      case 'e':
        {
          yyOption1  = yyIndex;

          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case '+':
            case '-':
              {
                yyOption1  = yyIndex;
              }

            default:
              /* No match. */
            }
          }

          yyRepetition1 = yyOption1;
          yyRepeated1   = false;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                {
                  yyRepetition1 = yyIndex;
                  yyRepeated1   = true;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          if (yyRepeated1) {

            yyValue = null;

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("exponent expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.IntegerConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerConstant(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fIntegerConstant) 
      yyColumn.chunk3.fIntegerConstant = pIntegerConstant$1(yyStart);
    return yyColumn.chunk3.fIntegerConstant;
  }

  /** Actually parse Constant.IntegerConstant. */
  private Result pIntegerConstant$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pHexConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerConstant", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pDecimalConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerConstant", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.LongConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLongConstant(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDecimalConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyResult = pLongTypeSuffix(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("LongConstant", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.IntegerList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerList(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fIntegerList) 
      yyColumn.chunk3.fIntegerList = pIntegerList$1(yyStart);
    return yyColumn.chunk3.fIntegerList;
  }

  /** Actually parse Constant.IntegerList. */
  private Result pIntegerList$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntegerConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$l$1 = yyResult.semanticValue();

      yyResult = pIntegerList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$l$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$l$1, v$l$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal jol.lang.parse.Parser.IntegerList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerList$$Star1(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fIntegerList$$Star1) 
      yyColumn.chunk3.fIntegerList$$Star1 = pIntegerList$$Star1$1(yyStart);
    return yyColumn.chunk3.fIntegerList$$Star1;
  }

  /** Actually parse jol.lang.parse.Parser.IntegerList$$Star1. */
  private Result pIntegerList$$Star1$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (',' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pIntegerConstant(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pIntegerList$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.HexConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexConstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pHexNumeral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'I':
        case 'U':
          {
            yyOption1  = yyIndex;
          }

        default:
          /* No match. */
        }
      }

      yyValue = difference(yyStart, yyOption1);

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("hex constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.DecimalConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalConstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;

    yyC = character(yyOption1);
    if ('-' == yyC) {
      yyIndex = yyOption1 + 1;

      yyOption1  = yyIndex;
    }

    yyResult = pDecimalNumeral(yyOption1);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = difference(yyStart, yyResult.index);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("decimal constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.DecimalNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          yyValue = null;

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("decimal numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.HexNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (-1 != yyC) {
        yyIndex = yyIndex + 1;

        switch (yyC) {
        case 'X':
        case 'x':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = false;
            while (true) {

              yyC = character(yyRepetition1);
              if (-1 != yyC) {
                yyIndex = yyRepetition1 + 1;

                switch (yyC) {
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                case 'A':
                case 'B':
                case 'C':
                case 'D':
                case 'E':
                case 'F':
                case 'a':
                case 'b':
                case 'c':
                case 'd':
                case 'e':
                case 'f':
                  {
                    yyRepetition1 = yyIndex;
                    yyRepeated1   = true;
                    continue;
                  }

                default:
                  /* No match. */
                }
              }
              break;
            }

            if (yyRepeated1) {

              yyValue = null;

              return new SemanticValue(yyValue, yyRepetition1, yyError);
            }
          }
          break;

        default:
          /* No match. */
        }
      }
    }

    // Done.
    yyError = yyError.select("hex numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.LongTypeSuffix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLongTypeSuffix(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'L':
      case 'l':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("long type suffix expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.StringConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringConstant(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fStringConstant) 
      yyColumn.chunk3.fStringConstant = pStringConstant$1(yyStart);
    return yyColumn.chunk3.fStringConstant;
  }

  /** Actually parse Constant.StringConstant. */
  private Result pStringConstant$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCharacterSequence(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("StringConstant", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.CharacterSequence.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterSequence(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\\':
            {
              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;

                switch (yyC) {
                case '\"':
                case '\'':
                case '\\':
                case 'b':
                case 'f':
                case 'n':
                case 'r':
                case 't':
                  {
                    yyRepetition1 = yyIndex;
                    continue;
                  }

                default:
                  /* No match. */
                }
              }
            }
            break;

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\"':
          case '\\':
            /* No match. */
            break;

          default:
            {
              yyRepetition1 = yyIndex;
              continue;
            }
          }
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('\"' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("character sequence expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.BooleanConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBooleanConstant(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("true")) {
      final String v$g$1 = "true";

      yyValue = GNode.create("BooleanConstant", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("false")) {
      final String v$g$2 = "false";

      yyValue = GNode.create("BooleanConstant", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("boolean constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.InfinityConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInfinityConstant(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("infinity")) {

      yyValue = GNode.create("InfinityConstant", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("infinity constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.NullConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNullConstant(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("null")) {
      final String v$g$1 = "null";

      yyValue = GNode.create("NullConstant", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("null constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.Vector.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVector(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntVector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pFloatVector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.IntVector.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntVector(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fIntVector) 
      yyColumn.chunk3.fIntVector = pIntVector$1(yyStart);
    return yyColumn.chunk3.fIntVector;
  }

  /** Actually parse Constant.IntVector. */
  private Result pIntVector$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pIntegerList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("}")) {

          yyValue = GNode.create("IntVector", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("int vector expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.FloatVector.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatVector(final int yyStart) throws IOException {
    ParserColumn yyColumn = (ParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fFloatVector) 
      yyColumn.chunk3.fFloatVector = pFloatVector$1(yyStart);
    return yyColumn.chunk3.fFloatVector;
  }

  /** Actually parse Constant.FloatVector. */
  private Result pFloatVector$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pFloatList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("}")) {

          yyValue = GNode.create("FloatVector", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("float vector expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.Matrix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMatrix(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntMatrix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pFloatMatrix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.IntMatrix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntMatrix(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pIntMatrixEntries(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("}")) {

          yyValue = GNode.create("IntMatrix", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("int matrix expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.FloatMatrix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatMatrix(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pFloatMatrixEntries(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("}")) {

          yyValue = GNode.create("FloatMatrix", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("float matrix expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.IntMatrixEntries.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntMatrixEntries(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntVector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$l$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pIntVector(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$l$2.
        final Pair<Node> v$l$2 = yyRepValue1.reverse();

        yyValue = new Pair<Node>(v$l$1, v$l$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$l$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal Constant.FloatMatrixEntries.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatMatrixEntries(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloatVector(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$l$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pFloatVector(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$l$2.
        final Pair<Node> v$l$2 = yyRepValue1.reverse();

        yyValue = new Pair<Node>(v$l$1, v$l$2);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$l$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  static {
    add(OVERLOG_KEYWORDS, new String[] {
      "delete",
      "public",
      "async",
      "true",
      "false",
      "in",
      "infinity",
      "keys",
      "define",
      "timer",
      "load",
      "null",
      "watch"
    });
  }

  // =========================================================================

  /**
   * Get the specified text.
   *
   * @param s The text.
   * @return The text.
   */
  protected static final String toText(String s) {
    return s;
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
