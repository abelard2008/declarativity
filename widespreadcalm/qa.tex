%!TEX root = proposal.tex

Writing correct distributed systems is extremely challenging, in large part
because developers of such systems are forced to reason
about program behavior under all the combinations of message ordering and failure
that could occur in an execution.
In addition to the basic computation they wish to express, developers
must consider the enormous space of nondeterministic behaviors caused by 
asynchrony, concurrency and partial failure.

Two techniques are commonly used
to address this difficulty in practical systems: verification and testing.
Verification using formal methods typically involves writing a specification
that models the program's behavior, and systematically exploring the state 
space that can be reached in any execution.  Verification is an attractive 
approach because it can catch bugs that are very difficult to reproduce,
but it requires a high level of mathematical sophistication, both to write the 
specifications and to interpret tool feedback.
Hence formal verification is not widely adopted in practice.  
In contrast, programmers widely turn to \emph{testing} strategies to increase
their confidence that distributed code is correct.  Unlike formal methods, 
which typically require the entire system to be specified before providing 
feedback, program testing has very rapid returns.  A developer can write a 
small set of unit tests to ``bootstrap'' a new piece of functionality, then
incrementally add tests to better ``cover'' the space of expected program 
inputs.  Unfortunately, unit tests do a poor job of covering the space of
program \emph{behaviors} in a distributed system, which are highly
nondeterministic due to uncertainty about ordering and failures.

CALM provides a solid foundation for program analysis---monotonic programs
produce the same results in all executions---freeing programmers from reasoning
about nondeterminism in program executions.  Unfortunately, while languages
like Bloom make it easy to construct (and ``bless'') purely monotonic 
\emph{components}, completely monotonic \emph{systems} are rare in practice.
Nonmonotonic distributed programs---as the CALM Theorem asserts---may exhibit
inconsistencies (e.g., in the form of divergent replica state)
if they are not
properly \emph{coordinated} (e.g., by using a total order broadcast protocol
to eliminate nondeterminism in message delivery order).
While Bloom (inspired by the CALM Theorem) has static analysis capabilities
that can pinpoint program locations where coordination should be interposed
to ensure consistent outcomes, it offers little help confirming if a supplied
coordination protocol is actually correct.

To increase the programmer's confidence that Bloom programs are correct---including those
that are not completely monotonic---it is tempting to adopt a testing framework similar to those used with common
systems programming languages.  \jmh{I'm not clear if we succumb to this temptation or reject it in the following text.} We believe that Bloom's relational model,
high-level declarative language and static analysis capabilities will allow
us to improve many shortcomings in existing testing systems.  Some clear
advantages to this approach follow:

\begin{itemize}
\item At its heart, Bloom is a query language.  If we view the execution
of a module over some input as a database containing the trace of inputs and
outputs to that module, we can recast the difficult problem of correctness 
specifications into the easier problem of querying a database.  \jmh{Haven't intro'd BloomUnit yet.}  A BloomUnit
assertion is simply a query that compares module inputs, outputs, and timing
information.

\item Database systems use \emph{constraints} to characterize admissible 
database instances.  Inspired by recent work on lightweight formal methods and
model finding~\cite{jackson}, we are exploring using relational constraints 
to generate valid test inputs automatically.

\item Most importantly, the CALM Theorem implies that we can significantly
reduce the enormous space of executions (corresponding to different message
orderings) that must be searched to ensure that a distributed system satisfies
its correctness requirements.  For monotonic modules, all orderings produce
the same result, so we need only explore a single execution.  For hybrid
modules, we need only explore message reorderings for racing messages that
are bound for nonmonotonic processing at the receiver.

\end{itemize}



\subsection{Summary of Tasks and Goals}

We are currently developing the BloomUnit system, a quality assurance tool
for programs written in Bloom.  

\begin{itemize}
\item \textbf{Declarative assertions}.
BloomUnit users will write declarative test specifications that describe the 
intended input-output behavior of the program. These specifications will be 
written 
as Bloom queries over the (distributed) execution trace of the program; 
using Bloom avoids the need for users to learn another language. 
BloomUnit will allow ``pay as you go'' testing: a simple test specification 
is equivalent to a single test case, while a more complex test specification 
can encapsulate many different test cases.


\item \textbf{Constraint-guided input generation}
Rather than supplying concrete inputs for test specifications, users will 
instead 
specify the constraints that the input must satisfy; BloomUnit will then 
automatically generate inputs that are consistent with those constraints.

\item \textbf{CALM-based pruning of the state space}
BloomUnit will systematically explore the space of
possible network behaviors in an intelligent manner. To reduce the size of this space, we may again
leverage the CALM Theorem.
If we can recognize that certain code fragments are purely monotonic, it follows 
that they are insensitive to message delivery order.
Hence the evaluator may explore only those message delivery order permutations
that could have produced different outputs.
\end{itemize}

