%!TEX root = proposal.tex

To achieve consistency without using expensive distributed coordination, many
systems have proposed using a vocabulary of \emph{commutative},
\emph{associative}, and \emph{idempotent} operations
(e.g.,~\cite{dynamo,Reiher1994,bayou,quicksand}). This helps to ensure that the
replicas of a distributed object converge to the same final state (``eventual
consistency''), despite the message reordering and duplication that may occur in
an asynchronous network. Shapiro et al.\ recently proposed a formalism for these
approaches called \emph{Conflict-Free Replicated Data Types} (CRDTs), which
casts these ideas into the algebraic framework of
\emph{semilattices}~\cite{Shapiro2011a,Shapiro2011b}.

CALM analysis is more powerful than approaches that only consider the
convergence of individual objects or lattices: by analyzing both distributed
state and logic, CALM can ensure the consistency of the application's entire
state, rather than individual objects. However, the original formulation of the
CALM analysis only supported monotonic programs over sets, which causes the
analysis to fail for common constructs such as timestamps, versions, and
counters. Drawing inspiration from CRDTs, we are working to address this problem
by extending Bloom and CALM to support arbitrary lattices, rather than just the
set lattice.

\begin{figure}[t]
\begin{minipage}{.48\textwidth}
\begin{lstlisting}[caption=Quorum vote in Bloom (non-monotonic).,label=lst:bloom-quorum-set]
QUORUM_SIZE = 5
RESULT_ADDR = "example.org"

class QuorumVote
  include Bud

  state do
    channel :vote_chn, [:@addr, :voter_id]
    channel :result_chn, [:@addr]
    table   :votes, [:voter_id]
    scratch :cnt, [] => [:cnt]
  end

  bloom do
    votes      <= vote_chn {|v| [v.voter_id]}
    cnt        <= votes.group(nil, count(:voter_id)) (*\label{line:bloom-nm-quorum}*)
    result_chn <~ cnt {|c| [RESULT_ADDR] (*\label{line:bloom-quorum-msg-start}*)
                           if c >= QUORUM_SIZE} (*\label{line:bloom-quorum-msg-end}*)
  end
end
\end{lstlisting}
\end{minipage}
\begin{minipage}{.48\textwidth}
\begin{lstlisting}[caption=Quorum vote in \blooml (monotonic).,label=lst:bloom-quorum-lattice]
QUORUM_SIZE = 5
RESULT_ADDR = "example.org"

class QuorumVoteL
  include Bud

  state do
    channel :vote_chn, [:@addr, :voter_id]
    channel :result_chn, [:@addr]
    lset    :votes (*\label{line:quorum-lset-decl}*)
    lmax    :cnt
    lbool   :quorum_done
  end

  bloom do
    votes       <= vote_chn {|v| v.voter_id} (*\label{line:quorum-set-accum}*)
    cnt         <= votes.size (*\label{line:quorum-size}*)
    quorum_done <= cnt.gt_eq(QUORUM_SIZE) (*\label{line:quorum-threshold}*)
    result_chn  <~ quorum_done.when_true { (*\label{line:quorum-when-true-start}*)
                     [RESULT_ADDR]
                   } (*\label{line:quorum-when-true-end}*)
  end
end
\end{lstlisting}
\end{minipage}
\end{figure}

Listing~\ref{lst:bloom-quorum-set} contains a simple example where the CALM
analysis over sets produces unsatisfactory results. This program receives votes
from one or more clients (not shown) via the \texttt{vote\_chn} channel. Once at
least \texttt{QUORUM\_SIZE} votes have been received, a message is sent to a
remote node to indicate that quorum has been reached
(lines~\ref{line:bloom-quorum-msg-start}--\ref{line:bloom-quorum-msg-end}).

Intuitively, this program makes progress in a semantically monotonic fashion:
the set of received votes grows and the size of the \texttt{votes} collection
can only increase, so once a quorum has been reached it will never be
retracted. Unfortunately, the CALM analysis over sets would regard this program
as non-monotonic because of the grouping/aggregation operation on
line~\ref{line:bloom-nm-quorum}.

We have developed an initial prototype of \blooml, a version of the Bloom
language that supports programs over arbitrary
lattices~\cite{bloom-lattice-tr}. Listing~\ref{lst:bloom-quorum-lattice}
contains a version of the quorum voting program implemented using
\blooml. Rather than being limited to monotonically growing sets, this version
of quorum voting uses three different lattices: a \texttt{set} lattice (to hold
the set of votes received), a \texttt{max} lattice representing an increasing
counter (to count the number of votes), and a \texttt{bool} lattice representing
a threshold test (to check for reaching quorum). Note that all three lattices
``grow'' over time, but according to different notions of growth (set
containment, increasing integers, and movement from False to True,
respectively). The key advantage of \blooml compared with CRDTs is that \blooml
allows \emph{safe} mappings between lattices via monotone functions. For
example, \texttt{size} is a monotone function from the \texttt{set} lattice to
the \texttt{max} lattice; as a set increases (according to set containment), the
\texttt{size} of the set will increase numerically. Monotone functions allow
complex applications to be safely \emph{composed} from a collection of simple
lattice types.

Our initial \blooml prototype has yielded promising results: for example, we
have used \blooml to build a simple Dynamo-style KVS that supports version
vectors and quorum replication. Not only is our KVS orders of magnitude more
concise than traditional KVS implementations, it has clear semantics because it
consists of the straightforward composition (via monotone functions) of a
collection of simple lattices. Our \blooml prototype also performs comparably to
the original Bloom runtime, in part because we generalized a well-known
evaluation strategy from logic programming~\cite{Balbin1987} to work over
lattices rather than just sets~\cite{bloom-lattice-tr}.

Nevertheless, many challenges and open questions remain. We are currently
pursuing the following ideas:
\begin{itemize}
\item \textbf{Distributed Garbage Collection:} Many distributed systems
  accumulate state that can eventually be reclaimed. For example, a vector clock
  in a dynamic system will eventually contain many entries for nodes that have
  subsequently left the system. In general, doing distributed garbage collection
  requires consensus; hence, such operations would be flagged as non-monotonic
  by the CALM analysis.

  A common pattern is to do distributed garbage collection as a background
  operation. Because application functionality does not block on achieving
  consensus, this avoids much of the operational concern associated with
  deploying consensus protocols at scale; this pattern is often called ``weak''
  or ``lazy'' consensus.

  We are working on providing language support for this pattern using
  \blooml. Intuitively, a datum can be reclaimed once it is no longer needed by
  any member of the system---this can be formalized as reclaiming objects that
  fall below the greatest lower bound of all the replicas of a \jmh{finish me.}

\item \textbf{Controlled Non-Determinism:} Thus far, we have primarily been
  interested in analysis techniques for deterministic distributed
  programs. While this is often desirable (e.g., determinism implies eventual
  consistency), certain popular protocols are intentionally
  non-deterministic. For example, a two-phase commit protocol might choose to
  abort a transaction if a response hasn't been received from a participant
  within a configured time bound. Although this exhibits a race condition
  (between receiving a slow response and exceeding the time bound), this is
  intended: in this situation, the programmer uses non-determinism to select
  from two acceptable outcomes.  \jmh{Expand a bit and connect to lattices.}

\item \textbf{Evaluations:} To validate that \blooml is useful for building
  practical distributed programs, we are exploring several different application
  domains. In particular, we are exploring how \blooml can be used to build
  collaborate editing systems.  \jmh{Expand on the challenges here, perhaps invoke the scope dillemma.}

  We are also working on building out the KVS prototype mentioned above into a
  complete distributed storage system.  \jmh{Expand on challenges here, perhaps connect to Peter's stuff.}
\end{itemize}

% \jmh{Intro paragraph.}
% \begin{itemize}
% \item Crib motivation from VLDB submission, shortening the CRDT and Bloom background and moving straight to the idea of solving the type dilemma (as discussed in Intro) by merging them. (Cite Ross/Sagiv along the way.)
% \item Discuss the idea of extending Bloom logic programming and CALM analysis to disorderly programs over arbitrary lattices. Say we've got an initial prototype of BloomL -- can cite TR if we like.
% \item Give an example of a Bloom rule over sets and a corresponding rule over lmaxes.  
% \item Discuss mappings, commutative functions and homomorphisms.  Impact on CALM and delta computation.
% \item Show the vector clock example in a box.
% \item Challenge: proving lattice properties. Possible conservative analysis in a nice imperative language, or a subsetted DSL within such a language., 
% \item Challenge: Lattices and efficiency: garbage collection and lower bounds
% \item Challenge: Lattices and non-monotonicity: e.g. ``odometer'' compositions, etc.
% \end{itemize}

\subsection{Summary of Tasks and Goals}
\jmh{Revisit in light of Neil's text.}

\begin{itemize}
\item \textbf{Efficient Evaluation of Lattice programs}.  \jmh{Sentence or 2 here on Lower bounds, zero-copy, etc.}
\item \textbf{Tools for guaranteed lattice properties}.  \jmh{Sentence or two here on a possible DSL agenda, perhaps subsetting some existing language like Scala.  Remind that scope can be small because so much can be done outside the DSL in BloomL via lattice composition (e.g. data structures).}
\item \textbf{Extend the Bloom prototype to support rich set of built-in for composition.}  \jmh{Sentence or two here on what's involved, including language design and evaluation.  Say we've got a first prototype, and highlight remaining challenges.}.
\item \textbf{Evaluations: KVSs and Collaborative Editors.}  \jmh{Sentence or two here pitching the challenge here, and sketching some milestones/metrics for success}.
\end{itemize}