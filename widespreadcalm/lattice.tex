%!TEX root = proposal.tex
To achieve consistency without using expensive distributed coordination, many
systems have proposed using a vocabulary of \emph{commutative} operations
(e.g.,~\cite{dynamo,Reiher1994,bayou}); this allows the replicas of a distributed
object to process events in different orders and converge to the same final
state. Shapiro et al.\ recently proposed a formalism for these approaches called
\emph{Conflict-Free Replicated Data Types} (CRDTs), which casts these ideas into
the algebraic framework of \emph{semilattices}~\cite{Shapiro2011a,Shapiro2011b}.

CALM analysis is more powerful than approaches that only consider the
convergence of individual objects or lattices: by analyzing both distributed
state and logic, CALM can ensure the consistency of the application's entire
state, rather than individual objects. However, the original formulation of the
CALM analysis only supported monotonic programs over sets (that is, programs
that compute larger sets of facts over time). This prevents the CALM analysis
for supporting several common patterns in weakly consistent distributed
programming, including timestamps, versions, counters, and threshold
tests. Drawing inspiration from CRDTs, we are working to extend Bloom and CALM
to support arbitrary lattices, rather than just the set lattice.

\begin{figure}[t]
\begin{minipage}{.48\textwidth}
\begin{lstlisting}[caption=Quorum vote in Bloom (non-monotonic).,label=lst:bloom-quorum-set]
QUORUM_SIZE = 5
RESULT_ADDR = "example.org"

class QuorumVote
  include Bud

  state do
    channel :vote_chn, [:@addr, :voter_id]
    channel :result_chn, [:@addr]
    table   :votes, [:voter_id]
    scratch :cnt, [] => [:cnt]
  end

  bloom do
    votes      <= vote_chn {|v| [v.voter_id]}
    cnt        <= votes.group(nil, count(:voter_id)) (*\label{line:bloom-nm-quorum}*)
    result_chn <~ cnt {|c| [RESULT_ADDR] (*\label{line:bloom-quorum-msg-start}*)
                           if c >= QUORUM_SIZE} (*\label{line:bloom-quorum-msg-end}*)
  end
end
\end{lstlisting}
\end{minipage}
\begin{minipage}{.48\textwidth}
\begin{lstlisting}[caption=Quorum vote in \blooml (monotonic).,label=lst:bloom-quorum-lattice]
QUORUM_SIZE = 5
RESULT_ADDR = "example.org"

class QuorumVoteL
  include Bud

  state do
    channel :vote_chn, [:@addr, :voter_id]
    channel :result_chn, [:@addr]
    lset    :votes (*\label{line:quorum-lset-decl}*)
    lmax    :cnt
    lbool   :quorum_done
  end

  bloom do
    votes       <= vote_chn {|v| v.voter_id} (*\label{line:quorum-set-accum}*)
    cnt         <= votes.size (*\label{line:quorum-size}*)
    quorum_done <= cnt.gt_eq(QUORUM_SIZE) (*\label{line:quorum-threshold}*)
    result_chn  <~ quorum_done.when_true { (*\label{line:quorum-when-true-start}*)
                     [RESULT_ADDR]
                   } (*\label{line:quorum-when-true-end}*)
  end
end
\end{lstlisting}
\end{minipage}
\end{figure}

Listing~\ref{lst:bloom-quorum-set} contains a simple example where the CALM
analysis over sets produces unsatisfactory results. This program receives votes
from one or more clients (not shown) via the \texttt{vote\_chn} channel. Once at
least \texttt{QUORUM\_SIZE} votes have been received, a message is sent to a
remote node to indicate that quorum has been reached
(lines~\ref{line:bloom-quorum-msg-start}--\ref{line:bloom-quorum-msg-end}).

Intuitively, this program makes progress in a semantically monotonic fashion:
the set of received votes grows and the size of the \texttt{votes} collection
can only increase, so once a quorum has been reached it will never be
retracted. Unfortunately, the CALM analysis over sets would regard this program
as non-monotonic because of the grouping/aggregation operation on
line~\ref{line:bloom-nm-quorum}.

We have developed an initial prototype of \blooml, a version of the Bloom
language and runtime that has been extended to support programs over arbitrary
lattices~\cite{bloom-lattice-tr}. Listing~\ref{lst:bloom-quorum-lattice}
contains a version of the quorum voting program implemented using
\blooml. Rather than being limited to monotonically growing sets, this version
of quorum voting uses three different lattices: a \texttt{set} lattice (to hold
the set of votes received), a \texttt{max} lattice representing an increasing
counter (to count the number of votes), and a \texttt{bool} lattice representing
a threshold test that

\jmh{Intro paragraph.}
\begin{itemize}
\item Crib motivation from VLDB submission, shortening the CRDT and Bloom background and moving straight to the idea of solving the type dilemma (as discussed in Intro) by merging them. (Cite Ross/Sagiv along the way.)
\item Discuss the idea of extending Bloom logic programming and CALM analysis to disorderly programs over arbitrary lattices. Say we've got an initial prototype of BloomL -- can cite TR if we like.
\item Give an example of a Bloom rule over sets and a corresponding rule over lmaxes.  
\item Discuss mappings, commutative functions and homomorphisms.  Impact on CALM and delta computation.
\item Show the vector clock example in a box.
\item Challenge: proving lattice properties. Possible conservative analysis in a nice imperative language, or a subsetted DSL within such a language., 
\item Challenge: Lattices and efficiency: garbage collection and lower bounds
\item Challenge: Lattices and non-monotonicity: e.g. ``odometer'' compositions, etc.
\end{itemize}

\subsection{Summary of Tasks and Goals}
\begin{itemize}
\item \textbf{Efficient Evaluation of Lattice programs}.  \jmh{Sentence or 2 here on Lower bounds, zero-copy, etc.}
\item \textbf{Tools for guaranteed lattice properties}.  \jmh{Sentence or two here on a possible DSL agenda, perhaps subsetting some existing language like Scala.  Remind that scope can be small because so much can be done outside the DSL in BloomL via lattice composition (e.g. data structures).}
\item \textbf{Extend the Bloom prototype to support rich set of built-in for composition.}  \jmh{Sentence or two here on what's involved, including language design and evaluation.  Say we've got a first prototype, and highlight remaining challenges.}.
\item \textbf{Evaluations: KVSs and Collaborative Editors.}  \jmh{Sentence or two here pitching the challenge here, and sketching some milestones/metrics for success}.
\end{itemize}