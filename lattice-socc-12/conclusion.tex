\pagebreak
\section{Conclusion}
In this paper, we proposed \lang, a distributed variant of Datalog that extends
logic programming with join semilattices. \lang is particularly valuable for
enabling coordination-free, consistent distributed programming, overcoming key
hurdles in prior work.  Like convergent module proposals, it allows
application-specific notions of ``progress'' to be represented as lattices, and
goes further to enabling safe mappings between lattices.  \lang improves upon
our own earlier work by expanding the space of recognizably monotonic programs,
enabling more programs to be verified as confluent by the CALM analysis.  In
addition to providing richer semantic guarantees than previous approaches, in
our experience \lang provides a natural and straightforward language for
implementing distributed systems.

\begin{comment}
\jmh{Some thoughts here to start.  More work this afternoon.}

Looking back:
\begin{itemize}
  \item \textbf{CALM Chills Out, and Distributed Programming wins!} The ability to prove confluence for a much broader range of constructs cracks one of the big remaining nuts in the Bloom agenda.  By marrying logic and lattices, it significantly advances the agenda delivering powerful, safe next-generation distributed languages.
  
  \item \textbf{Bloom programming is real nice now}:  The idea of using logic was to give us ``disorderly'' distributed programming a la MapReduce and SQL.  The convergent module approach went after the same goal from a more imperative perspective---``safe'' objects.  Both have their merits.  \lang's roots in logic still encourage set-wise, disorderly thinking, and the core construct of joining streams of events/messages with collections of stored facts is a nice way to capture asynchronous programming.  But stuff like counters are so very natural...
\end{itemize}

Looking forward:
\begin{itemize}
  \item \textbf{What more can we prove?}  Confluence is great when you can get it.  Checking for barrier-monotonicity is one nice thing for non-confluent designs.  But what more might we be able to do?
  \item \textbf{Efficiency and Optimization.}  Shopping carts still come in multiple flavors, but lattices start to smear the difference.  Is there hope for automatic program transformations in the \lang context that can tune an implementation optimally to workloads and elastic conditions?  What do the constraints of \lang provide that makes this question easier to tackle than a traditional imperative language?
  \item \textbf{Transactions.}  What about transactions, anyway?  If we want to provide transactional guarantees, how can \lang help---in terms of program specification, checking and optimization.
  \item \textbf{Your agenda goes here.}
\end{itemize}
\end{comment}
