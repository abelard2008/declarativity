\documentclass{sig-alternate}
\usepackage{color}
\usepackage{graphicx}
\usepackage{url}
\usepackage{balance}  % for  \balance command ON LAST PAGE  (only there!)
\usepackage{xspace}
\usepackage[T1]{fontenc}
\usepackage{times}
%\usepackage{mathptmx}    % use "times" font, including for math mode
\usepackage{txfonts}  % apparently needed to fixup the formatting of lstlistings
\usepackage{textcomp}
\usepackage[protrusion=true,expansion=true]{microtype}
\usepackage{paralist}
\usepackage{comment}

\frenchspacing

\usepackage{listings}
\lstset{
basicstyle=\ttfamily\scriptsize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\ttfamily,      % the size of the fonts that are used for the line-numbers
%aboveskip=0pt,
%belowskip=0pt,
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
%numbersep=10pt,                  % how far the line-numbers are from the code
breakindent=0pt,
firstnumber=1,
%backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=leftline,
tabsize=2,  		% sets default tabsize to 2 spaces
captionpos=b,   		% sets the caption-position to bottom
breaklines=false,    	% sets automatic line breaking
breakatwhitespace=true,    % sets if automatic breaks should only happen at whitespace
columns=fixed,
basewidth=0.52em,
xleftmargin=6mm,
xrightmargin=-6mm,
numberblanklines=false,
language=Ruby,
morekeywords={table,scratch,channel,interface,periodic,bloom,state,bootstrap,morph,monotone,lset,lbool,lmax,lmap},
escapeinside={(*}{*)}
}

\def\lang{Bloom$^L$\xspace}

%  \newcommand{\nrc}[1]{{\textcolor{magenta}{#1 -- nrc}}}
%  \newcommand{\paa}[1]{{\textcolor{blue}{[[#1 -- paa]]}}}

% % \newcommand{\wrm}[1]{{\textcolor{blue}{#1 -- wrm}}}
% \newcommand{\jmh}[1]{{\textcolor{red}{#1 -- jmh}}}

\newtheorem{example}{Example}

\begin{document}

\title{Logic and Lattices for Distributed Programming}

\numberofauthors{5}

\author{
\alignauthor
Neil Conway\\
       \affaddr{UC Berkeley}\\
       \email{nrc@cs.berkeley.edu}
\alignauthor
William R.\ Marczak\\
       \affaddr{UC Berkeley}\\
       \email{wrm@cs.berkeley.edu}
\alignauthor
Peter Alvaro\\
       \affaddr{UC Berkeley}\\
       \email{palvaro@cs.berkeley.edu}
\and
\alignauthor
Joseph M.\ Hellerstein\\
       \affaddr{UC Berkeley}\\
       \email{hellerstein@cs.berkeley.edu}
\alignauthor
David Maier\\
       \affaddr{Portland State University}\\
       \email{maier@cs.pdx.edu}
}

\maketitle

\begin{abstract}
  In recent years there has been interest in achieving application-level
  consistency criteria without the latency and availability costs of strongly
  consistent storage infrastructure. A standard technique
  %, found in designs such
  % as Bayou, Escrow Transactions, and CRDTs, 
  is to adopt a vocabulary of
  commutative operations; this avoids the risk of inconsistency due to message
  reordering.  A more powerful approach was recently captured by the \emph{CALM
    theorem}, which proves that logically monotonic programs are guaranteed to
  be eventually consistent. 
  In logic languages such as Bloom, CALM analysis can automatically verify that program modules achieve consistency without coordination.

  In this paper we present \lang, an extension to Bloom that takes inspiration
  from both these traditions.  
  % Drawing on systems that use commutative
  %   operations, \lang guarantees convergence for user-defined objects by adopting
  %   the notion of extensible \emph{lattice} data types: classes with a commutative
  %   and associative merge function.  
  \lang generalizes Bloom to support lattices
  and extends the power of CALM analysis to whole programs containing arbitrary
  lattices. We show how the Bloom interpreter can be generalized to support
  efficient evaluation of lattice-based code using well-known strategies from
  logic programming.  Finally, we use \lang to develop several practical
  distributed programs, including a key-value store similar to Amazon Dynamo,
  and show how \lang encourages the safe composition of small, easy-to-analyze
  lattices into larger programs.
\end{abstract}

\input{intro}
\input{background}
\input{lang}
\input{impl}
\input{kvs-case}
\input{cart-case}
\input{relwork}
\input{discussion}
\input{conclusion}
%\input{causal}
%\input{acks}

\newpage
\balance
\bibliographystyle{abbrv}
\bibliography{socc}

% \newpage
% \begin{appendix}
% \input{appendix}
% \end{appendix}

\end{document}
