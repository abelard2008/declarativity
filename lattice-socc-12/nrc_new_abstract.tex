\documentclass{sig-alternate-10pt}
\usepackage{color}
\usepackage{graphicx}
\usepackage{url}
\usepackage{balance}  % for  \balance command ON LAST PAGE  (only there!)
\usepackage{xspace}
\usepackage[T1]{fontenc}
\usepackage{times}
%\usepackage{mathptmx}    % use "times" font, including for math mode
\usepackage{txfonts}  % apparently needed to fixup the formatting of lstlistings
\usepackage{textcomp}
\usepackage[protrusion=true,expansion=true]{microtype}
\usepackage{paralist}
\usepackage{comment}

\frenchspacing

\usepackage{listings}
\lstset{
basicstyle=\ttfamily\scriptsize,       % the size of the fonts that are used for the code
numbers=left,                   % where to put the line-numbers
numberstyle=\ttfamily,      % the size of the fonts that are used for the line-numbers
%aboveskip=0pt,
%belowskip=0pt,
stepnumber=1,                   % the step between two line-numbers. If it is 1 each line will be numbered
%numbersep=10pt,                  % how far the line-numbers are from the code
breakindent=0pt,
firstnumber=1,
%backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=leftline,
tabsize=2,  		% sets default tabsize to 2 spaces
captionpos=b,   		% sets the caption-position to bottom
breaklines=false,    	% sets automatic line breaking
breakatwhitespace=true,    % sets if automatic breaks should only happen at whitespace
columns=fixed,
basewidth=0.52em,
xleftmargin=6mm,
xrightmargin=-6mm,
numberblanklines=false,
language=Ruby,
morekeywords={table,scratch,channel,interface,periodic,bloom,state,bootstrap,morph,monotone,lset,lbool,lmax,lmap},
escapeinside={(*}{*)}
}

\def\lang{Bloom$^L$\xspace}

% \newcommand{\nrc}[1]{{\textcolor{magenta}{#1 -- nrc}}}
% \newcommand{\wrm}[1]{{\textcolor{blue}{#1 -- wrm}}}
% \newcommand{\jmh}[1]{{\textcolor{red}{#1 -- jmh}}}

\begin{document}

\title{Logic and Lattices for Distributed Programming}

\numberofauthors{5}

\author{
\alignauthor
Neil Conway\\
       \affaddr{UC Berkeley}\\
       \email{nrc@cs.berkeley.edu}
\alignauthor
William R.\ Marczak\\
       \affaddr{UC Berkeley}\\
       \email{wrm@cs.berkeley.edu}
\alignauthor
Peter Alvaro\\
       \affaddr{UC Berkeley}\\
       \email{palvaro@cs.berkeley.edu}
\and
\alignauthor
Joseph M.\ Hellerstein\\
       \affaddr{UC Berkeley}\\
       \email{hellerstein@cs.berkeley.edu}
\alignauthor
David Maier\\
       \affaddr{Portland State University}\\
       \email{maier@cs.pdx.edu}
}

\maketitle

\begin{abstract}
  At large scale, protocols for achieving strong consistency are increasingly
  avoided because of their perceived latency and availability costs. Hence,
  several approaches for simplifying the development of weakly consistent
  programs have recently been proposed---in particular, Conflict-free Replicated
  Data Types (CRDTs) and monotonic logic.

  In the CRDT approach, programmers develop abstract data types whose public
  methods are commutative. While this ensures that individual values converge to
  a consistent final state, it does not address the mutual consistency of
  different replicated values.

  In monotonic logic, developers write declarative rules that compute sets of
  facts that grow over time. This enables a simple whole-program analysis: if
  the program consists only of monotonic logic, the final state of the program
  will be invariant to message reordering. However, this analysis is very
  conservative---many useful constructs, including counters, timestamps, and
  sequence numbers, cannot be represented as monotonically increasing sets.

  In this paper, we combine these two approaches to allow monotonic programs to
  be written over arbitrary lattices, rather than only over the set lattice. We
  realize this approach in \lang, a distributed Datalog variant that allows both
  set-oriented and lattice-oriented computations. We show how to implement
  lattice-based code efficiently, in the style of semi-naive evaluation.
  Finally, we use \lang to develop several practical distributed programs,
  including a key-value store similar to Amazon Dynamo.

  % Monotonic logic has recently been identified as a useful building block for
  % consistent distributed programs because it allows eventual consistency without
  % the need for coordination. However, many common distributed programs cannot
  % naturally be expressed as monotonic programs over sets. We present \lang, a
  % variant of Datalog that allows monotonic programs to use arbitrary lattice
  % structures, not just the set lattice. The ability to use multiple lattices
  % allows \lang to verify a much wider range of programs as monotonic and hence
  % eventually consistent.  We show how to implement lattice-based code
  % efficiently, in the style of semi-naive evaluation. Finally, we show how \lang
  % can be used to implement practical distributed programs.
\end{abstract}

\input{intro}
\input{background}
\input{lang}
\input{impl}
\input{carts}
\input{causal}
\input{relwork}
\input{discussion}
\input{conclusion}
%\input{acks}

\balance
\begin{small}
\bibliographystyle{abbrv}
\bibliography{socc}
\end{small}

% \newpage
% \begin{appendix}
% \input{appendix}
% \end{appendix}

\end{document}
