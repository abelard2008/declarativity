\section{Case Study: Shopping Carts}

In this section, we build an app with replicated state, and reason about the degree to which
it is ``eventually consistent.''

\subsection{Eventual Consistency}

In common usage, a system with replicated state is considered to be ``eventually consistent'' 
if the following conditions are met:

\begin{enumerate}
\item Replication is \emph{asynchronous}, in that servers and clients do not wait until global consistency is established.  It follows from this requirement that such systems are ``coordination-free,'' as in general coordination entails synchrony. 
\item If at some time messaging quiesces and all messages are delivered, all replicas will have the same state.
\end{enumerate}

\subsection{Straw Man}

\begin{Dedalus}
persist[status, 3, del_status];
r1
status(Location, Session, CartObj) :-
    cart_update(Location,  Session, CartObj);
    
r2
del_status(L, S, _) :-
    status(L, U, S, C),
    cart_update(L, U, S, _);

response(#Client, Loc, Session, CartObj) :-
    status(#Loc, Session, CartObj),
    request(#Loc, Client, User, Session)

// client code

cart_update(L, S, C)@async :- 
    update_event(L, S, C);

\end{Dedalus}

The simplest imaginable shopping cart implementation behaves like a key-value store,
and treats the cart as an opaque object that is repeatedly updated.  

Before we address the whether messages bound for the shopping cart server commute 
with one another, we must address a subtle bug in the implementation.  Because {\em cart\_update}
messages are sent over the network, we know that they appear in the head of an asynchronous 
rule in the global program, and hence it is impossible to predict the assignment of timestamps
to deduced tuples.  Even if the client deduces {\em cart\_update} tuples in a serial manner, it
is possible for multiple tuples to appear at the receiver in the same timestep \wrm{in other words, associativity}.  Thus rules {\em r1} 
and {\em r2}, which appear to describe how a single tuple in {\em status} representing a user
session is updated when a tuple in {\em cart\_update} appears, may cause multiple records
to appear in {\em status} for the same session (a violation of the implied primary key).
To mitigate this bug, we must ensure that exactly one tuple (per session) is available for dequeue
from {\em cart\_update} at any time.  The \emph{queue} template presented in section ?? 
provides this capability.

A simple syntactic analysis of the above program shows that {\em status} 
is temporally but not syntactically stratifiable \wrm{i don't think we need to say ``not syntactically stratifiable'', or provide hte rest of the sentence, we explained persistence earlier}: the deletion rule and the expansion of the
persistence template define {\em status} in terms of its own negation (in time).  The ``latest''
such tuple ``wins;'' thus clearly {\em cart\_update} tuples do not commute with each other,
and the program as given is unlikely to return the correct version of the cart in a {\em response}
message.

The difficult is precisely that the intended order corresponding to the serial order of updates
at the client, while reflected in the assignment of timestamps to tuples from the client's
local clock \wrm{this is confusing me, the problem is precisely because the order is not reflected in cart\_update tuples}, is lost in the asynchronous derivations of {\em cart\_update}.  By \emph{entangling}
the sender's time in rule  {\em r4}, we may communicate the desired total order over 
the {\em cart\_update} tuples and process them in that order.  \wrm{well, if we assume that the order of the body tuples captures the order we want}

\begin{Dedalus}
queue[cart_update, 4, 3];
\wrm{is queue a min queue by default? maybe we should name it ``min_queue''}
persist[status, 3, del_status];
r1
status(Location, Session, CartObj) :-
    cart_update(Location,  Session, CartObj, _);
    
r2
del_status(L, S, _) :-
    status(L, U, S, C),
    cart_update(L, U, S, _);

response(#Client, Loc, Session, CartObj) :-
    status(#Loc, Session, CartObj),
    request(#Loc, Client, User, Session)

// client code
r4
cart_update_queue(L, S, C, N)@async :- 
    update_event(L, S, C)@N;

\end{Dedalus}

\subsection{ACID 2.0}

Helland and others have advocated the design strategy of ensuring eventually-consistent 
semantics for replicated state by enforcing high-level algebraic 
properties in the application logic (in particular, commutativity, associativity and 
idempotence) rather than attempting to provide a RW storage substrate that can provide
such guarantees in general~\cite{quicksand, beyond}.  While Dynamo~\cite{dynamo} 
is a RW storage system
and as such needs to provide versioning and conflict resolution capabilities, the shopping
cart application that sits atop it is able to easily reconcile conflicts that occur due to inconsistency of global state, because the application logic is fundamentally order-insensitive.
The final state of the shopping cart is guaranteed to be the union of all the operations on
that state.  In the case of Dynamo, the application logic and not the storage system controls
cart merging logic.

Following this reasoning, if our implementation in \lang could be altered in such a way that
{\em cart\_update} tuples commute with one another,  we could dispense with the total
ordering of tuples.  Instead of replacing the opaque object as a read/write system would,
we'd like to expose the (fundamentally commutative) operation of cart-union to distributed
system.

\begin{Dedalus}
persist[cart_action, 5, _];
action_cnt(Location, Session, Item, Type, count<ReqId>) :-
    cart_action(Location, Client, Session, Item, Type, ReqId),
    checkout(Location, Client, Session);

status(L, Session, Item, Cnt) :-
    action_cnt(L, Session, Item, "Add", Cnt),
    notin action_cnt(L, Session, Item, "Del", _);

status(L, User, Session, Item, Acnt - Dcnt) :-
    action_cnt(L, Session, Item, "Add", Acnt),
    action_cnt(L, Session, Item, "Del", Dcnt);

commitfirst[log, 5, 4];
log(L, Session, Item, Cnt) :- 
    status(L, User, Session, Item, Cnt);

publish(#Client, Session, Item, Amt)@async :-
    log_event(#Location, Session, Item, Amt),
    checkout(#Location, Client, Session);

cart_action(#R, S, I, T, Ri)@async :-
    cart_action(#L, S, I, T, Ri),
    replicas(#L, S, R);
\end{Dedalus}


... and the client code, just to have it all in here:

\begin{Dedalus}
commitfirst[publish, 4, 3];

sequence[s, cart_action_stage, 5];
cart_action_stage(#Server, Client, Session, Item, Type, ReqId) :-
    action(#Client, Session, Type, ReqId),
    best_replica(#Client, Session, Server);
    s(ReqId);

cart_action(#L, S, I, T, R)@async :- 
    cart_action_stage(L, #C, S, I, T, R);

checkout(#Server, Client, Session) :-
    checkout_req(#Client, Session),
    best_replica(#Client, Session, Server);
\end{Dedalus}


