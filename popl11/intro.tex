\section{Introduction}

Distributed logic languages \wrm{cite stuff here, to make it clear that what we mean by a ``distributed logic language'' are the following instances of prior work} promise to significantly raise the level of
abstraction at which distributed systems are currently implemented, allowing
programmers to specify systems as a set of invariants over local state,
\wrm{okay, maybe say ``commonly'' or ``one popular design choice'' or something before ``these languages allow programs to specify systems as invariants over local state and rules that describe how state changes and moves across a network,'' because i think we all would consider something to be a distributed logic language that defines invariants over global or remote state}
%% \wrm{local isn't important, it's just a design choice of dedalus}
and rules that describe how state changes and moves across a network. 
%%\wrm{again this detail isn't important, it's just a design choice of dedalus}.  
This approach leads to succinct, executable specifications whose faithfulness to the original pseudocode may be visually verified.
%% \wrm{well...}.  
Moreover, many 
distributed logic languages are extensions of first-order logic enhanced with
a {\em least fixpoint operator}, which lends itself to powerful
formal verification techniques~\cite{wang, wang2}.

We conjecture that logic languages are a better fit for the specification of concurrent and distributed systems than traditional imperative approaches.  In imperative languages, whose instructions are built up from applications of a sequencing primitive and whose state is commonly stored in data structures like lists and trees, ordering is implicit and ubiquitous, 
while concurrency is achieved by duplicating the sequential control structures and allowing them
to run in an interleaved fashion.
%\wrm{what about concurrent data structures?  maybe we cut the ``concurrency is achieved...'' and replace it with ``the programmer must take specific steps to achieve concurrency''}.   whoops -- thought you said "data structures" instead of "control structures"
In contrast, declarative language constructs, built up from the implication primitive and abstracting program state into relations, are in general order-independent, forcing the programmer to explicitly reason about ordering of data elements or operations, but in return allowing a high degree of concurrency and often ``embarrassing'' 
parallelism~\cite{podskey}.  Instead of reasoning about the possible interleavings of sequential
instructions or the serial order of message arrival as one must when writing threaded or 
event-driven code, respectively, a distributed logic language allows the programmer to focus
on the admissible, atomic transformations over state that can in general be carried out in
parallel.  This inversion of concerns -- implicit concurrency and explicit order, instead of
implicit order and explicit concurrency -- can both ease the programmer's cognitive burden as
concurrency and parallelism increase, and help to highlight the hopefully few (but critical) 
portions of a distributed algorithm for which order is essential to correctness. 



In recent years, there has been a resurgence of interest in Datalog as
the foundation for applied, domain-specific languages in a wide
variety of areas, including networking~\cite{Loo2009-CACM},
distributed systems~\cite{Belaramani:2009,Chu:2007}, natural language
processing~\cite{Eisner:2004}, robotics~\cite{Ashley-Rollman:2007},
compiler analysis~\cite{Lam:2005}, security~\cite{sd3,Li:2003,Zhou:2009}
and computer games~\cite{White:2007}.  The resulting languages have
been promoted for their compact and natural representations of tasks
in their respective domains, in many cases leading to code that is
orders of magnitude shorter than equivalent imperative programs.
Another stated advantage of these languages is the ability to
directly capture intuitive specifications of protocols and programs as
executable code.

While most of these efforts were intended to be ``declarative''
languages, many chose to extend Datalog with operational features
natural to their application domain.  These operational aspects,
though familiar, limit the ability of the language designers to
leverage the rich literature on Datalog: program checks like safety
and stratifiability, and optimizations like magic sets and
materialized recursive view maintenance.  In addition, in many of
these languages the blend of operational and declarative constructs
leads to semantic ambiguities.  This is of particular interest to us
in the context of networking and other distributed systems, both
because we have considerable practical experience with these
languages~\cite{boom-eurosys,Loo2009-CACM}, and because others have
examined the semantic ambiguities of these languages in some
depth~\cite{Mao2009,navarro}.

In this paper we reconsider declarative programming for distributed
systems from a model-theoretic perspective. We introduce a declarative
language called \lang\footnote{\small \lang is intended as a precursor
  language for \textbf{Bloom}, a high-level language for programming
  distributed systems that will replace Overlog in the \textbf{BOOM}
  project~\cite{boom-eurosys}.  As such, it is derived from the
  character Stephen Dedalus in James Joyce's \emph{Ulysses}, whose
  dense and precise chapters precede those of the novel's hero,
  Leopold Bloom.  The character Dedalus, in turn, was partly derived
  from Daedalus, the greatest of the Greek engineers and father of
  Icarus.  Unlike Overlog, which flew too close to the sun, Dedalus
  remains firmly grounded.  } that enables the specification of rich
distributed systems concepts without recourse to operational
constructs \wrm{assignment of timestamps is operational.  i think the point we want to make is that we elegantly minimize the operational semantics}.  \lang is a subset of a language with well-studied
features: Datalog enhanced with negation, aggregate functions, choice,
and a successor relation.  \wrm{its not well studied, that's why we're studying it in this paper} \lang provides a model-theoretic foundation
for the two key features of distributed systems: mutable state, and
asynchronous processing and communication.  We show how these features
are captured in \lang using logical time. 
%via a natural incorporation of {\em time} as an
%attribute of Datalog predicates.

Given the ability to express programs with these two features, we
address three important properties of \lang programs: a temporal
notion of {\em safety} appropriate to long-running services and
protocols, {\em stratified} monotonic reasoning with negation over
time, and efficient evaluation via a simple execution strategy.  We
also provide conservative syntactic checks for our temporal notions of
safety and stratification.

We begin by defining \slang, a restricted sublanguage of Datalog
(Section~\ref{sec:slang}). We show how \slang supports state update in
Section~\ref{sec:stateupdate}, prove temporal safety and
stratifiability properties of \slang in Section~\ref{sec:safety}, and
describe a simple, efficient evaluation scheme
(Section~\ref{sec:eval}). Finally, we introduce \lang by adding
support for asynchrony to \slang in
Section~\ref{sec:async}. Throughout, we demonstrate the expressivity
and practical utility of our work with specific examples, including a
number of building-block routines from classical distributed
computing, such as sequences, queues, distributed clocks, and reliable
broadcast.  We also discuss the correspondence between \lang and our
prior work implementing full-featured distributed services in somewhat
more operational Datalog variants~\cite{boom-eurosys,Loo2009-CACM}.

Sometimes order -- ordering of data elements, as well as ordered computational steps -- 
is required by an algorithm, and in a logic language this order by be explicitly specified and 
managed.  Previous languages 

\paa{story: admitting order (that is, time) into logic is tricky, and retaining a purely logical interpretation for how the order is established and respected is downright hard.  as you'll see in the next section, nearly all of the useful idioms for DS construction are problematic/ambiguous precisely because they describe composite operations across timesteps, without the vocabulary to make clear what things co-occur atomically.}


% Traditional database systems are based on declarative query languages that
% specify transformations as dataflows over an updatable store.
% \jmh{Not usually thought of as dataflows.  Rel Alg is kinda like dataflow but declarative Rel Calc isn't. Stick with Calc/Declarative as your reference.}
%   Such query
% languages are either not expressive enough to capture common programming
% constructs \wrm{like what?}, or are at best awkward to use in this fashion.
% \wrm{todo: transition that explains Datalog's birth from these languages... I
% don't know enough to write it} The family of logic-based database languages, of
% which Datalog is the progenitor, represent expressive programming languages
% that produce similar dataflow representations.  Datalog is purely deductive: a
% program specifies the rules by which the derived relations are populated based
% on a static database, which is never updated.  Recent programming language
% research has explored the use of Datalog-based languages for expressing
% distributed systems.  Because the state of any complex system evolves with its
% execution, these efforts were forced to extend the Datalog model by admitting
% updates, additions and deletions of the EDB.  Unfortunately, these previous
% attempts were plagued with ambiguities about how and when state changes occur
% and become visible, putting a heavy burden on the programmer to ensure even
% simple properties, such as atomicity of updates over time.
% 
% In contrast to reasoning about state change procdurally, \lang observes
% that this concept is intuitively expressed as invariants over {\em time}.  In
% this work, we present a formal model of Datalog augmented with time extensions.
% By reifying time as data an introducing it into the logic, \lang eliminates
% previous ambiguities, ensures atomicity of updates and makes it possible to
% express system invariants that can guarantee liveness properties, a key
% challenge in building distributed systems.
