\section{Introduction}
Distributed programming has become an important topic in recent years, driven by advances in scalable and elastic Internet services, and by the recent Cloud Computing vision of commoditizing the development of such services using mainstream programmers.  Unfortunately, the development of distributed systems is still widely considered difficult: it routinely requires reasoning about parallel and asynchronous code, and often involves developing and judiciously configuring complex protocols for detecting and handling component failure.

In this paper, we address the distributed programming challenge with a new logic programming language we call {\em Dedalus}.  Logic programming provides an interesting basis for programming distributed systems, because of its focus on set-oriented---and hence execution-order-independent---reasoning.  In most programming paradigms, the basic language construct is the sequential, step-wise evaluation of code. At the other extreme, purely declarative logic languages like basic Datalog are entirely set-based, and cannot even express sequential evaluation.  We believe that for distributed systems, a middle ground is desirable, where ``disorderly'' statements are encouraged whenever possible (to enable parallel and asynchronous evaluation), but ordering constructs can be inserted at an appropriately coarse grain that matches the overheads of distributed coordination.

A variety of work in recent years has explored this territory, by wrapping declarative, set-oriented Datalog extensions with additional constructs for stateful and ordered computation~\cite{overlog,reactors,meld,prolog-events-gui,etc}.  A difficulty with these hybrid languages is that they complicate the development of program analyses, requiring an interleaving of both operational and model-theoretic reasoning.  And in many cases, the hybrid semantics have made it difficult for programmers to understand the subtleties of how apparently declarative code interacts with basic constructs like state update and network communication~\cite{overlogkvetches}.

Dedalus is a declarative logic programming language for distributed systems that avoids the imperative constructs that complicated this earlier work, via the use of a very simple notion of logical time.  It is built on three main themes ({\em are these themes, or contributions?}) that we believe are critical for distributed systems development:
\begin{itemize}
    \item {\bf Disorderly By Nature:} Given its grounding in logic, Dedalus encourages set-oriented expressions as the basic mode of development, with ordering as a ``special-case'' construct that can be employed explicitly at a coarse grain.  This encourages large blocks of code that can run asynchronously and in parallel, without need for expensive distributed coordination.
    \item {\bf Points of Order:} {\em via simple static analyses, we can automatically detect points in the program where ordering constructs are required to disambiguate the logic of a distributed program -- these correspond to traditional notions of non-monotonic reasoning}  
    \item {\bf Ordering by Design:} {\em for each point of order, a variety of mechanisms can be used to ensure order.  the choice of the mechanism and its parameterization has profound effects not only on the semantics of the program, but on important distributed systems features including latency, availability and load-balancing.  In essence the language highlights what we believe are the most important architectural and semantic design issues in distributed systems. }
\end{itemize}

\emph{Main contributions/outline of the paper: the design of Dedalus, design patterns for common distributed systems features, static analyses for important static properties, and a case study of a canonical distributed application: highly-available shopping carts.}