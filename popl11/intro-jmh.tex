\section{Introduction}
Distributed programming has become an important topic in recent years, driven by advances in scalable and elastic Internet services, and by recent Cloud Computing platforms that aim to commoditize the development of such services for mainstream programmers.  Despite the recent Cloud offerings, the development of distributed programs is still widely considered to be difficult.  Distributed programming routinely requires reasoning about parallel and asynchronous code, and often involves developing and judiciously configuring complex protocols for detecting and handling distributed coordination in the face of delays and failure.

In this paper, we address the distributed programming challenge with a new distributed logic programming language we call {\em \lang}.
% \footnote{\small \lang is intended as a precursor
%   language for \textbf{Bloom}, a high-level language for programming
%   distributed systems that will replace Overlog in the \textbf{BOOM}
%   project~\cite{boom-eurosys}.  As such, it is derived from the
%   character Stephen \lang in James Joyce's \emph{Ulysses}, whose
%   dense and precise chapters precede those of the novel's hero,
%   Leopold Bloom.  The character \lang, in turn, was partly derived
%   from Daedalus, the greatest of the Greek engineers and father of
%   Icarus.  Unlike Overlog, which flew too close to the sun, \lang
%   remains firmly grounded.  } 
Logic provides an interesting basis for programming distributed systems, because of its focus on set-oriented reasoning, which is inherently independent of execution order.  In most programming paradigms, the basic language construct is the sequential, step-wise evaluation of code. At the other extreme, purely declarative logic languages like basic Datalog are entirely set-based, and cannot express any control over order of evaluation.  We believe that for distributed systems, a middle ground is desirable, where ``disorderly'' statements are encouraged whenever possible to enable parallel and asynchronous evaluation, but ordering constructs can be expressed and inserted at an appropriately coarse grain to achieve the needs of core tasks like mutable state, asynchronous communication, and distributed coordination.

A variety of work in recent years has explored this territory, typically by wrapping declarative, set-oriented Datalog extensions with additional constructs for stateful, ordered computation and communication~\cite{boon,reactors,meld,prologevents}.  One difficulty with these hybrid languages is that they require program analyses to blend both operational and model-theoretic reasoning; this has made it hard, for example, to exploit analysis tools from the Datalog literature to these contexts.  And in many cases, the hybrid semantics have also made it difficult for programmers to understand the subtleties of interaction between apparently declarative code blocks, and their interaction with imperative constructs like state update and network communication~\cite{Mao2009,navarro}.

\lang avoids the imperative constructs that complicated this earlier work.  Instead, it expands Datalog with a very simple notion of logical time at each node in the system, which enables program analyses based in the logic programming literature, even while supporting traditionally imperative notions like mutable state and communication.  \lang is designed around three main themes that we believe are critical for distributed systems development:
\begin{itemize}
    \item {\bf Disorderly By Nature:} \lang provides set-oriented expressions as the basic programming mode, enriched with coarse-grain ordering as an additional construct at the programmer's disposal.  This encourages programmers to write large blocks of code that can be evaluated asynchronously and in parallel in any order, leaving expensive coordination as a special case.
    \item {\bf Points of Order:} In order to help programmers decide where to use ordering constructs, \lang enables simple but powerful static tests that can detect points in a program where these constructs may be required to disambiguate program semantics.
    \item {\bf Focus on Coordination:} Distributed programmers can address ordering requirements with a wide variety of coordination mechanisms. The choice of mechanism can have profound effects on program semantics, while also impacting opportunities for features like data replication and load-balancing that affect system availability and performance.  By focusing attention on these points in program design, the language and analyses engage programmers in thinking through the key architectural and semantic design tradeoffs in their code.
\end{itemize}

The paper makes a number of contributions.  We begin by presenting a simple but canonical distributed program---an online ``shopping cart''---and demonstrate some of the subtleties that arise in a typical distributed implementation.  With this motivation, we present the design of \lang, and show how despite its set-oriented basis in logic, it can be used to implement key design patterns for mutable state and coordination used in distributed systems.  We follow this with a presentation of simple but powerful static analysis techniques we have developed for aiding programmers to identify points of order and achieve meaningful distributed code.  We illustrate how these techniques inform the design space for the shopping cart program, and use that example to show how programmer decisions about coordination can affect semantics and system architecture.  We conclude with a discussion of future directions and open problems.