\section{Introduction}
Distributed programming has become an important topic in recent years, driven by a growing community of developers interested in building scalable and elastic Internet services.  Despite the importance of the topic, it remains difficult for most programmers to produce correct, reliable distributed code.  Distributed programming routinely requires reasoning about parallel and asynchronous operations, and often involves developing and judiciously configuring complex protocols for distributed coordination in the face of delays and failure.

In this paper, we address these challenges with a new distributed logic programming language we call {\em \lang}.
% \footnote{\small \lang is intended as a precursor
%   language for \textbf{Bloom}, a high-level language for programming
%   distributed systems that will replace Overlog in the \textbf{BOOM}
%   project~\cite{boom-eurosys}.  As such, it is derived from the
%   character Stephen \lang in James Joyce's \emph{Ulysses}, whose
%   dense and precise chapters precede those of the novel's hero,
%   Leopold Bloom.  The character \lang, in turn, was partly derived
%   from Daedalus, the greatest of the Greek engineers and father of
%   Icarus.  Unlike Overlog, which flew too close to the sun, \lang
%   remains firmly grounded.  } 
Logic provides an interesting basis for programming distributed systems because of its focus on set-oriented reasoning, which is inherently independent of execution order.  In most programming paradigms, the basic language construct is the sequential, step-wise evaluation of code. At the other extreme, purely declarative logic languages like basic Datalog are entirely set-based, and cannot express any constraints on evaluation order.  We believe that  a middle ground is desirable for distributed programming, where ``disorderly'' statements are encouraged whenever possible to enable parallel and asynchronous evaluation, but ordering constructs can be expressed and inserted at an appropriately coarse grain to achieve the needs of core tasks like mutable state and distributed coordination.

A variety of work in recent years has explored this territory, typically by wrapping declarative, set-oriented Datalog extensions with additional constructs for stateful, ordered computation and communication~\cite{boon,reactors,meld,prologevents}.  One difficulty with these hybrid languages is that they require program analyses to blend operational and model-theoretic reasoning; this has made it hard, for example, to apply analysis tools from the Datalog literature.  In many cases, the hybrid semantics have also made it difficult for programmers to understand the subtleties of interaction between apparently declarative code blocks and imperative constructs like state update and network communication~\cite{Mao2009,navarro}.

\lang avoids the imperative constructs that complicated this earlier work.  Instead, it expands Datalog with a very simple notion of logical time at each node in the system, which enables program analyses based in the logic programming literature, even while supporting traditionally imperative notions like mutable state and communication.  \lang is designed around three main themes that we believe are critical for distributed systems development:
\begin{itemize}
    \item {\bf Disorderly By Nature:} \lang provides set-oriented expressions as the basic programming mode, enriched with coarse-grain ordering as an additional construct at the programmer's disposal.  This encourages programmers to write large blocks of code that can be evaluated asynchronously and in parallel in any order, leaving expensive coordination as a special case.
    \item {\bf Points of Order:} In order to help programmers decide where to use ordering constructs, \lang enables simple but powerful static tests that can detect points in a program where these constructs may be required to disambiguate program semantics. %\wrm{``disambiguating program semantics'' sounds like stratification.  the test you're referring to is not for stratification, it's to show programmers where they need to put order in their code in order to ensure a particular correctness criterion -- confluence}
    \item {\bf Focus on Coordination:} Distributed programmers can address ordering requirements with a wide variety of coordination mechanisms. The choice of mechanism can have significant effects on program semantics, while also impacting opportunities for features like data replication and load-balancing that affect system availability and performance.  By focusing attention on these points in program design, the language and analyses engage programmers in key architectural and semantic design tradeoffs inherent to distributed code.
\end{itemize}

The paper makes several contributions.  We begin by presenting a simple but canonical distributed program---an online ``shopping cart''---and demonstrate some of the subtleties that arise in a typical distributed implementation.  With this motivation, we present the design of \lang, and show how despite its set-oriented basis in logic, it can be used to implement key design patterns for mutable state and coordination used in distributed systems.  We follow this with a presentation of simple but powerful static analysis techniques we have developed for aiding programmers to identify points of order and achieve meaningful 
%\wrm{we have a very specific interpretation of ``meaningful'' here, which is confluence} 
distributed code.  We illustrate how these techniques inform the design space for the shopping cart program, and use that example to show how programmer decisions about coordination can affect semantics and system architecture.  We conclude with a discussion of future directions and open problems.
