\section{Introduction}
Distributed programming has become an important topic in recent years, driven by advances in scalable and elastic Internet services, and by the recent Cloud Computing vision of commoditizing the development of such services for mainstream programmers.  Despite the recent Cloud offerings, the development of distributed programs is still widely considered difficult: it routinely requires reasoning about parallel and asynchronous code, and often involves developing and judiciously configuring complex protocols for detecting and handling distributed coordination in the face of delays and failure.

In this paper, we address the distributed programming challenge with a new distributed logic programming language we call {\em Dedalus}.
% \footnote{\small \lang is intended as a precursor
%   language for \textbf{Bloom}, a high-level language for programming
%   distributed systems that will replace Overlog in the \textbf{BOOM}
%   project~\cite{boom-eurosys}.  As such, it is derived from the
%   character Stephen Dedalus in James Joyce's \emph{Ulysses}, whose
%   dense and precise chapters precede those of the novel's hero,
%   Leopold Bloom.  The character Dedalus, in turn, was partly derived
%   from Daedalus, the greatest of the Greek engineers and father of
%   Icarus.  Unlike Overlog, which flew too close to the sun, Dedalus
%   remains firmly grounded.  } 
Logic programming provides an interesting basis for programming distributed systems, because of its focus on set-oriented reasoning, which is inherently independent of execution order.  In most programming paradigms, the basic language construct is the sequential, step-wise evaluation of code. At the other extreme, purely declarative logic languages like basic Datalog are entirely set-based, and cannot express any control over order of evaluation.  We believe that for distributed systems, a middle ground is desirable, where ``disorderly'' statements are encouraged whenever possible (to enable parallel and asynchronous evaluation), but ordering constructs can be expressed and inserted at an appropriately coarse grain to achieve the needs of basic tasks like state modification, asynchronous communication, and distributed coordination.

A variety of work in recent years has explored this territory, typically by wrapping declarative, set-oriented Datalog extensions with additional constructs for stateful, ordered computation and communication~\cite{overlog,reactors,meld,prolog-events-gui,etc}.  One difficulty with these hybrid languages is that they require program analyses to blend both operational and model-theoretic reasoning; this has made it hard, for example, to exploit analysis tools from the Datalog literature to these contexts.  And in many cases, the hybrid semantics have also made it difficult for programmers to understand the subtleties of interaction between apparently declarative code blocks, and their interaction with imperative constructs like state update and network communication~\cite{overlogkvetches}.

Dedalus avoids the imperative constructs that complicated this earlier work, by expanding Datalog with a very simple notion of logical time at each node in the system.  Dedalus is design around three main themes ({\em are these themes, or contributions?}) that we believe are critical for distributed systems development:
\begin{itemize}
    \item {\bf Disorderly By Nature:} Dedalus provides set-oriented expressions as the basic programming mode, enriched with coarse-grain ordering as an additional construct at the programmer's disposal.  This encourages programmers to write large blocks of code that can be evaluated asynchronously and in parallel in any order, leaving expensive coordination as a special case.
    \item {\bf Points of Order:} In order to help programmers decide where to use ordering constructs, Dedalus enables simple but powerful static tests that can detect points in a program where these constructs may be required to disambiguate program semantics.
    \item {\bf Focus on Coordination:} Distributed programmers can address ordering requirements with a wide variety of coordination mechanisms. The choice of the mechanism and its parameterization can have profound effects on program semantics in the field, and also opportunities for replication and load-balancing that affect system availability, load-balancing and service latency.  By focusing programmer attention on these points in a program, the language focuses developer attention on key architectural and semantic design issues that arise in distributed systems. 
\end{itemize}

The paper makes a number of contributions.  We begin by presenting a simple but canonical distributed program---an online ``shopping cart''---and demonstrate some of the subtleties that arise in a typical distributed implementation.  With this motivation, we present the design of Dedalus, and show how despite its set-oriented basis in logic, it can be used to implement key design patterns for state and ordering used in distributed systems.  We follow this with a presentation of simple but powerful static analysis techniques we have developed for ensuring correct distributed code.  We show how these techniques inform the design space for our canonical program, and how subsequent programmer decisions about coordination can affect program semantics and system architecture.  We conclude with a discussion of future directions and open problems.