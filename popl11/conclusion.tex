\section{Conclusion and Future Work}
In earlier work we developed substantial experience building significant
distributed systems~\cite{boom-eurosys,netdb,Chu:2007,Loo2009-CACM} using hybrid
declarative/imperative languages such as Overlog~\cite{Loo2009-CACM}.
While our experience with those languages was largely positive, the 
combination of Datalog and imperative constructs, limited our development of program analyses, and often clouded our understanding of the ``correct'' execution: even for simple  single-node programs that performed state updates.  
\lang was developed in large part as a reaction to the semantic difficulties
presented by these distributed logic languages.

The language features, analysis, and examples in this paper are intended to illustrate the benefit that \lang provides to distributed systems by bringing stateful and ordered metaphors under the semantic umbrella of logic programming.  In particular, we believe that the ability to direct programmers to focus on coarse-grained points of order is a significant step forward from reasoning about concurrency in more imperative models.

Having taken this first step in our agenda, a number of next questions come up quite naturally.  We feel that the ability to ask these questions validates our progress---these questions would not be natural or feasible in other languages.  In closing we acknowledge some of this unfinished business, informally laying out some of the questions that interest us in an informal way:

\begin{itemize}
    \item {\bf Resolving Points of Order:}.  In Section~\ref{sec:stateupdate} we present a number of motifs that can be used to insert order into programs at the points non-monotonic boundaries identified by the checks of Section~\ref{sec:properties}.  These motifs are themselves non-monotonic, however.  So after programmer ``resolves'' the points of order in their program, the checks of Section~\ref{sec:properties} on the resulting augmented program will identify {\em even more} points of order.  Clearly it would be better for the analysis tools to ``reward'' a programmer by recognizing order resolution where it is introduced.  This raises a number of challenges including (a) suitably defining what is required to ``resolve'' a point of order and (b) building tests that can verify that order has been resolved -- tests that at minimum work over a wide range of typical order-resolving motifs.    
    
    \item {\bf Re-Ordering Code.} As we saw in the shopping cart example, despite the ``declarativity'' of \lang, the same basic program can be implemented in very different ways, with subtly different characteristics under reorderings and delays.  This is of course true in a traditional imperative language as well.  But in the case of \lang, these differences can be seen at a relatively high level: ``importantly'' different implementations are manifested in different PDG's, which will likely have differing numbers of ordering constructs, and hence will enable differing degrees of asynchrony and parallelism.  This raises the possibility of helping programmers address some very high-level design decisions.  For example, it seems plausible that analysis could in some circumstances demonstrate that a program employes ``too many'' points of order, and could be made more parallel or asynchronous---this is easy to imagine, for example. in the case of fully monotonic programs that include unnecessary ordering constructs.  If simple rewriting of ordering constructs is possible, then more subtle challenges arise.  In particular, it would be very interesting to help programmers navigate tradeoffs between asynchrony, potential non-determinism (e.g., inconsistency of replicas), and availability.  An initial agenda here might be to study small, local transformations on the ordering components of PDGs: for example, ``pushing'' ordering lower in the dependency chain of a program, or ``pulling it higher''.

    \item {\bf Modularity and Programmability.}  Although we have implemented substantial software in \lang and its predecessors~\cite{p2}, we recognize that the language is missing many familiar language features that are important for productivity: modularity, rich types, mechanisms for code reuse and specialization, etc.  The simplicity of \lang allowed us to make progress without considering these issues, but we are now a stage where they are achievable and important.  One question we ponder on this front is whether to design a more practical language {\em de novo} based on the lessons of \lang, or whether to use \lang to implement a distributed framework embedded in a more traditional language, adapting the host language's features to the extent possible.
    
\end{itemize}
