\section{Foundation}
\label{sec:lang}

\lang is based in Datalog enhanced with negation and aggregation
(a.k.a.\ Datalog$\lnot$)~\cite{ullmanbook}, which hereinafter we refer to simply as Datalog.
Below, we provide a brief review of Datalog, and subsequently detail our
language in terms of Datalog.

\subsection{Datalog}
\label{sec:datalog}

A Datalog {\em program} comprises a set of {\em rules}.  A Datalog {\em rule}
is a first-order logical formula of the following form:
\dedalus{$p_0(\overline{X_0})$ :- $p_1(\overline{X_1})$, ...,
$p_j(\overline{X_j})$, $\lnot p_{j+1}(\overline{X_{j+1}})$, ..., $\lnot
p_k(\overline{X_k})$;}.  \dedalus{$p_0$, ..., $p_k$} are known as {\em
predicates}.  Each predicate, also called a {\em relation} or {\em table}, has
a fixed arity.  Predicates that appear on the left-hand side of some rule in
the program are called {\em intensional} predicates; the rest are called {\em
extensional}.  Each of $\overline{X_0}, ..., \overline{X_k}$ are lists of
arguments (constants or existentially quantified variables).
$p_0(\overline{X_0})$, ..., $p_k(\overline{X_K})$ are {\em atoms}: an atom is
a list of arguments prefixed with a predicate.  The same variable symbol may
appear in multiple atoms; in this case, we say that the atoms are {\em
unified} on the arguments that contain the duplicated variable.  An assignment of constants to all arguments in a predicate is known as a {\em
fact}---also called a {\em tuple} or {\em row}---and we often refer to ``the
facts in a predicate,'' meaning the satisfying assignment of constants to the
predicate's arguments.  The single
atom to the left of the \dedalus{:-} delimeter is the rule's {\em head}, and
the set of atoms to the right is the rule's {\em body}.  We say that the rule's
head predicate {\em depends on} each of its body predicates.   If a predicate
(resp. fact) \dedalus{p} depends on a predicate (resp. fact) \dedalus{q}, we
write \dedalus{p} $\succ$ \dedalus{q}.  A predicate (resp. fact) \dedalus{p} transitively depends on a predicate (resp. fact) \dedalus{q}---denoted
\dedalus{p} $\succ^+$ \dedalus{q}---if \dedalus{p} $\succ$ \dedalus{q}, or if
\dedalus{p} $\succ$ \dedalus{r} $\succ^+$ \dedalus{q}.  If \dedalus{p}
$\succ^+$ \dedalus{p}, then we say that \dedalus{p} is {\em recursive} or {\em
cyclic}.

In addition to atoms, a rule's body may also contain the {\em order
constraints}: $=, \geq, >, \leq, <, \neq$.  An order constraint is an infinite
binary relation that may be applied either to constants, or variables used in
the rule's body atoms.

The logical meaning of a Datalog rule is that for each satisfying assignment of
constants to variables on the right-hand side, there exists a tuple with the
corresponding satisfying assignment of constants in the left-hand side
predicate.
%\rcs{satisfies the lhs?}
A (possibly empty) set of facts for the extensional predicates is known as an
{\em extensional data base} (EDB).  A Datalog {\em instance} is a program
together with an EDB.  The set of facts in intensional predicates implied by
the EDB given the program is the {\em intensional data base} (IDB) of the
instance.

The {\em Herbrand Universe} of an instance, written $\mathcal{H}$, is the set of
all constants in the EDB and IDB.

\subsection{Aggregation}

{\em Aggregates} are functions from sets to scalar values.
We are interested in both {\em exemplary} aggregates like \dedalus{max} and \dedalus{min} that return a value
from the input set, and {\em summary} aggregates like \dedalus{count}.  An aggregate may only appear in the head
of a rule; a head atom \dedalus{p($\bar{A}, \rho<B>$)}, where $\rho$ is an 
aggregate, indicates that predicate \dedalus{p} contains one row for each 
satisfying assignment of $\bar{A}$ (the ``grouping'' attributes).  This row contains the value of the 
aggregate function over the set of assignments to $B$ for the given value of 
$\bar{A}$.

As a concrete example, consider implementing the ``checkout'' functionality for shopping carts: this requires carrying out some aggregations over the \dedalus{cart\_action} table.
A typical implementation counts the number of additions and deletions 
of each item.  The rule below will group by the first five attributes, and associate the
count of unique {\tt ReqId} values with the last attribute: 
%\jmh{is it clear that Type is one of ``insert'' or ``delete''?}

\noindent{}
\begin{Dedalus}

status(Serv, Cli, Ses, Item, Type, count<ReqId>) :- 
  cart\_action(Serv, Cli, Ses, Item, Type, ReqId);
\end{Dedalus}

\subsection{Non-Monotonicity}

A Datalog instance without negation or aggregation always has a unique {\em
minimal model}: the minimal sets of facts in all predicates, implied by the
EDB given the program~\cite{ullmanbook}.  Programs without negation or
aggregation are always {\em monotonic}.  A program is monotonic if, when
evaluated on two EDBs $E \subset F$, the model of the instance of $P$ with EDB
$E$ is a subset of the model of the instance of $P$ with EDB $F$.  In practice,
monotonic logic is not expressive enough to capture many interesting programs --
computation can never happen over an unbounded set.

Adding negation or aggregation introduces potential nonmonotonicity.  When
admitting negation or aggregation, a {\em
contradiction} may arise---a fact that depends on its own negation.  Consider
the Datalog program below, which represents a game where player \dedalus{X}
wins if she has a move, and player \dedalus{Y} does not have a move:

\begin{Dedalus}
win(X) :- move(X,Y), \(\lnot\) win(Y);
\end{Dedalus}

\noindent{}Consider the following EDB for the above program:

\begin{Dedalus}
move(1,1)
\end{Dedalus}

This instance has no minimal model, because it has a contradiction:
\dedalus{move(1,1)} and \dedalus{\(\lnot\) win(1)} implies \dedalus{win(1)},
and thus \dedalus{win(1)} $\succ$ \dedalus{\(\lnot\) win(1)}.  Notice that if
we required \dedalus{p} $\not\succ^+$ \dedalus{\(\lnot\) p} for all predicates
\dedalus{p}, a contradiction could never arise in any instance of any program
\paa{eek, only if we take $\lnot$ as shorthand for negation \emph{or} aggregation}
-- this is called {\em syntactic stratification}.  It is known that detecting
whether a program is contradiction-free for all EDBs is
undecidable~\cite{papa-yanna}, so the Datalog community has devised a spectrum
of decreasingly conservative {\em stratification conditions}~\cite{local-strat,
ross-syntactic, modular, weak-strat} that assure acyclicity of all facts
through negation---but exclude some contradiction-free programs. For example,
adding the condition \dedalus{X < Y} to the above rule would rule out
contradictions.  Alternatively, adding a condition to ensure that
\dedalus{move} is acyclic would also exclude contradictions.  If a program
satisfies a particular stratification condition, then we call the program {\em
stratified}.

%The logic programming community has devised a number of increasingly
%less-conservative conditions called {\em stratification
%conditions}~\cite{local-strat, ross-syntactic, modular, weak-strat}, which
%ensure acyclicity of derivations through negation, but exclude some
%contradiction-free programs.  If a program meets a particular stratification
%condition, we say the program is {\em stratified}.  One condition is known as
%{\em syntactic stratification}, which excludes all programs where a predicate
%\dedalus{p} transitively depends on \dedalus{\(\lnot\)p}.  Clearly, this
%condition may exclude many useful programs, because such a syntactic cycle may
%in practice never lead to a contradiction.  The semantics presented
%in~\cite{wellfounded} define a unique model for any stratified program.
Negation (non-existence in a set) and aggregates (functions defined over sets)
require their input set to be fully determined in order to produce a correct
answer.  In other words, they require {\em universal quantification} over the
set on which they are defined.  Stratification conditions impose order on the
application of rules to ensure that this universal quantification is always
applied after the input set is fully determined.  This ordering induces a
unique model, under the semantics presented in~\cite{wellfounded}.

\subsection{Safety}

To ensure that Datalog programs are always effectively computable, the Herbrand
Universe---and thus the model---is restricted to be finite.  This is
achieved by making the program {\em safe}---restricting the use of constructs
that can expand the Herbrand Universe, such as summary aggregates.


\subsection{Choice}

One of our goals for \lang is to model the inherent non-determinism of network
delay in asynchronous distributed systems.  Sacc\`{a} and
Zaniolo~\cite{sacca-zaniolo} formalized non-determinism in Datalog in their
\dedalus{choice} construct.  Consider the rule \dedalus{p(X,Y) :- q(X,Y),
choice((X), (Y));} The \dedalus{choice((X),(Y))} clause means that For each
value that variable \dedalus{X} assumes, variable \dedalus{Y} may only take on
a single {\em non-deterministically chosen} value.  \dedalus{choice} has a
model-theoretic definition based on cycles through negation.  \dedalus{choice}
never causes a contradiction, and is safe, because it does not expand the
Herbrand Universe.

\section{\lang}

\lang is a subset of Datalog, with \dedalus{choice}, an infinite \dedalus{time}
relation $\mathbb{N}$, and a \dedalus{successor}
%$(\mathbb{N} \cup \top)$
relation, which is isomorphic to $+1$ on $\mathbb{N}$.  We will carefully
restrict the use of \dedalus{time} and \dedalus{successor} to ensure safety,
and \dedalus{successor} will serve as the basis for a stratification condition
that we call {\em temporal stratification}.

The intuition behind \lang's \dedalus{successor} relation is that it models the
passage of logical time.  In our discussion, we will say that facts with lower
time suffixes occur ``before'' facts with higher ones.  
%If we wish to model possible message loss, we may admit a special element
%$\infty$ into \dedalus{time}.
We exclude message loss and node failure in this paper to simplify the
discussion, though we explicitly deal with such issues in other
work~\cite{dedalus-techr, netdb}.

\subsection{Syntactic Restrictions}
\label{sec:syntaxrestrictions}
In \lang, the form of predicates and rules are restricted in the following ways:

\noindent{\bf Time Suffix: } The final attribute of every \lang
predicate must range over the \dedalus{time} domain. 
%\lang considers this final attribute as a ``timestamp,'' so
We refer to this attribute as the predicate's \emph{time suffix}, and we talk about the {\em timestamp} of a fact. 
%\rcs{Removed:''---we also refer to
%facts as {\em events}.''  We need to talk about async before talking about events.  Also, we should define ``event'' as ``a tuple produced by async rules''.}

\noindent{\bf Unification on Time: } The time suffix of every predicate in the
body of a rule must contain the same variable symbol.  Hence, each rule body
refers to a single logical time.  For ease of exposition, we henceforth assume
that this variable symbol is named $\DT$.  A well-formed \lang rule must also
bind the head predicate's time suffix to a variable symbol.  We will assume the
name of this variable symbol is $\DS$. $\DS$ must be constrained in one of
three ways:

\begin{enumerate}
%
\item The rule is {\em deductive} if $\DS$ is bound to the value
$\DT$; that is, the body contains \dedalus{$\DS$ = $\DT$}.
%
\item The rule is {\em inductive} if $\DS$ is the successor of
$\DT$; that is, the body contains \dedalus{successor($\DT$, $\DS$)}.
%
\item The rule is {\em asynchronous} if $\DS$ is unrelated to $\DT$;
that is, the body contains \dedalus{time($\DS$), choose(($\overline{A}$),
($\DS$))}, where $\overline{A}$ is the set of variables occurring in the body,
including $\DT$.
%
\end{enumerate}

The use of \dedalus{successor}, \dedalus{time}, and \dedalus{choice} are
otherwise prohibited.  We will study the utility of these three types of rules
later, but briefly observe here that systems in general only require recourse
to ordering primitives for mutable state and communication.  Inductive and
asynchronous rules model these cases respectively.

Usage of $S$ or $T$ outside of the time suffixes is known as {\em
entanglement}.  We will revisit this powerful construct in
Section~\ref{sec:entangle}. 

\begin{table*}[t]
\begin{center}
\begin{tabular}{l | l | l}
& \lang code & Sugared \lang code \\
\hline
deductive & \dedalus{p(A, B, \(\DS\)) \(\leftarrow\) e(A, B, \(\DT\)), \(\DS\) = \(\DT\);} & \dedalus{p(A, B) \(\leftarrow\) e(A, B);} \\
\hline
inductive & \dedalus{q(A, B, \(\DS\)) \(\leftarrow\) e(A, B, \(\DT\)), successor(\(\DT\), \(\DS\));} & \dedalus{q(A, B)@next \(\leftarrow\) e(A, B);} \\
\hline
async & \dedalus{r(A, B, \(\DS\)) \(\leftarrow\) e(A, B, \(\DT\)), time(\(\DS\)), choice((A,B,\(\DT\)), (\(\DS\)));} & \dedalus{r(A, B)@async \(\leftarrow\) e(A, B);} \\
\hline
fact & \dedalus{e(1, 2, 3)} & \dedalus{e(1, 2)@3}
\end{tabular}
\end{center}
\caption{Well-formed deductive, inductive, and asynchronous rules and a fact, and sugared versions}
\label{tbl:rules}
\end{table*}

Table~\ref{tbl:rules} shows an example of each kind of well-formed \lang
rule---deductive, inductive, and asynchronous---as well as a \lang fact.  The
table also presents a sugared syntax, which elides the time suffixes in the
head and body, and replaces the \dedalus{successor}, \dedalus{time} and
\dedalus{choice} clauses in temporal rules with a head keyword that indicates
the change in time suffix.

%\paa{consider using shopping cart examples (with shorter attr names)
%for the above}
%\\
%deductive:
%\begin{Dedalus}
%ca_stage(S, C, Sn, I, T, R, \(\DS\)) :- 
%  action(C, Sn, I, T, \(\DT\)), 
%  best_replica(C, Sn, S, \(\DT\)), s(R, \(\DT\)),
%  \(\DS\) = \(\DT\);
%ca_stage(S, C, Sn, I, T, R) :-
%  action(C, Sn, I, T), best_replica(C, Sn, S), s(R);
%\end{Dedalus}
%\\
%inductive:
%\begin{Dedalus}
%s(X + 1, \(\DS\)) \(\leftarrow\) s(X, \(\DT\))), \(\lnot\) action(_, _, _, _, _, \(\DT\)),
%  successor(\(\DT\), \(\DS\));
%s(X + 1)@next \(\leftarrow\) s(X) \(\lnot\) action(_, _, _, _, _);
%\end{Dedalus}
%\\
%asynchronous:
%\begin{Dedalus}
%cart_action(#L, C, S, I, T, R, \(\DS\))) :- 
%  ca_stage(L, #C, S, I, T, R, \(\DT\))), time(\(\DS\)),
%  choose((L,#C, S, I, T, R, \(\DT\)), (\(\DS\)));
%\end{Dedalus}
%
%\paa{better (modulo formatting)?}

%\noindent{\bf Positive and Negative Predicates: }
%\paa{joe thinks we could probably footnote a digest of all or most of this section} \jmh{postpone p\_neg until you need it, and ignore p\_pos (you could footnote that when you talk IDB vs. EDB if you like.)  Assume this is not a language feature, it's just a design pattern you'll use.}
%For every extensional predicate \dedalus{r} in a \lang program $P$, we add to
%$P$ two distinguished predicates \dedalus{r\pos} and \dedalus{r\nega} with the same arity
%as \dedalus{r}.  We define \dedalus{r\pos} using the following rule:\rcs{this leads to akwardness later.  perhaps we should define an \dedalus{r} and an \dedalus{r edb}}

%\begin{dedalus}
%r\pos($\overline{A}$,\(\DS\)) \(\leftarrow\) r($\overline{A}$,\(\DT\)), \(S\)=\(\DT\);
%\end{dedalus}

% \hspace{5mm}
% \begin{dedalus}
   
% \end{dedalus}

%\noindent{}That is, for every extensional predicate \dedalus{r} there is an intensional
%predicate \dedalus{r\pos} that contains at least the contents of \dedalus{r}.
%Intuitively, this rule allows extensional facts to serve as ground for
%\dedalus{r\pos}, while enabling other rules to derive additional \dedalus{r\pos} facts.

%The predicate \dedalus{r\pos} may be referenced in the body or head of any \lang rule.  
%We will make use of the predicate \dedalus{r\nega} later to capture the notion of mutable state; we return to it in Section~\ref{sec:mutable}. 
%Like \dedalus{r\pos}, the use of \dedalus{r\nega} in the heads and bodies of rules is unrestricted.

%\vspace{1.2em}
%\noindent{\bf Guarded EDB: }
%No well-formed \lang rule may involve any extensional predicate, except for a rule of the form above.


\subsection{Distribution, Asynchrony and Choice}

\lang adopts the {\em horizontal partitioning} convention introduced by Loo et
al.~\cite{Loo:2005}, where each predicate is partitioned on the value of its
{\em location specifier}: a column of the predicate that stores an agent's
identifier.  In \lang, we require that all atoms in the body of a single rule
use the same variable name in the location specifier, enforcing locality in
space, just as \lang forces locality in time.  If the location specifier of a
rule's head is bound to the body's location specifier, then we call the rule
{\em local}.  Otherwise, we call the rule a {\em communication rule}.  Note
that by restricting rule bodies to a single agent, the only communication
modeled in \lang occurs via communication rules.  Derivation of a fact with
another agent's identifier implies sending the fact to the agent.
Syntactically, location specifiers are prefixed with a \dedalus{\#} symbol in
Dedalus.

We use choice to model the inherent temporal nondeterminism associated with
communication in {\em asynchronous} distributed systems.  For example, messages
may be arbitrarily delayed, and a receiver cannot infer that a message will
never be sent based solely on his non-receipt of the message (it may arrive
arbitrarily far in the future).  To this end, we require that any communication
rules be \dedalus{async} rules.  

\subsection{Temporal Stratification}

We desire a stratification condition for \lang that corresponds to our
intuitive interpretation of time.  Note that contradictions in a \lang program
can always be avoided by rewriting the program to spread out the contradictory
values over time.  \wrm{this is a pretty poor motivation, someone please help}

If predicate \dedalus{p} depends on predicate \dedalus{q} through only
inductive rules, then we write $\dedalus{p} \gets \dedalus{q}$.  $\dedalus{p}
\gets^+ \dedalus{q}$ if $\dedalus{p} \gets \dedalus{q}$ or $\dedalus{p} \gets
\dedalus{r} \gets^+ \dedalus{q}$.

\begin{definition}
%
A \lang program is temporally stratified if for all predicates \dedalus{p}:
$\dedalus{p} \succ^+ \nega \dedalus{p} \implies \dedalus{p} \gets^+ \nega
\dedalus{p}$.
%
\end{definition}


The edge is annotated with a
$\lnot$ if $P_i \succ \lnot P_j$.  The
edge is annotated with a $+$ if all rules with head $P_i$ and $P_j$ in their
bodies are either inductive or async.  A \lang program is temporally
stratified if all cycles in the PDG with an $\lnot$ edge also have a $+$
edge.

The intuitive meaning of a $+$ edge $(N_i, N_j)$ is that $P_j$ derives $P_i$ at
some later time.  
\paa{for more details and a proof see the TR}

\subsection{Temporal Safety}

Next we consider the issue of infinite results.  In Datalog, programs with
infinite results are traditionally ruled out, as Datalog's evaluation
algorithms fail to terminate on such programs.  Similarly, for \lang, we want
to somehow constrain programs that fail to terminate, given any bounded EDB.
Given a finite universe of constants---i.e., restricting entanglement and
summary aggregates---it is clear that modulo time, a \lang program can
only compute a finite model.  
\jmh{we can't just say ``modulo time''.  this requires more careful definition.}
The only possible termination issue then is that
a set of facts may exhibit {\em non-convergence}: oscillation in time.  Given
that the finiteness of the universe implies a finite period of oscillation, we
can either compute a finite representation of these non-convergent derivations
in the style of Chomicki et al.~\cite{chomicki-infinite} or a {\em partial
fixpoint}~\cite{abiteboul-vianu}, which regards non-convergent derivations as
false.

If finiteness of the universe cannot be guaranteed, we can fall back on
conservative syntactic conditions presented in~\cite{dedalus-techr} that
guarantee the existence of a finite model.

\rcs{wrm agreed the following paragraph needs to be moved/rewritten, but I forget where.  Note that the following only holds for analyses of confluence.  We might want to check other properties, such as invariants over a trace that we collect and process at runtime.  Such analyses are probably more interested in network events than the ultimate model.  Other analyses probably want to check other things...}

\begin{definition}
%
For a \lang instance and a particular series of non-deterministic choices, the
set of all facts implied by \dedalus{async} rules, including their timestamps,
comprise a trace of the instance.
%
\end{definition}


\wrm{tie in this def better}
\begin{definition}
%
An {\em incremental model} at time $T$ of trace $R$ of a \lang instance $I$,
represented by $\mathcal{M}_{I,T}(R)$, is the contents of all
relations at time $T$.
%
\end{definition}

\jmh{don't think you've introduced ``simply persisted'' yet.  Meanwhile, can't we say time $t=\infty$}
\begin{definition}
%
The {\em ultimate model} of trace $R$ of a \lang instance $I$, represented by
$\mathcal{U}_I(R)$, is the eventual contents of the simply persisted relations
(ignoring timestamps).
%
\end{definition}

In the general case, we are not interested in the full model of a trace of an
instance: facts that are only ephemerally true represent events, or intermediate
computations, which intuitively should not be considered as part of the output
of the program.  We are only interested in the program's {\em ultimate
  model}---the eventual contents of the simply persisted relations (ignoring
timestamps).
\paa{sort of.  but those ephemeral tuples provide ground for future inductive deductions, no?}
\paa{also (unrelated to previous comment) perhaps make reference to the correspondence with eventual consistency
(if it has been introduced yet}

Since non-determinism (\dedalus{choice}) is restrited to \dedalus{async} rules, we ca


