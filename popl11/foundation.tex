\section{Foundation}
\label{sec:lang}

\lang is related to Datalog$\lnot$~\cite{ullmanbook}, hereinafter referred to as Datalog.  Below, we provide a brief review of Datalog, and subsequently detail our language in terms of Datalog.

\subsection{Datalog}
\label{sec:datalog}

A Datalog {\em program} comprises a set of {\em rules}.  A Datalog {\em rule} is a first-order logical formula, of the following form: \dedalus{$p_0$(\bf{$X_0$}) :- $p_1$(\bf{$X_1$}), ..., $p_j$(\bf{$X_j$}), $!p_j+1$(\bf{$X_{j+1}$}), ..., $!p_k$(\bf{$X_k$});}.  \dedalus{$p_0$, ..., $p_k$} are known as {\em predicates} (each predicate has a fixed arity).  Predicates that appear on the left-hand side of some rule in the program are called {\em intensional} predicates -- the rest are called {\em extensional}.  Each of \dedalus{\bf{$X_0$}, ..., \bf{$X_k$}} are lists of arguments (existentially quantified variables or constants).  An application of a predicate to a list of arguments is called an {\em atom} (note that predicates are of a fixed arity).  The single atom to the left of the \dedalus{:-} delimeter is the rule's {\em head}, and the set of atoms to the right is the rule's {\em body}.  If the head predicate also appears in the rule's body, the rule is called {\em recursive}.  In addition to atoms, a rule's body may also contain {\em dense~\paa{recall that 'dense' is not correct; it implies continuous} order constraints} \wrm{weird...  levy/sagiv et al refer to these as ``dense order constraints'', presumably to distinguish them from ``gap order constraints''??  anyway, the terminology appears to be ambiguosly used in the literature, maybe we should stick with ``order constraints'' } , $=, \geq, >, \leq < \neq$, which restrict the values of variables.  If an atom's argument list is solely comprised of constants, it is called a {\em fact}.  A possibly empty set of facts for the extensional predicates is known as an {\em EDB} or extensional data base.  A Datalog {\em instance} is a program together with an EDB.  \paa{what happened to "if the right-hand side is true...?} \wrm{i took this out because it didn't flow.  i can stick it back later}

\wrm{say something like:  Traditionally, people doing data processing have found it useful to have shorthand for some commonly-used operations that associate a value with a set, called aggregates.  We allow {\em exemplary} aggregates, which cannot be used to expand the universe of constants.

paste from constructs--

Mumick and Shmueli observe correspondences in the expressivity of Datalog with stratified negation and stratified aggregation functions~\cite{mumickshmueli}.  Adding aggregation to our language does not affect its expressive power, but is useful for writing natural constructs for distributed computing including queues and ordering.  

In \lang we will allow
aggregate functions $\rho_1 - \rho_n$ to appear
in the head of a deductive rule of the form:

%%\dedalus{p(\(A_1\), \(\ldots\), \(A_n\), \(\rho_1\)(\(A_{n+1}\)), \(\ldots\), \(\rho_m\)(\(A_{n+m}\))) \(\leftarrow\)}

\begin{dedalus}
p($A_1, \ldots, A_n, \rho_1(A_{n+1}), \ldots, \rho_m(A_{n+m})) \leftarrow$
\end{dedalus}
%%\linebreak

\hspace{5mm}
$q_1$
\begin{dedalus}
($A_1, \ldots, A_{n}, A_{n+1}), \ldots, q_m(A_1, \ldots, A_{n}, A_{n+m}$);
\end{dedalus}

According to this rule, the predicate $p$ contains one row for each satisfying assignment of $A_1, \ldots, A_n$ --- akin to the distinct ``groups'' of SQL's ``GROUP BY'' notation.}

In certain cases, a Datalog instance has a unique {\em model} \wrm{cite} -- a minimal set of facts in all predicates implied by the EDB given the program.  Adding netation to Datalog programs increases expressivity, but creates the possibility of two additional types of programs: programs with no model, i.e. programs with a {\em contradiction} -- a fact that depends on its own negation -- and programs that have a multiplicity of models \wrm{cite sacca and zaniolo}.  The computation of the model of a Datalog program is an iterative procedure, where each iteration determines new facts.  Datalog ensures termination of this procedure (and finiteness of the model) by guaranteeing finiteness of the universe of constants (for example: restrictions on functions).


\subsubsection{Stratification}
%Note that negation allows the specification of a program that is contradictory, such as $p(X) :- q(X), !p(X);$.  The reason for the contradiction is that given an EDB where \dedalus{p \cap q} is non-empty, each \dedalus{p} fact with a corresponding \dedalus{q} fact depends on its own negation (is simultaneousy both false and true).  
Contradictions are usually undesirable in logic programming. 
\paa{usually?  it seems to me they are always undesirable, b/c in logic, I can use a constradictory
premise to prove any arbitrary conclusion (rendering the language rather useless).  this is the 
same argument for why we always choose soundness over completeness.} \wrm{3-valued logic}
  Unfortunately, detecting that a program is contradiction-free for all EDBs is undecidable in general \wrm{cite}, so the logic programming community has devised a number of conservative conditions called {\em stratification conditions} that guarantee freedom from contradiction and the existence of a model.  One popular condition is known as {\em syntactic stratification}, which excludes all programs where a predicate \dedalus{p} transitively depends on \dedalus{!p}.  We will see later how syntactic stratification is too conservative for our needs, and we will intrduce a more liberal stratification condition called {\em temporal stratification}.

\subsubsection{Choice}
Having ruled out single-solution programs with contradiction, we are interested in programs that have a multiplicity of solutions, where no solution has a contradiction.  This notion was formalized by~\cite{greedychoice} as the \dedalus{choice} construct.  \dedalus{choice} allows the specification of a functional dependency in a rule.  For example, \dedalus{p(X,Y) :- q(X,Y), choice( (X), (Y) );} expesses that for each value that variable \dedalus{X} takes on, variable \dedalus{Y} may only take on a single value.  If \dedalus{q} contains more than one \dedalus{Y} value for an \dedalus{X}, then the instance has multiple models: one corresponding to each choice of \dedalus{Y} for each \dedalus{X}.  Operationally, the answer to a Datalog program with choice corresponds to a {\em non-deterministic choice} of one of the models.

See~\cite{greedychoice} for the details on how \dedalus{choice} is expanded into Datalog rules.  For many stratification conditions, this expansion is {\em unstratfiable}, meaning it violates the conditions.  Thus, we often must explicitly admit programs with \dedalus{choice} after ruling out certain unstratified programs.

\subsection{\lang}
Dedalus is a subset of Datalog, with \dedalus{choice}, an infinite \dedalus{time} relation $(\mathbb{N} \cup \top)$, and a \dedalus{successor} relation, which is isomorphic to $+1$ on $\mathbb{N}$.  Intuitively, $\top$ is meant to model the time {\em never}.  We will see later how \dedalus{successor} forms the basis of a stratification condition that we call {\em temporal stratification}.

\subsection{Syntactic Restrictions}
\label{sec:syntaxrestrictions}

Specifically, we restrict the admissible schemata and the form of rules with the four constraints that follow.

\noindent{\bf Schema: }We require that the final attribute of every \lang predicate range over the \dedalus{time} domain.  
%\lang considers this final attribute as a ``timestamp,'' so
We refer to this attribute as the \emph{time suffix} of the corresponding predicate.

\noindent{\bf Time Suffix: }
%$p(C_{1},C_{2},[...],C_{n}, i) |  i \in \mathbb{Z} \cup \top$ The balance of
%our restrictions concern the well-formedness of \dedalus rules.
%\begin{definition}
%
%An \emph{extensional} predicate in a \slang program $P$ is a predicate that
%does not appear in the head of any rule in $P$.
%
%\end{definition} \wrm{we really want an inclusion constraint not just in the
%set of integers, but in the set of all possible times, in case time is
%finite}.  \jmh{I disagree, actually.  EDB facts can be sprinkled throughout
%time without restriction, and the rule syntax below provides the restrictions
%you want.  you're hinting at the reduction stuff below, but we can rewrite to
%that.}
In a well-formed \lang rule, every body predicate's time suffix is bound to the
same variable symbol.  For ease of exposition, we henceforth assume that this
variable symbol is named $\DT$.  A well-formed \lang rule must also bind the head
predicate's time suffix to a variable symbol.  We will assume the name of this
variable symbol is $\DS$.  $\DS$ may be constrained in exactly one of three ways:

\begin{enumerate}
%
\item The rule is said to be {\em deductive} if $\DS$ is bound to the
value $\DT$; that is, the body contains \dedalus{$\DS$ = $\DT$}.
%
\item The rule is said to be {\em inductive} if $\DS$ is the successor of
$\DT$; that is, the body contains \dedalus{successor($\DT$, $\DS$)}.
%
\item The rule is said to be {\em asynchronous} if $\DS$ is unrelated to $\DT$;
that is, the body contains \dedalus{time($\DS$), choose(($\bar{A}$), ($\DS$))}, where $\bar{A}$ is the set of variables occuring in the body, incuding $\DT$.
\end{enumerate}

We will study the utility of these three types of rules later: systems in general only require recourse to order for mutable state and communication.  Inductive and asynchronous rules model each of these cases respectively.  Deductive rules enable embarassingly parallel execution of all other aspects of distributed systems. \wrm{eliding negation within a timestamp here}

Usage of $S$ or $T$ outside of the timestamp attributes is known as {\em entanglement}.  We will revisit this powerful construct in~\ref{sec:entangle}. 

\wrm{we can cut this example if we're short on space}
\begin{example}
The following are examples of well-formed deductive, inductive, and asynchronous rules, respectively.
\\
deductive:
\begin{Dedalus}
p(A, B, \(\DS\)) \(\leftarrow\) e(A, B, \(\DT\)), \(\DS\) = \(\DT\);
\end{Dedalus}
\\
inductive:
\begin{Dedalus}
q(A, B, \(\DS\)) \(\leftarrow\) e(A, B, \(\DT\)), successor(\(\DT\), \(\DS\));
\end{Dedalus}
\\
asynchronous:
\begin{Dedalus}
q(A, B, \(\DS\)) \(\leftarrow\) e(A, B, \(\DT\)), time(\(\DS\)), choose(A,B,\(\DT\)), (\(\DS\)));
\end{Dedalus}
\end{example}

\noindent{\bf Positive and Negative Predicates: }
For every extensional predicate \dedalus{r} in a \lang program $P$, we add to
$P$ two distinguished predicates \dedalus{r\pos} and \dedalus{r\nega} with the same schema
as \dedalus{r}.  We define \dedalus{r\pos} using the following rule:

\begin{dedalus}
r\pos($\bar{A}$,\(\DS\)) \(\leftarrow\)
\end{dedalus}

\hspace{5mm}
\begin{dedalus}
   r($\bar{A}$,\(\DT\)), \(S\)=\(\DT\);
\end{dedalus}

That is, for every extensional predicate \dedalus{r} there is an intensional
predicate \dedalus{r\pos} that contains at least the contents of \dedalus{r}.
Intuitively, this rule allows extensional facts to serve as ground for
\dedalus{r\pos}, while enabling other rules to derive additional \dedalus{r\pos} facts.

The predicate \dedalus{r\pos} may be referenced in the body or head of any \lang rule.  
We will make use of the predicate \dedalus{r\nega} later to capture the notion of mutable state; we return to it in Section~\ref{sec:mutable}. 
Like \dedalus{r\pos}, the use of \dedalus{r\nega} in the heads and bodies of rules is unrestricted.

\vspace{1.2em}
\noindent{\bf Guarded EDB: }
No well-formed \lang rule may involve any extensional predicate, except for a rule of the form above.

\subsection{Abbreviated Syntax and Temporal Interpretation}

\label{sec:abbrvsyntax}

%\wrm{i don't see the importance of the next 2 paras (before bullet points).  cut it?}
%We have been careful to define \lang as a subset of Datalog; this inclusion allows us to take advantage of Datalog's
%well-known semantics and the rich literature on the language.

%\lang programs are intended to capture 
%temporal semantics.  For example, a fact, \dedalus{p($C_1 \ldots C_n$, $C_{n+1}$)}, with some constant $C_{n+1}$ in its time
%suffix can be thought of as a fact that is true ``at time $C_{n+1}$''.
%%Deductive
%%rules can be seen as {\em atemporal} statements: they range over all values of
%%the time suffix, and express deductions that are ``always'' valid. 
%Deductive rules can be seen as {\em instantaneous} statements: their deductions hold for 
%predicates agreeing in the time suffix and describe what is true ``for an instant'' given 
%what is known at that instant.
% Inductive %%and asynchronous 
% rules are {\em temporal}---their consequents are defined to
%be true ``at a different time'' than their antecedents. 

To simplify \lang notation for this typical interpretation, we
introduce some syntactic ``sugar'' as follows:

\begin{itemize}
%
%why do we need this one??  \item {\em Time-suffix notation:}  Each predicate's
%time suffix  time-suffix attribute of each predicate is placed after the
%predicate's right parenthesis, separated by the symbol `@'.   For example, the
%predicate \\ $r(A_{1}, \ldots, A_{n}, S)$ is rewritten as $r(A_{1}, \ldots,
%A_{n})@S$.
%
\item {\em Implicit time-suffixes in body predicates:} Since each body
predicate of a well-formed rule has an existential variable $\DT$ in its
time suffix, we optionally omit the time suffix from each body predicate and treat
it as implicit.
%%\wrm{it's not a free variable unless there's only one body atom, right?  otherwise
%%it's restricted because it appears in multiple atoms.}
%
\item {\em Temporal head annotation:} Since there are a finite number of binding
possibilities (enumerated above) for the time suffix in a head predicate, we omit the time
suffix from the head---and its relevant constraints from the body---and
instead attach an identifier to the head predicate of each temporal rules, to indicate the change in
time suffix.  A temporal head predicate \dedalus{r} is of the form: \dedalus{r($\bar{A}$)@next},
while an asynchronous head predicate \dedalus{r} is of the form \dedalus{r($\bar{A}$)@async}.

\item {\em Timestamped facts:} For notational consistency, we write the time suffixes of facts in the EDB (which
must be given as a constant) outside the predicate.  For example:

\dedalus{r($A_1$,$A_2$,[...],$A_n$)@$\Consts$}

%
%\begin{enumerate}
%
%item \emph{next} implies the rule is inductive, and stands in for
%\linebreak\dedalus{successor($\DTau$,S)} in the body.
%
%\item \emph{async(N)} implies the rule is asynchronous, and stands in for
%\dedalus{successor(\_, S), choose((\_), (S))} in the body.  $N$ is a variable,
%corresponding to the time suffix $\DTau$ of all predicates in the rule body and
%optionally referenced in the head.  \wrm{this seems ugly to me}
%
%\end{enumerate}
%
\end{itemize}

%\wrm{the before stuff might be a bit to verbose and repetitive.}

\wrm{again we can cut this if we're out of space}
\begin{example}
%%Sugared deductive and inductive rules.
The following are ``sugared" versions of deductive and inductive rules from Example 1, and a temporal fact:
\\
deductive:
\begin{Dedalus}
p(A, B) \(\leftarrow\) e(A, B);
\end{Dedalus}
inductive:
\begin{Dedalus}
q(A, B)@next \(\leftarrow\) e(A, B);
\end{Dedalus}
asynchronous:
\begin{Dedalus}
q(A, B)@async \(\leftarrow\) e(A, B);
\end{Dedalus}
fact:
\begin{Dedalus}
e(1, 2)@10;
\end{Dedalus}

%%asynchronous
%%r(A, B)@async \(\leftarrow\) \wrm{inconsistency.  are we doing async(N)?}
%%  e(A, B);
\end{example}


\subsection{Distribution, Asynchrony and Choice}
\lang enables the modeling of {\em asynchronous} distributed systems.  A distributed system comprises multiple communicating agents, which are represented by identifiers.  \lang adopts the {\em horizontal partitioning} convention introduced by Loo et al.\ and used in many subsequent efforts~\cite{Loo:2005}, where all agents execute the same rules, but predicates are partitioned based on the value of the {\em location specifier}: a column of every relation that stores an agent's identifier.  We constrain \lang rules so that the location specifier variable in each body predicate be the same.  If the head of the rule has the same location specifier variable as the body, we call the rule ``local,'' since its results can remain on the machine where they are computed.  If the head has a different variable in its location specifier, we call the rule a {\em communication rule}.  Note that by restricting bodies to a single agent, the only communication modeled in \lang occurs via communication rules.  Derivation of a fact with another agent's identifier implies sending the fact to the agent.  Syntactically, location specifiers are prefixed with a \dedalus{\#} symbol in Dedalus.

We use choice to model the inherent nondeterminism associated with communication in {\em asynchronous} distributed systems.  For example, messages may be lost or arbitrarily delayed, and a receiver cannot infer that a message will never be sent based solely on his non-receipt of the message.  To this end, we require that any communication rules be \dedalus{@async} rules.

%Note that this model says nothing about the
%relationship between the agents' clocks; they could be
%non-monotonically increasing, or they could respect a global order.

% \jmh{the following is redundant and can be omitted}
% \lang facts are just datalog facts that conform to the schema constraint:  rule heads with empty bodies, and ground terms for all attributes including the time suffix.  To accommodate this in our notation,
% we allow a fourth suffix for the special case of empty bodies: a constant integer.  A \lang fact thus has the form:
% 
% $r(C_1, C_2, [...], C_n)@CI$
% 
% where $CI$ is an integer constant.


%Finally, we define the following shorthand for referring to the special IDB relations defined above.  Recall that for every EDB predicate $r$
%we have a uniquely defined pair of IDB predicates $r\pos$ and $r\nega$.  In a \lang program, we use $r$ as shorthand for $r\pos$ 

%(recall that the true EDB predicate $r$ cannot be referenced by any rules) and $delete$ $r$ as shorthand for $r\nega$.
%%A deductive rule as defined above will hold for any assignment of a constant integer to the $N$-value in the suffix of each predicate.

%%\subsection{Events}

%%\newdef{definition}{Definition} 
%%\begin{definition}
%
%%An \emph{event} in \lang is an EDB fact.
%
%%\end{definition}

%%\jmh{Isn't the following simply a restatement of Datalog's use of EDB?}
%%Since an extensional relation may not appear in a rule's head, events come from
%%sources external to the evaluation of the \lang instance.

