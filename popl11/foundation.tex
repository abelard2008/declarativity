\section{Foundation}
\label{sec:lang}

\lang is related to Datalog with negation (Datalog$\lnot$)~\cite{ullmanbook},hereinafter referred to
as Datalog.
%Datalog is first order logic enhanced with a {\em least-fixpoint operator}.
%\paa{Datalog doesn't have a LFP 'operator' -- it implies LFP with syntactic
%recursion.  you mean it's equivalent to FO(LFP)?}
Below, we provide a brief review of Datalog, and subsequently detail our
language in terms of Datalog.\nrc{I think there is too much background stuff:
  get to the good stuff faster. A competent reviewer should know this anyway;
  either cut or move to an appendix?}

\subsection{Datalog}
\label{sec:datalog}

A Datalog {\em program} comprises a set of {\em rules}.  A Datalog {\em rule}
is a first-order logical formula of the following form:
\dedalus{$p_0(\overline{X_0})$ :- $p_1(\overline{X_1})$, ...,
$p_j(\overline{X_j})$, $\lnot p_{j+1}(\overline{X_{j+1}})$, ..., $\lnot
p_k(\overline{X_k})$;}.  \dedalus{$p_0$, ..., $p_k$} are known as {\em
predicates}.  Each predicate, also called a {\em relation} or {\em table}, has
a fixed arity.  Predicates that appear on the left-hand side of some rule in
the program are called {\em intensional} predicates---the rest are called {\em
extensional}.  Each of $\overline{X_0}, ..., \overline{X_k}$ are lists of
arguments (constants or existentially quantified variables).  An application of
a predicate to a list of arguments is called an {\em atom}.  The same variable
symbol may appear in multiple atoms---in this case, we say that the atoms
are {\em unified} on the arguments that contain the duplicated variable.  The
single atom to the left of the \dedalus{:-} delimeter is the rule's {\em head},
and the set of atoms to the right is the rule's {\em body}.  If the head
predicate also appears in the rule's body, the rule is called {\em recursive}.\rcs{bad definition of recursion; misses recursion through two rules / predicates}
In addition to atoms, a rule's body may also contain the {\em order
constraints}: $=, \geq, >, \leq, <, \neq$, which restrict the values of
variables.  
%\paa{why quoted?  also -- "for each assignment of the body, given the model --
%right?}

An assignment of
constants to all arguments in a predicate is known as a {\em fact}---also
called a {\em tuple} or {\em row}---and we often speak of ``the facts in a
predicate,'' meaning the satisfying assignment of constants to the predicate's
arguments.
The logical meaning of a Datalog rule is that for each satisfying assignment of
constants to variables on the right-hand side, the tuple with the
corresponding assignment of constants in the left-hand side predicate exists.\rcs{satisfies the lhs?}
A possibly empty set of facts for the extensional predicates is
known as an {\em EDB} or extensional data base.  A Datalog {\em instance} is a
program together with an EDB.  All constants in the EDB are contained in the
{\em universe of constants} of the instance.

\subsection{Aggregation}

%%As a shorthand for common operations involving a number of rules, one often
%%admits {\em aggregation} into Datalog -- a special type of function that takes
%%a set as input and computes a scalar output.  
Datalog is commonly extended with {\em aggregate functions}: special
functions that take sets as input and compute a scalar output. Typical aggregate
functions include \dedalus{max}, \dedalus{min}, and \dedalus{count}.
%   We are interested in both
% {\em exemplary} aggregates---which return a value from the input set---such
% as \dedalus{max} and \dedalus{min}, and {\em summary} aggregates like
% \dedalus{count}.
%\paa{doesn't this notation seem to mean that only one aggregate per rule is
%allowed?} \wrm{yes, but we only ever use one agg per rule in the paper}
%\paa{reads strange.  "in particular, we are interested in foo things, and also
%non-foo things...  I see though that in 2.1.2 we need to have introduced
%exemplary functions}

%In general, aggregation involves universal quantification over a set, thus it
%is a non-monotonic construct.  Mumick and Shmueli observe that adding
%stratified aggregation to Datalog does not affect its expressive
%power~\cite{mumickshmueli}.  \wrm{non-exemplary aggs affect our expressive
%power}

Aggregation may only be used in the head of a rule.  A head atom
\dedalus{p($\bar{A}, \rho<B>$)}, where $\rho$ is an aggregate function symbol,
indicates that predicate \dedalus{p} contains one row for each satisfying
assignment of $\bar{A}$.  This row contains the value of the aggregate function
on the set of assignments to $B$ for the given value of $\bar{A}$. \nrc{Mention
  the relationship between negation and aggs?}

\subsection{Contradictions}

A Datalog instance without negation or aggregation has a unique {\em model}: the
minimal set of facts in intensional predicates implied by the EDB given the
program, or the intensional data base ({\em IDB})~\cite{ullmanbook}.  Adding
negation or aggregation to Datalog programs increases expressivity, but creates
the possibility of two additional types of programs: programs with no model,
i.e., programs with a {\em contradiction}---a fact that depends on its own
negation---and programs that have a multiplicity of
models~\cite{sacca-zaniolo}.  The computation of the model of a Datalog program
is an iterative procedure, where each iteration determines new facts.  Datalog
ensures termination of this procedure---and finiteness of the model---by
guaranteeing finiteness of the universe of constants.  Finiteness is guaranteed
by ensuring the EDB is finite, and restricting the use of constructs that can
expand the universe of constants such as non-exemplary functions and non-exemplary aggregates.

A Datalog program is called {\em monotonic} if the addition of
facts to the EDB never causes facts from the IDB to be retracted.  All Datalog
programs that exclude negation and aggregation are monotonic; the presence of
negation or aggregation may imply that the program is non-monotonic.

%%One intuition is that 
Negation and aggregation require {\em universal
quantification}:
%%-- that is they 
in general, they need to consider all elements in the
set that they operate over.  It is easy to see that addition of facts to the
EDB may cause set-wise properties to become untrue, which may lead to IDB
retractions.  On the other hand, adding a fact to the EDB can never cause an
existential quantification to become false.

\subsection{Stratification}

%Note that negation allows the specification of a program that is
%contradictory, such as $p(X) :- q(X), !p(X);$.  The reason for the
%contradiction is that given an EDB where \dedalus{p \cap q} is non-empty, each
%\dedalus{p} fact with a corresponding \dedalus{q} fact depends on its own
%negation (is simultaneousy both false and true).  
Contradictions are undesirable in logic programming. 
%\paa{usually?  it seems to me they are always undesirable, b/c in logic, I can
%use a constradictory premise to prove any arbitrary conclusion (rendering the
%language rather useless).  this is the same argument for why we always choose
%soundness over completeness.} \wrm{3-valued logic}
Unfortunately, detecting that a program is contradiction-free for all EDBs is
undecidable in general~\cite{papa-yanna}, so the logic programming community
has devised a number of conservative conditions called {\em stratification
conditions}, which ensure acyclicity of derivations through negation, but exclude some contradiction-free programs.  
One
condition is known as {\em syntactic stratification}, which excludes all
programs where a predicate \dedalus{p} transitively depends on
\dedalus{\(\lnot\)p}.  Clearly, this condition may exclude many useful
programs, because such a syntactic cycle may in practice never lead to a
contradiction if all {\em derivations} are acyclic.  Additional conditions,
such as {\em local stratification}~\cite{local-strat}, {\em universal
constraint stratification}~\cite{ross-syntactic}, {\em modular
stratification}~\cite{modular}, and {\em weak stratification}~\cite{weak-strat}
are increasingly less conservative.  Later we will introduce our own condition,
{\em temporal stratification}, which allows such syntactic cycles as long as
the program encodes the condition that \dedalus{p} occurs at a {\em later time}
than \dedalus{\(\lnot\)p}.

\subsection{Choice}

Having ruled out programs with contradiction, \rcs{confusing.  we don't disallow all contradictions, since we allow aggregates, negation, functions, etc...} we are interested in programs
that have a multiplicity of solutions because such programs can be used to
model non-determinism; we wish to model the inherent non-determinism in
asynchronous distributed systems.  The correspondence between multiple
solutions and non-determinism was formalized by Sacc\`{a} and
Zaniolo~\cite{sacca-zaniolo} as the \dedalus{choice} construct.  Intuitively,
\dedalus{choice} allows the specification of a functional dependency in a rule.
For example, \dedalus{p(X,Y) :- q(X,Y), choice( (X), (Y) );} expresses that for
each value that variable \dedalus{X} takes on, variable \dedalus{Y} may only
take on a single {\em non-deterministically chosen} value. If \dedalus{q}
contains more than one \dedalus{Y} value for an \dedalus{X}, then the instance
has multiple models: one corresponding to each choice of \dedalus{Y} for each
\dedalus{X}.  Operationally, the answer to a Datalog program with choice
corresponds to a non-deterministic choice of one of the models.

See~\cite{sacca-zaniolo} for the details on how \dedalus{choice} is expanded
into Datalog rules that employ cyclic negation.  Although \dedalus{choice}
cannot cause a contradiction, its expansion violates many stratification
conditions.  Thus, we often must explicitly admit programs with \dedalus{choice}
after ruling out certain {\em unstratified} programs---programs that violate
the stratification condition.

\section{\lang}

Dedalus is a subset of Datalog, with \dedalus{choice}, an infinite
\dedalus{time} relation $\mathbb{N}$, and a \dedalus{successor}
%$(\mathbb{N} \cup \top)$
relation, which is isomorphic to $+1$ on $\mathbb{N}$.  The intuition behind
\lang's \dedalus{successor} relation is that it models the passage of logical
time.  In our discussion, we will say that facts with lower time suffixes occur
``before'' atoms with higher ones.  If we wish to model possible message loss,
we may admit a special element $\infty$ \rcs{was $\top$ which is confusing, (and wrong, unless we decide that time is a lattice, which might be a useful model of lamport clocks, parallelism, etc, but is not how we present time in this paper...)} into \dedalus{time}.  We exclude message
loss and node failure in this paper to simplify the discussion, though we explicitly deal with such issues in other work~\cite{dedalus-techr, netdb}. \rcs{this used to claim we had some implicit protocol, which was distractiong/misleading.  plus, not even paxos can rule out message loss for all execution traces (such as the ones with too many node failures...)}
%Intuitively, $\top$ is meant to model the time {\em never}.
We will see later how \dedalus{successor} forms the basis of a stratification
condition that we call {\em temporal stratification}.

\subsection{Syntactic Restrictions}
\label{sec:syntaxrestrictions}

Specifically, we restrict the form of predicates and rules in the following ways:

\noindent{\bf Time Suffix: }We require that the final attribute of every \lang
predicate range over the \dedalus{time} domain.  
%\lang considers this final attribute as a ``timestamp,'' so
We refer to this attribute as the \emph{time suffix} of the corresponding
predicate, and we speak of the {\em timestamp} of a fact. \rcs{Removed:''---we also refer to
facts as {\em events}.''  We need to talk about async before talking about events.  Also, we should define ``event'' as ``a tuple produced by async rules''.}

\noindent{\bf Unification on Time: }
%$p(C_{1},C_{2},[...],C_{n}, i) |  i \in \mathbb{Z} \cup \top$ The balance of
%our restrictions concern the well-formedness of \dedalus rules.
%\begin{definition}
%
%An \emph{extensional} predicate in a \slang program $P$ is a predicate that
%does not appear in the head of any rule in $P$.
%
%\end{definition} \wrm{we really want an inclusion constraint not just in the
%set of integers, but in the set of all possible times, in case time is
%finite}.  \jmh{I disagree, actually.  EDB facts can be sprinkled throughout
%time without restriction, and the rule syntax below provides the restrictions
%you want.  you're hinting at the reduction stuff below, but we can rewrite to
%that.}
In a well-formed \lang rule, every body predicate's time suffix is bound to the
same variable symbol.  For ease of exposition, we henceforth assume that this
variable symbol is named $\DT$.  A well-formed \lang rule must also bind the
head predicate's time suffix to a variable symbol.  We will assume the name of
this variable symbol is $\DS$.  $\DS$ may be constrained in exactly one of
three ways:

\begin{enumerate}
%
\item The rule is {\em deductive} if $\DS$ is bound to the value
$\DT$; that is, the body contains \dedalus{$\DS$ = $\DT$}.
%
\item The rule is {\em inductive} if $\DS$ is the successor of
$\DT$; that is, the body contains \dedalus{successor($\DT$, $\DS$)}.
%
\item The rule is {\em asynchronous} if $\DS$ is unrelated to $\DT$;
that is, the body contains \dedalus{time($\DS$), choose(($\overline{A}$),
($\DS$))}, where $\overline{A}$ is the set of variables occurring in the body,
including $\DT$.
%
\end{enumerate}

We will study the utility of these three types of rules later: systems in
general only require such to ordering primitives for mutable state and communication.
Inductive and asynchronous rules model these cases respectively.
%Deductive rules enable embarassingly parallel execution of all other aspects of
%distributed systems.

Usage of $S$ or $T$ outside of the time suffixes is known as {\em
entanglement}.  We will revisit this powerful construct in~\ref{sec:entangle}. 

\wrm{we can cut this example if we're short on space}\rcs{merge with example 2, which is just the sugar corresponding to this example}
\begin{example}
The following are examples of well-formed deductive, inductive, and asynchronous rules, respectively.
\\
deductive:
\begin{Dedalus}
p(A, B, \(\DS\)) \(\leftarrow\) e(A, B, \(\DT\)), \(\DS\) = \(\DT\);
\end{Dedalus}
\\
inductive:
\begin{Dedalus}
q(A, B, \(\DS\)) \(\leftarrow\) e(A, B, \(\DT\)), successor(\(\DT\), \(\DS\));
\end{Dedalus}
\\
asynchronous:
\begin{Dedalus}
r(A, B, \(\DS\)) \(\leftarrow\) e(A, B, \(\DT\)), time(\(\DS\)),
   choose(A,B,\(\DT\)), (\(\DS\)));
\end{Dedalus}
\end{example}
\rcs{We use the following syntactic sugar for clarity, and to syntactically preclude the use of entanglement: ... ex 2 stuff ... }
\noindent{\bf Positive and Negative Predicates: }
For every extensional predicate \dedalus{r} in a \lang program $P$, we add to
$P$ two distinguished predicates \dedalus{r\pos} and \dedalus{r\nega} with the same arity
as \dedalus{r}.  We define \dedalus{r\pos} using the following rule:\rcs{this leads to akwardness later.  perhaps we should define an \dedalus{r} and an \dedalus{r edb}}

\begin{dedalus}
r\pos($\overline{A}$,\(\DS\)) \(\leftarrow\) r($\overline{A}$,\(\DT\)), \(S\)=\(\DT\);
\end{dedalus}

% \hspace{5mm}
% \begin{dedalus}
   
% \end{dedalus}

\noindent{}That is, for every extensional predicate \dedalus{r} there is an intensional
predicate \dedalus{r\pos} that contains at least the contents of \dedalus{r}.
Intuitively, this rule allows extensional facts to serve as ground for
\dedalus{r\pos}, while enabling other rules to derive additional \dedalus{r\pos} facts.

The predicate \dedalus{r\pos} may be referenced in the body or head of any \lang rule.  
We will make use of the predicate \dedalus{r\nega} later to capture the notion of mutable state; we return to it in Section~\ref{sec:mutable}. 
Like \dedalus{r\pos}, the use of \dedalus{r\nega} in the heads and bodies of rules is unrestricted.

\vspace{1.2em}
\noindent{\bf Guarded EDB: }
No well-formed \lang rule may involve any extensional predicate, except for a rule of the form above.

\subsection{Abbreviated Syntax and Temporal Interpretation}

\label{sec:abbrvsyntax}

%\wrm{i don't see the importance of the next 2 paras (before bullet points).  cut it?}
%We have been careful to define \lang as a subset of Datalog; this inclusion allows us to take advantage of Datalog's
%well-known semantics and the rich literature on the language.

%\lang programs are intended to capture 
%temporal semantics.  For example, a fact, \dedalus{p($C_1 \ldots C_n$, $C_{n+1}$)}, with some constant $C_{n+1}$ in its time
%suffix can be thought of as a fact that is true ``at time $C_{n+1}$''.
%%Deductive
%%rules can be seen as {\em atemporal} statements: they range over all values of
%%the time suffix, and express deductions that are ``always'' valid. 
%Deductive rules can be seen as {\em instantaneous} statements: their deductions hold for 
%predicates agreeing in the time suffix and describe what is true ``for an instant'' given 
%what is known at that instant.
% Inductive %%and asynchronous 
% rules are {\em temporal}---their consequents are defined to
%be true ``at a different time'' than their antecedents. 

To simplify \lang notation, we introduce some syntactic ``sugar'' as follows:

\begin{itemize}
%
%why do we need this one??  \item {\em Time-suffix notation:}  Each predicate's
%time suffix  time-suffix attribute of each predicate is placed after the
%predicate's right parenthesis, separated by the symbol `@'.   For example, the
%predicate \\ $r(A_{1}, \ldots, A_{n}, S)$ is rewritten as $r(A_{1}, \ldots,
%A_{n})@S$.
%
\item {\em Implicit time-suffixes in body predicates:} Since the binding
pattern for time suffixes in a rule body is constrained, we omit the time
suffix from each body predicate and treat it as implicit.

\item {\em Temporal head annotation:} Since there are a finite number of
binding possibilities (enumerated above) for the time suffix in a head
predicate, we omit the time suffix from the head--and its relevant constraints
from the body--and instead attach an identifier to the head predicate of each
temporal rule, to indicate the change in time suffix.  An inductive head
predicate \dedalus{r} is of the form: \dedalus{r($\overline{A}$)@next}, while
an asynchronous head predicate \dedalus{r} is of the form
\dedalus{r($\overline{A}$)@async}.

\item {\em Timestamped facts:} For notational consistency, we write the
timestamps of facts, in the EDB outside the
predicate.  Note that timestamps must be constants.  For example:

\dedalus{r($\overline{A}$)@$\Consts$}

%
%\begin{enumerate}
%
%item \emph{next} implies the rule is inductive, and stands in for
%\linebreak\dedalus{successor($\DTau$,S)} in the body.
%
%\item \emph{async(N)} implies the rule is asynchronous, and stands in for
%\dedalus{successor(\_, S), choose((\_), (S))} in the body.  $N$ is a variable,
%corresponding to the time suffix $\DTau$ of all predicates in the rule body and
%optionally referenced in the head.  \wrm{this seems ugly to me}
%
%\end{enumerate}
%
\end{itemize}

%\wrm{the before stuff might be a bit to verbose and repetitive.}

\wrm{again we can cut this if we're out of space}
\begin{example}
%%Sugared deductive and inductive rules.
The following are ``sugared" versions of deductive, inductive and asynchronous rules from Example 1, and a temporal fact:
\\
deductive:
\begin{Dedalus}
p(A, B) \(\leftarrow\) e(A, B);
\end{Dedalus}
inductive:
\begin{Dedalus}
q(A, B)@next \(\leftarrow\) e(A, B);
\end{Dedalus}
asynchronous:
\begin{Dedalus}
r(A, B)@async \(\leftarrow\) e(A, B);
\end{Dedalus}
fact:
\begin{Dedalus}
e(1, 2)@10;
\end{Dedalus}

%%asynchronous
%%r(A, B)@async \(\leftarrow\) \wrm{inconsistency.  are we doing async(N)?}
%%  e(A, B);
\end{example}

\subsection{Distribution, Asynchrony and Choice}

\lang adopts the {\em horizontal partitioning} convention introduced by Loo et
al.~\cite{Loo:2005}, where all agents execute the same rules but predicates
are partitioned based on the value of the {\em location specifier}: a column of
every relation that stores an agent's identifier. In \lang, we require that all
atoms in the body of a single rule use the same location specifier. If the location
specifier of a rule's head is bound to the body's location specifier, then we
call the rule {\em local}.  Otherwise, we call the rule a {\em communication rule}.
Note that by restricting rule bodies to a single agent, the only communication
modeled in \lang occurs via communication rules.  Derivation of a fact with
another agent's identifier implies sending the fact to the agent.
Syntactically, location specifiers are prefixed with a \dedalus{\#} symbol in
Dedalus.

We use choice to model the inherent nondeterminism associated with
communication in {\em asynchronous} distributed systems.  For example, messages
may be arbitrarily delayed, and a receiver cannot infer that a message will
never be sent based solely on his non-receipt of the message (it may arrive
arbitrarily far in the future).
%\nrc{Sec 2.2 says that we don't discuss message loss in this paper.}
To this end, we require that any communication rules be \dedalus{@async} rules.

We call the set of facts, including their timestamps, derived by communication
rules during a particular execution a {\em trace} of the program.
Each trace is associated with exactly one model of the program.

%\wrm{however, in this paper we assume bounded message delivery time, in other words top is ruled out of time. (note that this can be ensured in logic by admitting timers and doing retries)}

%Note that this model says nothing about the
%relationship between the agents' clocks; they could be
%non-monotonically increasing, or they could respect a global order.

% \jmh{the following is redundant and can be omitted}
% \lang facts are just datalog facts that conform to the schema constraint:  rule heads with empty bodies, and ground terms for all attributes including the time suffix.  To accommodate this in our notation,
% we allow a fourth suffix for the special case of empty bodies: a constant integer.  A \lang fact thus has the form:
% 
% $r(C_1, C_2, [...], C_n)@CI$
% 
% where $CI$ is an integer constant.


%Finally, we define the following shorthand for referring to the special IDB relations defined above.  Recall that for every EDB predicate $r$
%we have a uniquely defined pair of IDB predicates $r\pos$ and $r\nega$.  In a \lang program, we use $r$ as shorthand for $r\pos$ 

%(recall that the true EDB predicate $r$ cannot be referenced by any rules) and $delete$ $r$ as shorthand for $r\nega$.
%%A deductive rule as defined above will hold for any assignment of a constant integer to the $N$-value in the suffix of each predicate.

%%\subsection{Events}

%%\newdef{definition}{Definition} 
%%\begin{definition}
%
%%An \emph{event} in \lang is an EDB fact.
%
%%\end{definition}

%%\jmh{Isn't the following simply a restatement of Datalog's use of EDB?}
%%Since an extensional relation may not appear in a rule's head, events come from
%%sources external to the evaluation of the \lang instance.

%\wrm{define trace}

