\section{Challenge: Correct, Distributed Shopping Carts}

Consider a simple distributed application that provides a scalable,
fault-tolerant ``shopping cart'' service for commercial websites.
Such systems are typically built atop a storage tier that provides a
read/write interfaces to objects.  In order to provide scalabilty and
fault-tolerance, such storage tiers provide weaker semantics than
those provided by local storage systems.  Specifically, for fault
tolerance, such systems store multiple (and therefore sometimes
inconsistent) copies of each data item.  Also, in order to scale, such
systems avoid computing a total order of the updates to the entire
database.

Two sets of semantics that are of particular interest are {\em
  per-tuple ordering}\rcs{better name?}, in which updates to a given piece of data are
always applied in the same order, and {\em eventual consistency},
which guarantees that each copy of a piece of data will agree once the
system quiesces.

The operations performed by our shopping cart are special in two ways.
First, it is possible to specify them in a way that is {\em
  commutative}; if each replica can guarantee that each operation
against the cart is applied exactly once (but in some arbitrary order)
the system will provide eventual consistency.  Second, because
shopping carts are updated by a single client at a time, the client
can impose a total ordering of the updates to its cart.  Again, once
each update reaches each replica (and is applied in the correct
order), the system will be consistent.

Our motivating example will order the updates at the client; ordering
updates at the server is more complex, though our group has
implemented the necessary machinery atop distributed logic languages
in the past~\cite{bfs-paxos}.  For completeness, Section~\ref{sec:casestudy}
sketches an approach based upon commutative writes.

\rcs{wrm and I were confused by the old text. does the new text above make sense?}

%While it is common in
%practice to implement such applications above a key-value store tier that
%provides a read/write interface to objects, such a separation of tiers limits
%the ability of the storage substrate to exploit application-level semantics.
%Hence a design decision needs to be made: should the application provide its
%own storage or use a store?  \wrm{okay i'm lost here.} Our motivating example
%will do the former, though we will explore the latter option in more detail in
%section~\ref{sec:casestudy}.

Our shopping cart application will consist of a client and a (distributed)
server component.  The client converts user input into messages sent to
the server which describe updates to the cart, and the server stores these 
messages.  
A practical shopping cart would provide a mechanism to {\em check out}; that is,
summarize the cart contents, but we will postpone this discussion until later.
To make the application fault-tolerant and to increase availability, 
we will need to replicate the stored state to server replicas.  Ideally, however,
this state replication can occur asynchronously, as wait-free message handling
will decrease request latency and increase availability.  This cheap communication
cannot come at the cost of consistency -- all replicas should eventually reach
the same state -- but we may be willing to wait a long time for such convergence.

Therefore we wish to reason about whether our implementation possesses the desirable 
properties that, in spite of message reordering and the possibility of the simultaneous
receipt of multiple messages, all executions of the client code for the same series of
input will produce the same state on all replicas.  

The imperative pseudocode for the client component is trivial: we assume the existence
of a function {\em best\_replica} that will return the address of a server replica.

\begin{Dedalus}
while(in = client_input()) do
  send(best_replica(), in);
done
\end{Dedalus}


The pseudocode for the server component processes incoming messages one
at a time.  The values in the hash {\em cart\_state} (keyed on the session identifiers) 
are the union of 

\begin{Dedalus}
initialize hash cart_state
while true do
  req = receive message
  if defined cart_state[req.session] then
     cart_state[req.session] =  
       (req \(\cup\) cart_state[req.session]) 
  else 
    cart_state[req.session] = { req } 
  endif
  foreach r in replicas do
    send(r, req);
  done
done
\end{Dedalus}


Several difficulties present themselves.
First, it is not obvious from a static analysis of the code that the client and server are
part of a single distributed system, so we must analyze each of the agents individually.
If we assume conservatively that repeated calls to {\em receive message} will return messages in
arbitrary order, verifying the first property (essentially, order-independence of messages)
is tantamount to showing that the {\em union} operation is
order-insensitive, which could in principle be inferred from annotations associated
with the operator.
In this imperative approach, we happen to also know that the semantics of {\em receive message}
hide a {\em queue} which ensures that only one message (perhaps arbitrarily chosen in the
even of simultaneous receipt) is returned by each call.


In a distributed logic language like Overlog~\cite{boom-eurosys}, the entire program 
can be expressed with a pair of rules describing how clients send {\em cart\_action}
messages to a server and how servers multicast such tuples to other replicas, and 
a declaration that defined {\em cart\_action} as a persisted table:

\begin{Dedalus}
persist[cart_action, 5];
cart\_action(#Server, Client, Session, Item, Type) :-
  action(#Client, Session, Item, Type, ReqId),
  best_replica(#Client, Session, Server);

cart\_action(#Remote, C, S,S, I, T) :-
  cart\_action(#Local, C, S, I, T),
  replicas(#Local, C, S, Remote);
\end{Dedalus}

As is common in logic programming languages, each line is read as a backwards
implication ($\rightarrow$); if there is a satisfying assignment of tuples to each of
the predicates appearing in the body (with ``,'' read as conjunction), 
then there is a tuple in the head with the same bindings.
Note that the distributed system is expressed as a single, global program.
Because messages are themselves deductions, there are opportunities to 
analyze server and client code together.  We can analyze the program to 
show that cart\_action, a set that is persitently and immutably
stored, is insensitive to the arrival order of messages 
\wrm{i thought it's an
associativity thing, not a commutativity thing}
and to the co-occurrence of multiple messages simultaneously
. Moreover, the code 
itself is succinct and straightforward. 




When we consider the case of multiple messages with the same values for
{\em client, session, item}, and {\em type} (e.g. adding two of the same items to a cart)
we see that both the imperative and logical implementations are underspecified.
The set semantics of $\cup$ in the first implementation and the implicit union 
in the second rule this out, so we need some way of uniquely identifying each message.
Of course, this is trivial in an imperative language (and so common that many such languages
provide a shorthand like $++$ for self-increment), but difficult to express in a logic language:

\begin{Dedalus}
ca_stage(Server, Client, Session, Item, Type, ReqId) :-
  action(Client, Session, Item, Type),
  best_replica(Client, Session, Server),
  s(ReqId);

cart_action(#L, C, S, I, T, R) :-
  ca_stage(L, #C, S, I, T, R);

s(0);
s(X+1) \(\leftarrow\)  s(X), action(_, _, _, _, _);

\end{Dedalus}


The intent of the rule defining {\em s} is that s contains an integer, initialized to
zero, which should be incremented by one whenever an {\em action} event occurs,
regardless of its values.  Many distributed logic languages allow rules of this kind,
but its semantics are unclear.  Though on the surface the rule says that if {\em action} is true
the value of {\em s} should be infinitely incremented, this pattern is common enough
that many interpreters provide the intended semantics, at the cost of losing a logical
interpretation of the implication statement.  Equally problematic is the second rule above,
an implication which induces communication, for it is certainly not the case that the consequence of the rule's evaluation (the left-hand side) is true whenever the antecedent is
true.  

In both cases, what is missing is a notion of time.  The incremented sequence value should
be ``true'' at the {\em next} visible state of the system, and the deduced {\em cart\_action}
tuple should (ignoring message loss) be true at {\em some} unspecified future time.
In the remainded of the paper, we present \lang, which restores a logical interpretation to
both state change and asynchrony.  We will return to the shopping cart example in more detail 
in section~\ref{sec:casestudy}.

