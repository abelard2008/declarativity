\section{Challenge: Correct, Distributed Shopping Carts}

Consider a simple distributed application that provides a fault-tolerant
``shopping cart'' service for commercial websites.  While it is common in
practice to implement such applications above a key-value store tier that
provides a read/write interface to objects, such a separation of tiers limits
the ability of the storage substrate to exploit application-level semantics.
Hence a design decision needs to be made: should the application provide 
its own storage or use a store?  Our motivating example will do the former,
though we will explore the latter option in more detail in section~\ref{sec:casestudy}.

Our shopping cart application will consist of a client and a (distributed)
server component.  The client converts user input into messages sent to
the server which describe updates to the cart, and the server stores these 
messages.  
A practical shopping cart would provide a mechanism to {\em check out}; that is,
summarize the cart contents, but we will postpone this discussion until later.
To make the application fault-tolerant and to increase availability, 
we will need to replicate the stored state to server replicas.  Ideally, however,
this state replication can occur asynchronously, as wait-free message handling
will decrease request latency and increase availability.  This cheap communication
cannot come at the cost of consistency -- all replicas should eventually reach
the same state -- but we may be willing to wait a long time for such convergence.

Therefore we wish to reason about whether our implementation possesses the desirable 
properties that, in spite of message reordering and the possibility of the simultaneous
receipt of multiple messages, all executions of the client code for the same series of
input will produce the same state on all replicas.  


Client pseudocode:

\begin{Dedalus}
while(in = client_input()) do
  send(best_replica(), in);
done
\end{Dedalus}

\begin{Dedalus}
initialize hash cart_state
while (req = receive message) do
  if cart_state has key req.session then
     cart_state[req.session] =  (req \(\cup\) cart_state[req.session]) 
  else 
    cart_state[req.session] = { req } 
  endif
  foreach r in replicas do
    send(r, req);
  done
done
\end{Dedalus}




Several difficulties present themselves.
First, it is not obvious from a static analysis of the code that the client and server are
part of a single distributed system, so we must analyze each of the agents individually.
If we assume conservatively that repeated calls to {\em receive message} will return messages in
arbitrary order, verifying the first property (essentially, order-independence of messages)
is tantamount to showing that the {\em union} operation is
order-insensitive, which could in principle be inferred from annotations associated
with the operator.
In this imperative approach, we happen to also know that the semantics of {\em receive message}
hide a {\em queue} which ensures that only one message (perhaps arbitrarily chosen in the
even of simultaneous receipt) is returned by each call.






\paa{rest are notes}

In a distributed logic language like Overlog~\cite{boomanalytics}, the entire program 
can be expressed with a pair of rules describing how clients send {\em cart\_action}
messages to a server and how servers multicast such tuples to other replicas.

\begin{Dedalus}
persist[cart_action, 5];
cart\_action(#Server, Client, Session, Item, Type) :-
  action(#Client, Session, Item, Type, ReqId),
  best_replica(#Client, Session, Server);

cart\_action(Remote, C, S,S, I, T) :-
  cart\_action(#Local, C, S, I, T),
  replicas(#Local, C, S, Remote);
\end{Dedalus}

the program is global -- server and client code can be co-analyzed, b/c messages are deductions.

we can analyze the program to show that cart\_action, a set that is persitently and immutably
stored, is insensitive to the order of messages.

the code is succinct and straightforward. 

but we need to deal with the case of multiple messages with the same values for
(client, session, item, type) -- e.g. adding two of the same items to a cart.  the set semantics
of union in the first implementation and the implicit union in the second rule this out,
so we need to uniquely identify each message.

this is trivial in an imperative language (++) but difficult to express in a logic language:

\begin{Dedalus}
// client code

cart_action_stage(Server, Client, Session, Item, Type, ReqId) :-
  action(Client, Session, Item, Type),
  best_replica(Client, Session, Server),
  s(ReqId);

cart_action(#L, C, S, I, T, R) :-
  cart_action_stage(L, #C, S, I, T, R);

s(X+1) \(\leftarrow\)  s(X), action(_, _, _, _, _);
\end{Dedalus}

the idea is, add one to seq() whenever action is true.

etc, etc, we need to incorporate explicit time into the language.
