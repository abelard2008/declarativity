\section{Challenge: Correct, Distributed Shopping Carts}

Consider a simple distributed application that provides a fault-tolerant
``shopping cart'' service for commercial websites.  While it is common in
practice to implement such applications above a key-value store tier that
provides a read/write interface to objects, such a separation of tiers limits
the ability of the storage substrate to exploit application-level semantics.
Hence a design decision needs to be made: should the application provide 
its own storage or use a store?  Our motivating example will do the former,
though we will explore the latter option in more detail in section~\ref{sec:casestudy}.

Our shopping cart application will consist of a client and a (distributed)
server component.  The client converts user input into messages sent to
the server which describe updates to the cart.   

\begin{Dedalus}
while(in = client_input()) do
  send(server, in);
done
\end{Dedalus}

The server stores these messages
and forwards them to replicas which provide fault-tolerance for the cart state:


\begin{Dedalus}
cart_state = new Hash;
while (req = recv()) do
  if (cart_state.has_key(req.session)) 
    curr = cart_state.get(req.session)
    curr.union(req);
  else 
    cart_state.put(req.session, new Cartobj(req));
  endif
  foreach r in replicas do
    send(r, req);
  done
done
\end{Dedalus}
A practical shopping cart would provide a mechanism to {\em check out}; that is,
summarize the cart contents, but we will postpone this discussion until later.

Suppose that we wish to verify whether this implementation possesses the desirable 
properties that, in spite of message reordering and the possibility of the simultaneous
receipt of multiple messages, all executions of the client code for the same series of
input will produce the same state on all replicas.  Several difficulties present themselves.

\begin{Dedalus}
persist[cart_action, 5];
cart_action(#Server, Client, Session, Item, Type)@async :-
  action(Client, Session, Item, Type, ReqId),
  best_replica(Client, Session, Server);
\end{Dedalus}



\begin{Dedalus}
// client code

cart_action_stage(Server, Client, Session, Item, Type, ReqId) :-
  action(Client, Session, Item, Type),
  best_replica(Client, Session, Server),
  s(ReqId);

cart_action(#L, C, S, I, T, R) :-
  cart_action_stage(L, #C, S, I, T, R);

s(X+1)@next \(\leftarrow\)  s(X), action(_, _, _, _, _);


\end{Dedalus}