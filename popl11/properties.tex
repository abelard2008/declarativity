\section{Properties}

blah blah blah

\subsection{Temporal Stratification}

blah blah blah

\subsubsection{Operational Semantics of Timestamp Assignment}

Nothing in our definition of asynchronous rules prevents tuples
in the head of a rule from having a timestamp that precedes the
timestamp in the ruleâ€™s body. This may violate temporal stratification.
On an intuitive level, it may also trouble us that rules can
derive head tuples that exist ``before'' the body tuples on which they
are grounded; this violates intuitive notions of causality and admits
the possibility of temporal paradoxes.

We have avoided restricting Dedalus to rule out such issues, as
doing so would reduce its expressiveness. Recall that simple mono-
tonic Datalog (without negation) is insensitive to the values in any
particular attribute. Hence Dedalus programs without negation are
also well-defined regardless of any ``temporal ordering'' of deduc-
tions: in monotonic programs, even if tuples with timestamps ``in
the future'' are used to derive tuples ``from the past,'' there is an un-
ambiguous least minimal model.


Since \dedalus{@async} does not preclude derivations that precede their antecedents in time, these programs may not be modularly stratified.  A simple way to fix this is to constrain the choice clause so that the head timestamp variable is only chosen from the set of times greater than the body timestamp variable.  Unfortunately, this fails to preserve temporal stratification in the distributed case, because at the same point in real time, because different nodes logical clocks may advance at different speeds, and due to the wall-clock time delay between the derivation and receipt of the message.  Because of this, the sender cannot choose the timestamp at which the receiver will receive a \dedalus{@async} fact in the distributed case. \wrm{i think this is obvious, but provide a proof?}

Thus, the receiver must set the timestamp on incoming \dedalus{@async} facts.  Can such a timestamp assignment rule be expressed in logic?  Clearly, the rule would not be a Dedalus rule, because Dedalus rules prohibit arbitrary modification of the head timestamp.  In fact, no such rule can be expressed in logic.  Such a rule would need to compute the ``next unused timestamp,'' \wrm{show this is necessary and sufficient} as new incoming facts would need to occur at a stricty higher timestamp than any existing program facts.  Assume there is a rule that models the ``next unused timestamp''.  Clearly, this rule must quantify over the current timestamps of all facts in all predicates.  As a transitive consequence, this rule will derive a new fact with a higher timestamp.  This derivation must happen at a timestamp that the original rule does not quantify over, otherwise the derivation will occur only at infinity.  However, if the original rule does not quantify over all time, it cannot produce a correct value for the ``next unused timestamp.''

Since timestamp assignment cannot be modeled in logic, we define an operational semantics of timestamp assignment: \wrm{put in fancy-pants figures?}  the receiver assigns the ``next unused timestamp'' to an incoming fact.

\subsubsection{Reality Constraint}

\dedalus{@async} is clearly more liberal than our operational semantics defined above.  One of our goals is formal verification of distributed systems.  Thus, for the particular use-case of distributed execution with the above operational semantics, we need to discover a logical condition that results in a set of models that exhibit the same set of behaviors.  It is  necessary and sufficient for each fact to carry an entangled timestamp from each node.  Timestamps must be propagated through derivations \wrm{explain}.  When a node receives a fact, it will need to delay processing of the fact until its current time is greater than its entangled timestamp.  Note that this scheme employs vector clocks.

Note that the use of Lamport clocks enforces additional constraints by ruling out more possible interleavings of events than the operational semantics for timestamp assignment. \wrm{check if this is true}

\subsection{Temporal Safety}

Next we consider the issue of infinite results.  In traditional Datalog, a Datalog program is considered safe if it has a finite
minimal model, and hence has a finite execution. Safety in Datalog is ensured by requiring a finite universe of constants \wrm{cite}.

In Dedalus, the program's result is the limit of the program as time goes to infinity.  Nonconvergence is a special case that we handle in the style of a {\em partial fixpoint}: nonconvergent facts are considered to be false.  Other work has proposed the use of infinite objects to represent nonconvergent results \wrm{cite chomicki}.  Absent entanglement, the set of convergent facts is always finite and can be efficiently computed \wrm{cite the paper that has the algorithm for this}.  Additionaly, we presented conservative syntactic conditions in previous work to guarantee convergence for all EDBs \wrm{cite tech report}.

However, in this work, we regard the limit of the program as only those predicates declared {\em naively persistent}.  \wrm{how do we ensure finiteness????}




