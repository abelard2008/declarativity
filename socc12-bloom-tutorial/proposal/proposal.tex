\documentclass{sig-alternate}
\usepackage{color}
\usepackage{graphicx}
\usepackage{url}
\usepackage{xspace}
\usepackage[T1]{fontenc}
\usepackage{times}
%\usepackage{mathptmx}    % use "times" font, including for math mode
\usepackage{txfonts}  % apparently needed to fixup the formatting of lstlistings
\usepackage{textcomp}
\usepackage[protrusion=true,expansion=true]{microtype}
\usepackage{paralist}
\usepackage{comment}
%\usepackage[hidelinks]{hyperref}

\frenchspacing

\begin{document}

\title{Distributed Programming with Bloom}

\numberofauthors{3}
\author{
\alignauthor
Peter Alvaro\\
        \affaddr{UC Berkeley}\\
        \email{palvaro@cs.berkeley.edu}
\alignauthor
Neil Conway\\
        \affaddr{UC Berkeley}\\
        \email{nrc@cs.berkeley.edu}
\alignauthor
Joseph M.\ Hellerstein\\
        \affaddr{UC Berkeley}\\
        \email{hellerstein@cs.berkeley.edu}
}

\maketitle

\section{Introduction}

In recent years, distributed programming has become a topic of widespread
interest among developers. However, writing reliable distributed programs
remains stubbornly difficult. In addition to the inherent challenges of
distribution---asynchrony, concurrency, and partial failure---many modern
distributed systems operate at massive scale. Scalability concerns have in turn
encouraged many developers to eschew strongly consistent distributed storage in
favor of application-level consistency criteria~\cite{Birman2009,Helland2009},
which has raised the level of difficulty still further.

In this tutorial, we will introduce \emph{Bloom}, a language for distributed
programming that we have developed at UC Berkeley~\cite{bloom-website}. We will
show how Bloom can be used to develop declarative, readable distributed
programs. Our focus will be on using Bloom to develop well-known distributed
systems infrastructure components, including a key-value store, quorum
replication, a distributed lock manager with deadlock detection, and a
distributed commit protocol.

In addition to introducing Bloom and showing how distributed logic can be used
to implement realistic designs, our emphasis will be on how the unique features
of Bloom help programmers understand the \emph{semantics} of their distributed
programs. In particular, we will discuss the \emph{CALM Theorem}, which
establishes a connection between \emph{logical monotonicity} and
\emph{distributed
  consistency}~\cite{Alvaro2011,Ameloot2011,Hellerstein2010,dedalus-confluence}. We
will review recent work on developing eventually consistent programs using
\emph{lattices} and \emph{monotone functions}~\cite{Conway2012}. We will also
compare Bloom to other recent proposals for principled eventually consistent
programming~\cite{Burckhardt2012,Shapiro2011a,Shapiro2011b}. Using tools distributed with the
Bloom runtime, we will show how programmers can visualize the distributed
behavior of their programs, reason about the monotonicity of software
components, compose individual monotonic components into larger programs, and
employ Bloom's built-in tools for systematic distributed
testing~\cite{Alvaro2012}.

The tutorial will be \emph{interactive}, in that simple installation
instructions for the Bloom runtime will be provided and attendees will be given
the complete source code for all example programs. During the tutorial, we plan
to use the Bloom runtime to execute example programs, use the the built-in Bloom
analysis tools to understand program behavior, and iteratively refine programs
as appropriate. Attendees will have the option to run the tools themselves,
although participation int this manner will not be mandatory. Note that for time
reasons we do not expect attendees to develop Bloom programs from scratch during
the tutorial, although simple ``homework'' assignments will be made available to
extend the example programs we present.

\section{Objectives and Benefits}

\begin{enumerate}
\item
  Introduce the Bloom programming language and show how realistic programs can
  be built using a combination of declarative rules, local storage, and message
  passing.
\item
  Discuss the CALM theorem, which sheds light on \emph{why} certain programs
  require distributed consensus and why others do not.
\item
  Discuss the particular challenges and benefits associated with programming
  using systems that provide only eventual
  consistency~\cite{DeCandia2007,Terry1995,vogels}, rather than the stronger
  guarantees provided by traditional distributed database systems. We will
  discuss the connection between eventual consistency and \emph{join
    semilattices}~\cite{Conway2012}, show how programs can be written by
  composing lattices using monotonic functions, and discuss the connection
  between Bloom and recent work on convergent modules (CRDTs) from the systems
  community~\cite{Shapiro2011a,Shapiro2011b}.
\item
  Highlight open problems and potential research challenges in the area of
  principled eventual consistency.
\end{enumerate}

\section{Outline}

\begin{itemize}
\item
  Introduction to Bloom
  \begin{itemize}
  \item
    Installation and configuration
  \item
    Syntax and semantics
  \item
    Simple example program: chat server
  \end{itemize}
\item
  CALM
  \begin{itemize}
  \item
    Lattices, monotone functions, and confluence
  \item
    CALM analysis tools, presented with examples
  \end{itemize}
\item
  Key-value store
  \begin{itemize}
  \item
    Version 1: non-monotonic updates
  \item
    Version 2: monotonic updates using a \texttt{map} lattice
  \item
    Version 3: monotonic updates using lattices to implement version vectors
    (per Dynamo~\cite{DeCandia2007}).
  \item
    Version 4: distributed locking, multi-key atomic updates
  \end{itemize}
\item
  Dealing with non-monotonicity
  \begin{itemize}
  \item
    Strong coordination: two-phase commit or Paxos in Bloom
    \begin{itemize}
    \item
      Automatic coordination synthesis
    \end{itemize}
  \item
    Weak coordination: lattice-theoretic approach to distributed garbage
    collection
  \item
    Apologies and compensation logic~\cite{Helland2009}
  \end{itemize}
\end{itemize}

\bibliographystyle{abbrv}
\bibliography{proposal}

\end{document}
