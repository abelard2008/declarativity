\documentclass{sig-alternate}
\usepackage{color}
\usepackage{graphicx}
\usepackage{url}
\usepackage{xspace}
\usepackage[T1]{fontenc}
\usepackage{times}
%\usepackage{mathptmx}    % use "times" font, including for math mode
\usepackage{txfonts}  % apparently needed to fixup the formatting of lstlistings
\usepackage{textcomp}
\usepackage[protrusion=true,expansion=true]{microtype}
\usepackage{paralist}
\usepackage{comment}
\usepackage[hidelinks]{hyperref}

\frenchspacing

\begin{document}

\title{Distributed Programming with Bloom}

\numberofauthors{3}
\author{
\alignauthor
Peter Alvaro\\
        \affaddr{UC Berkeley}\\
        \email{palvaro@cs.berkeley.edu}
\alignauthor
Neil Conway\\
        \affaddr{UC Berkeley}\\
        \email{nrc@cs.berkeley.edu}
\alignauthor
Joseph M.\ Hellerstein\\
        \affaddr{UC Berkeley}\\
        \email{hellerstein@cs.berkeley.edu}
}

\maketitle

\section{Introduction}

In recent years, distributed programming has become a topic of widespread
interest among developers. However, writing reliable distributed programs
remains stubbornly difficult. In addition to the inherent challenges of
distribution--- asynchrony, concurrency, and partial failure---many modern
distributed systems operate at massive scale. Scalability concerns have in turn
encouraged many developers to eschew strongly consistent distributed
storage~\cite{Birman2009,Helland2009}, which has raised the level of difficulty
still further.

In this tutorial, we will introduce \emph{Bloom}, a language for distributed
programming that we have developed at UC Berkeley~\cite{bloom-website}. We will
show how Bloom can be used to develop declarative, readable declarative
programs. Our focus will be on using Bloom to develop well-known distributed
systems infrastructure components, including a key-value store, quorum
replication, a distributed lock manager, and a distributed commit protocol. In
addition to introducing Bloom and showing how distributed logic can be used to
implement realistic designs, our emphasis will be on how the unique features of
Bloom help programmers understand the \emph{semantics} of their distributed
programs. In particular, we will discuss the \emph{CALM Theorem}, which
establishes a connection between \emph{logical monotonicity} and
\emph{distributed
  consistency}~\cite{Alvaro2011,Ameloot2011,Hellerstein2010,dedalus-confluence}. Using
tools distributed with the Bloom runtime, we will show how programmers can
reason about the monotonicity of their software components, compose individual
monotonic components into larger programs, and employ Bloom's systematic
distributed testing tool~\cite{Alvaro2012}.

\section{Objectives and Benefits}

\section{Outline}

\begin{itemize}
\item
  Introduction to Bloom
\item
  Key-value store
  \begin{itemize}
  \item
    Version 1: non-monotonic updates
  \item
    Version 2: monotonic updates using a \texttt{map} lattice
  \item
    Version 3: monotonic updates using lattices to implement version vectors
    (per Dynamo~\cite{DeCandia2007}).
  \end{itemize}
\end{itemize}

\bibliographystyle{abbrv}
\bibliography{proposal}

\end{document}
