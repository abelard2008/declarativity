\documentclass{sig-alternate}
\usepackage{color}
\usepackage{graphicx}
\usepackage{url}
\usepackage{xspace}
\usepackage[T1]{fontenc}
\usepackage{times}
%\usepackage{mathptmx}    % use "times" font, including for math mode
\usepackage{txfonts}  % apparently needed to fixup the formatting of lstlistings
\usepackage{textcomp}
\usepackage[protrusion=true,expansion=true]{microtype}
\usepackage{paralist}
\usepackage{comment}
%\usepackage[hidelinks]{hyperref}

\frenchspacing

\begin{document}

\title{Distributed Programming and Consistency:\\A Principled and Practical Approach}

\numberofauthors{3}
\author{
\alignauthor
Peter Alvaro\\
        \affaddr{UC Berkeley}\\
        \email{palvaro@cs.berkeley.edu}
\alignauthor
Neil Conway\\
        \affaddr{UC Berkeley}\\
        \email{nrc@cs.berkeley.edu}
\alignauthor
Joseph M.\ Hellerstein\\
        \affaddr{UC Berkeley}\\
        \email{hellerstein@cs.berkeley.edu}
}

\maketitle

\section{Introduction}

In recent years, distributed programming has become a topic of widespread
interest among developers. However, writing reliable distributed programs
remains stubbornly difficult. In addition to the inherent challenges of
distribution---asynchrony, concurrency, and partial failure---many modern
distributed systems operate at massive scale. Scalability concerns have in turn
encouraged many developers to eschew strongly consistent distributed storage in
favor of application-level consistency criteria~\cite{Birman2009,Helland2009},
which has raised the level of difficulty still further.

To cope with the challenges of distributed programming without the benefit of
strong consistency, practitioners have developed rules of thumb, such as using
commutative, associative, and idempotent operations when
possible~\cite{Helland2009,Pritchett2008} and employing application semantics to
resolve divergent replica states~\cite{DeCandia2007}. However, until recently
there was relatively little work on principled approaches to enable
application-level consistency criteria without requiring global coordination.

In this tutorial, we will review recent research on principled approaches to
eventually consistent
programming~\cite{Alvaro2011,Burckhardt2012,Conway2012,Hellerstein2010,Roh2011,Shapiro2011a,Shapiro2011b},
and connect this body of work to practical systems and design patterns used by
practioners. We will begin by discussing how \emph{semilattices} can be used to
reason about the convergence of replicated data values, following the ``CRDT''
framework recently proposed by Shapiro et
al.~\cite{Shapiro2011a,Shapiro2011b}. After presenting several examples of how
lattices can be used to achieve consistency without coordination, we will then
discuss how lattices can be composed using \emph{monotone functions} to form
more complex applications~\cite{Conway2012}. We will present our work on the
\emph{CALM Theorem}, which characterizes the kinds of programs that can be
guaranteed to be deterministic without distributed
coordination~\cite{Alvaro2011,Ameloot2011,Hellerstein2010,dedalus-confluence}. Finally,
we will discuss several design options for supporting non-monotonic operations:
(a) carefully introducing coordination at appropriate program locations (b)
employing ``weak coordination'' as a background operation (e.g., for distributed
garbage collection) (c) tolerating and then correcting inconsistency using
after-the-fact ``apology'' or compensation logic~\cite{Helland2009}. We will
conclude by summarizing the state of the art and highlighting open problems and
challenges in the field.

Throughout the tutorial, we will use \emph{Bloom}, a language for distributed
programming that we have developed at UC Berkeley~\cite{bloom-website}. We will
demonstrate the concepts introduced in this tutorial by using Bloom to develop
well-known distributed systems infrastructure components, including a key-value
store, quorum replication, a distributed lock manager with deadlock detection,
and a distributed commit protocol. Using tools distributed with the Bloom
runtime, we will show how programmers can visualize the distributed behavior of
their programs, reason about the monotonicity of software components, compose
individual monotonic components into larger programs, and employ Bloom's
built-in tools for systematic distributed testing~\cite{Alvaro2012}.

The tutorial will be \emph{interactive}, in that simple installation
instructions for the Bloom runtime will be provided and attendees will be given
the complete source code for all example programs. During the tutorial, we plan
to use the Bloom runtime to execute example programs, use the the built-in Bloom
analysis tools to understand program behavior, and iteratively refine programs
as appropriate. Attendees will have the option to run the tools themselves,
although participation int this manner will not be mandatory. Note that for time
reasons we do not expect attendees to develop Bloom programs from scratch during
the tutorial, although simple ``homework'' assignments will be made available to
extend the example programs we present.

\section{Objectives and Benefits}

\begin{enumerate}
\item
  Introduce the Bloom programming language and show how realistic programs can
  be built using a combination of declarative rules, local storage, and message
  passing.
\item
  Discuss the CALM theorem, which sheds light on \emph{why} certain programs
  require distributed consensus and why others do not.
\item
  Discuss the particular challenges and benefits associated with programming
  using systems that provide only eventual
  consistency~\cite{DeCandia2007,Terry1995,vogels}, rather than the stronger
  guarantees provided by traditional distributed database systems. We will
  discuss the connection between eventual consistency and \emph{join
    semilattices}~\cite{Conway2012}, show how programs can be written by
  composing lattices using monotonic functions, and discuss the connection
  between Bloom and recent work on convergent modules (CRDTs) from the systems
  community~\cite{Shapiro2011a,Shapiro2011b}.
\item
  Highlight open problems and potential research challenges in the area of
  principled eventual consistency.
\end{enumerate}

\section{Outline}

\begin{itemize}
\item
  Introduction to Bloom
  \begin{itemize}
  \item
    Installation and configuration
  \item
    Syntax and semantics
  \item
    Simple example program: chat server
  \end{itemize}
\item
  CALM
  \begin{itemize}
  \item
    Lattices, monotone functions, and confluence
  \item
    CALM analysis and visualization tools, presented with examples
  \end{itemize}
\item
  Key-value store
  \begin{itemize}
  \item
    Version 1: non-monotonic updates
  \item
    Version 2: monotonic updates using a \texttt{map} lattice, quorum
    replication
  \item
    Version 3: monotonic updates using lattices to implement version vectors
    (per Dynamo~\cite{DeCandia2007}).
  \item
    Version 4: distributed locking, multi-key atomic updates
  \end{itemize}
\item
  Dealing with non-monotonicity
  \begin{itemize}
  \item
    Strong coordination: two-phase commit or Paxos in Bloom
    \begin{itemize}
    \item
      Automatic coordination synthesis
    \end{itemize}
  \item
    Weak coordination: lattice-theoretic approach to distributed garbage
    collection
  \item
    Apologies and compensation logic~\cite{Helland2009}
  \end{itemize}
\item
  Distributed testing
  \begin{itemize}
  \item
    BloomUnit
  \item
    Applying CALM to enhance systematic testing
  \end{itemize}
\item
  Summary and conclusion
  \begin{itemize}
  \item
    Strengths and weaknesses of Bloom and CALM
  \item
    Open research problems
  \end{itemize}
\end{itemize}

\bibliographystyle{abbrv}
\bibliography{proposal}

\end{document}
