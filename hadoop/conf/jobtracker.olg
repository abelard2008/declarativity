program jobtracker;

import org.apache.hadoop.mapred.JobID;
import org.apache.hadoop.mapred.TaskID;
import org.apache.hadoop.mapred.JobClient;
import org.apache.hadoop.mapred.JobPriority;
import org.apache.hadoop.mapred.JobConf;

import org.apache.hadoop.mapred.declarative.Constants;
import org.apache.hadoop.mapred.declarative.util.JobState;
import org.apache.hadoop.mapred.declarative.util.TaskState;
import org.apache.hadoop.mapred.declarative.util.Function;
import org.apache.hadoop.mapred.declarative.util.FileInput;
import org.apache.hadoop.mapred.TaskTrackerAction;

import jol.types.basic.ValueList;
import java.lang.Integer;
import java.lang.Long;
import java.lang.Enum;

watch(job, a);
watch(task, a);
watch(taskAttempt, a);

/*************** JobTracker Duty Cycle (PERFORMANCE HACK) *********************/
timer(minDutyCyclePeriod, physical, 2000, infinity, 0);
define(dutyCycle, {String});
define(activeJobs, keys(), {Integer});
define(activeTasks, keys(), {Integer});
define(failedTasks, keys(0,1), {JobID, TaskID, Constants.TaskType, TaskState});
define(tasksWaitingForSchedule, keys(0), {Integer});

watch(failedTasks, a);
watch(tasksWaitingForSchedule, a);

tasksWaitingForSchedule(count<TaskId>) :-
    jobtracker::task(JobId, TaskId, _, _, _, _, TaskStatus),
    TaskStatus.state() == Constants.TaskState.UNASSIGNED ||
    TaskStatus.state() == Constants.TaskState.FAILED;

activeJobs(count<JobId>) :-
	job(JobId, _, _, _, _, _, _, _, FinishTime, _),
	FinishTime == 0L;
	
activeTasks(count<TaskId>) :-
	task(JobId, TaskId, Type, Partition, Input, MapCount, Status),
	Status.state() == Constants.TaskState.RUNNING;

failedTasks(JobId, TaskId, Type, Status) :-
	task(JobId, TaskId, Type, Partition, Input, MapCount, Status),
	Status.state() == Constants.TaskState.FAILED;
	
/* Set semantics ensure a single duty cycle per fixpoint. 
   I could have used a logical clock here but that spin the CPU during idle periods. */
dutyCycle("Duty Cycle") :- minDutyCyclePeriod(), activeJobs(Count), Count > 0;


/*************** Task Tracker Monitor *********************/

/*
timer(checkTracker, physical, 60000, infinity, 60000);

taskTracker(TrackerName, Host, HttpPort, Constants.TaskTrackerState.FAILED, 
            Timestamp, Failures, MapCount, ReduceCount, MaxMap, MaxReduce, true) :-
	checkTracker(Period, TTL, Delay),
	taskTracker(TrackerName, Host, HttpPort, TrackerState, Timestamp, Failures, 
	            MapCount, ReduceCount, MaxMap, MaxReduce, Dirty),
	TrackerState == Constants.TaskTrackerState.RUNNING,
	java.lang.System.currentTimeMillis() - Timestamp > Period;
	*/
	
/*************** Clean up *********************/


define(cleanup, {JobID});

cleanup(JobId) :-
	job(JobId, _, _, _, _, _, _, _, _, JStatus),
	JStatus.state() == Constants.JobState.SUCCEEDED || 
	JStatus.state() == Constants.JobState.FAILED;
	
delete
task(JobId, TaskId, Type, Partition, Input, MapCount, Status) :-
	cleanup(JobId),
	task(JobId, TaskId, Type, Partition, Input, MapCount, Status);

delete
taskAttempt(JobID, TaskID, AttemptID, Progress, TaskState, Phase, Diag, TrackerName, FileLoc, Start, Finish, Timestamp, Dirty) :-
	cleanup(JobId),
    taskAttempt(JobID, TaskID, AttemptID, Progress, TaskState, Phase, Diag, TrackerName, FileLoc, Start, Finish, Timestamp, Dirty);
    
delete
taskFileLocation(JobId, TaskId, Loc) :-
	cleanup(JobId), taskFileLocation(JobId, TaskId, Loc);


/*************** TASK INIT *********************/

define(initTask, {JobID, JobConf, String, TaskID, Constants.TaskType, Integer, FileInput, Integer, TaskState});
define(taskFile, {JobID, TaskID, ValueList});
define(taskFileLocation, keys(0,1), {JobID, TaskID, String});

/******* Admission control *******/
/*
initTask(JobID, JobConf, JobFile, null, null, null, null, null, null) :-
	job(JobID, JobName, JobFile, JobConf, User, URL, Priority, SubmitTime, FinishTime, JobStatus),
	JobStatus.state() == Constants.JobState.PREP,
	activeJobs(JobCount), activeTasks(TaskCount), JobCount <= 1 || TaskCount < 5000
	{
		JobStatus.state(Constants.JobState.RUNNING); // Update state to running
	};

initTask(JobID, JobConf, JobFile, null, null, null, null, null, null) :-
	job(JobID, JobName, JobFile, JobConf, User, URL, Priority, SubmitTime, FinishTime, JobStatus),
	JobStatus.state() == Constants.JobState.PREP,
	notin activeTasks(TaskCount)
	{
		JobStatus.state(Constants.JobState.RUNNING); // Update state to running
	};
	
*/

initTask(JobID, JobConf, JobFile, null, null, null, null, null, null) :-
	job(JobID, JobName, JobFile, JobConf, User, URL, Priority, SubmitTime, FinishTime, JobStatus),
	JobStatus.state() == Constants.JobState.PREP
	{
		JobStatus.state(Constants.JobState.RUNNING); // Update state to running
	};
	
/******************************************************/
	
/********************************/
	
/* Break out of the current fixpoint thread (using 'async') since taskCreate table function
   makes blocking calls to the DFS. */
async initTask
task(JobID, TaskID, Type, Partition, Input, MapCount, Status) :-
	taskCreate(initTask(JobID, JobConf, JobFile, TaskID, Type, Partition, Input, MapCount, Status));
	
taskFile(JobId, TaskId, Locations) :-
	task(JobId, TaskId, Type, _, Input, _, Status),
	Status.state() == Constants.TaskState.UNASSIGNED,
	Type == Constants.TaskType.MAP
	{ Split := Input.split(); Locations := Function.getLocations(Split); };
	
	
taskFileLocation(JobId, TaskId, Location) :-
	flatten(taskFile(JobId, TaskId, Locations)),
	Location := (String) Locations;
	
	
/*************** Job Status Maintenance *********************/
import java.util.Set;
	
/* Update the job state. */
public updateJobState
job(JobId, JobName, JobFile, JobConf, User, URL, Priority, SubmitTime, FinishTime, JobStatus) :-
	taskUpdate(JobId, TaskId, Type, TaskStatus),
	job(JobId, JobName, JobFile, JobConf, User, URL, Priority, SubmitTime, _, JobStatus),
	JobStatus.task(Type, TaskStatus)
	{
	FinishTime := JobStatus.state() == Constants.JobState.SUCCEEDED ? 
	              java.lang.System.currentTimeMillis() : 0L;
	};
	
define(killjob, {JobID});
killJob
job(JobId, JobName, JobFile, JobConf, User, URL, Priority, SubmitTime, FinishTime, JobStatus) :-
	killjob(JobId),
	job(JobId, JobName, JobFile, JobConf, User, URL, Priority, SubmitTime, _, JobStatus),
	JobStatus.killjob()
	{
	FinishTime := JobStatus.state() == Constants.JobState.SUCCEEDED ? 
	              java.lang.System.currentTimeMillis() : 0L;
	};
	

define(killJobOnTracker, {JobID, String});
public
killJobOnTracker(JobId, TrackerName) :-
	job(JobId, _, _, _, _, _, _, _, _, JobStatus),
	taskAttempt(JobId, TaskID, _, _, TaskState, _, _, TrackerName, _, _, _, _,_),
	JobStatus.state()  == Constants.JobState.FAILED,
	TaskState == Constants.TaskState.RUNNING;
	
taskTrackerAction(TrackerName, TaskTrackerAction.ActionType.KILL_JOB, Action) :-	
	killJobOnTracker(JobId, TrackerName),
	Action := Function.killJob(JobId);

taskTrackerAction(TrackerName, TaskTrackerAction.ActionType.KILL_TASK, Action) :-	
    job(JobId, _, _, _, _, _, _, _, _, JobStatus),
    JobStatus.state() == Constants.JobState.SUCCEEDED,
	taskAttempt(JobId, TaskId, AttemptId, _, State, _, _, TrackerName, _, _, _, _, _),
    State == Constants.TaskState.RUNNING
    {
        Action := Function.killTask(TaskId, AttemptId);
    };
	
    
/*************** Task Status Maintenance *********************/

define(taskUpdate, {JobID, TaskID, Constants.TaskType, TaskState});

public
task(JobId, TaskId, Type, Partition, Input, MapCount, Status) :-
    taskUpdate(JobId, TaskId, _, Status),
	task(JobId, TaskId, Type, Partition, Input, MapCount, _);
	
delete
task(JobId, TaskId, Type, Partition, Input, MapCount, Status) :-
    dutyCycle(), job(JobId, _, _, _, _, _, _, _, _, JobStatus), JobStatus.status().mapProgress() == 1f,
	task(JobId, TaskId, Type, Partition, Input, MapCount, Status),
    Type == Constants.TaskType.MAP;

/******* UPDATE TASK ATTEMPT STATE ******/
delete
taskAttempt(JobId, TaskId, AttemptID, Progress, State, Phase, Diag, Tracker, TaskFileLoc, Start, Finish, Timestamp, Dirty) :-
    taskUpdate(JobId, TaskId, _, Status), Status.state() == Constants.TaskState.SUCCEEDED,
	taskAttempt(JobId, TaskId, AttemptID, Progress, State, Phase, Diag, Tracker, TaskFileLoc, Start, Finish, Timestamp, Dirty);

taskAttempt(JobId, TaskId, AttemptID, Progress, Constants.TaskState.FAILED, Phase, Diag, TrackerName, FileLoc, Start, Finish, Timestamp, true) :-
	taskTracker(TrackerName, _, _, TrackerState, _, _, _, _, _, _,_),
	taskAttempt(JobId, TaskId, AttemptID, Progress, TaskState, Phase, Diag, TrackerName, FileLoc, Start, Finish, Timestamp,_),
	TrackerState != Constants.TaskTrackerState.RUNNING,
	TaskState == Constants.TaskState.RUNNING;
	
	
/************** GENERATE TASK UPDATES BASED ON TASK ATTEMPT STATE ********/
define(lookupDirtyTaskAttempt, {Boolean});
lookupDirtyTaskAttempt(true) :- dutyCycle();

taskAttempt(JobId, TaskId, AttemptID, Progress, State, Phase, Diag, Tracker, TaskFileLoc, Start, Finish, Timestamp, false) :-
	lookupDirtyTaskAttempt(Dirty),
	taskAttempt(JobId, TaskId, AttemptID, Progress, State, Phase, Diag, Tracker, TaskFileLoc, Start, Finish, Timestamp, Dirty);

define(taskAttemptUpdate, {JobID, TaskID, Integer, Constants.TaskState, Constants.TaskPhase, Long, Long, Float});
taskAttemptUpdate(JobId, TaskId, AttemptID, State, Phase, Start, Finish, Progress) :-
	taskAttempt(JobId, TaskId, AttemptID, Progress, State, Phase, Diag, Tracker, TaskFileLoc, Start, Finish, Timestamp, Dirty);

taskUpdate(JobId, TaskId, Type, StatusUpdate) :-
	taskAttemptUpdate(JobId, TaskId, AttemptID, State, Phase, Start, Finish, Progress),
	task(JobID, TaskId, Type, _, _, _, TaskStatus),
	TaskStatus.state() != Constants.TaskState.SUCCEEDED 
	{
		StatusUpdate := TaskStatus.attempt(AttemptID, Progress, State, Phase, Start, Finish);
	};
