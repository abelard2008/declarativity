program scheduler;

import java.lang.String;
import java.lang.Integer;
import java.lang.Float;
import java.lang.System;
import jol.types.basic.ValueList;
import org.apache.hadoop.mapred.declarative.Constants;
import org.apache.hadoop.mapred.TaskTrackerAction;
import org.apache.hadoop.mapred.declarative.util.Function;
import org.apache.hadoop.mapred.declarative.util.JobState;
import org.apache.hadoop.mapred.JobPriority;
import org.apache.hadoop.mapred.JobID;
import org.apache.hadoop.mapred.TaskID;


/*************** Task Attempt Scheduler *********************/

define(trackerCount, keys(0),   {Integer});
define(taskAttempts, keys(0,1), {JobID, TaskID, Integer});
define(schedule,        {JobID, TaskID, String});

public
trackerCount(count<TrackerName>) :-
	jobtracker::taskTracker(TrackerName, _, _, TrackerState, Timestamp, _,  _, _, _, _),
	TrackerState == Constants.TaskTrackerState.RUNNING;
	
public
taskAttempts(JobId, TaskId, count<AttemptId>) :-
	jobtracker::taskAttempt(JobId, TaskId, AttemptId);
	
failedJob
jobtracker::killjob(JobId) :-
	taskAttempts#insert(JobId, TaskId, Attempts), trackerCount(Trackers),
	jobtracker::task(JobId, TaskId, _, _, _, _, TaskStatus),
	TaskStatus.state() == Constants.TaskState.FAILED,
	Attempts > 3 || Attempts > Trackers;
	
jobtracker::taskUpdate(JobId, TaskId, Type, TaskStatus) :-
	jobtracker::taskAttempt#insert(JobId, TaskId, AttemptID, Progress, State, Phase, _, _, _, Start, Finish, Timestamp),
	State == Constants.TaskState.RUNNING,
	jobtracker::task(JobID, TaskId, Type, _, _, _, TaskStatus),
	TaskStatus.attempt(AttemptID, Progress, State, Phase, Start, Finish);

watch(jobtracker::taskAttempt, a);
public
jobtracker::taskAttempt(JobId, TaskId, AttemptID, 0, State, Phase, null, TrackerName, null, 0L, 0L, System.currentTimeMillis()) :-
	schedule(JobId, TaskId, TrackerName),
	notin taskAttempts(JobId, TaskId, _),
	State       := Constants.TaskState.RUNNING,
	Phase       := Constants.TaskPhase.STARTING,
	AttemptID   := 0;

public
jobtracker::taskAttempt(JobId, TaskId, AttemptID, 0, State, Phase, null, TrackerName, null, 0L, 0L, System.currentTimeMillis()) :-
	schedule(JobId, TaskId, TrackerName),
	taskAttempts(JobId, TaskId, Attempts),
	State       := Constants.TaskState.RUNNING,
	Phase       := Constants.TaskPhase.STARTING,
	AttemptID   := Attempts;
	
actionSchedule
jobtracker::taskTrackerAction(TrackerName, TaskTrackerAction.ActionType.LAUNCH_TASK, Action) :-	
	jobtracker::taskAttempt#insert(JobId, TaskId, AttemptID, _, _, Constants.TaskPhase.STARTING, _, TrackerName, _, _, _, _),
	jobtracker::job(JobId, JobName, JobFile),
	jobtracker::task(JobId, TaskId, Type, Partition, FileInput, MapCount, _),
	Action := Type == Constants.TaskType.MAP ? 
	          Function.launchMap(FileInput.split(), JobFile, TaskId, AttemptID, Partition) :
	          Function.launchReduce(JobFile, TaskId, AttemptID, Partition, MapCount);
	          
/*
watch(jobtracker::taskAttempt, a);
failedAction
jobtracker::taskAttempt(JobId, TaskId, AttemptID, 0, Constants.TaskState.FAILED, Constants.TaskPhase.STARTING, Diag, TrackerName, null, 0L, 0L, ActionTimestamp) :-
    trackerSlots(TrackerName, Host, TrackerTimestamp, Maps, Reduces),
	jobtracker::taskAttempt(JobId, TaskId, AttemptID, _, _, Constants.TaskPhase.STARTING, _, TrackerName, _, _, _, ActionTimestamp),
	jobtracker::task(JobId, TaskId, _, _, _, _, TaskStatus),
	TaskStatus.state() == Constants.TaskState.UNASSIGNED,
	TrackerTimestamp - ActionTimestamp > 60000L,
	Diag := "It's been 60 seconds and the tracker still hasn't started my task.";
*/
 
/******************** Process Jobs *******************/
define(jobQueue,            keys(0), {JobID, JobPriority, Long, Constants.TaskType});
define(jobFinishedMapTasks, keys(0), {JobID, Integer});

/* Put new jobs in a wait queue in a MAP phase. */
public
jobQueue(JobId, Priority, SubmitTime, Constants.TaskType.MAP) :-
	jobtracker::job(JobId, _, _, _, _, _, Priority, SubmitTime, _, JobStatus),
	JobStatus.mapCount() > 0, JobStatus.state() == Constants.JobState.PREP;
	
public
jobQueue(JobId, Priority, SubmitTime, Constants.TaskType.REDUCE) :-
	jobtracker::job(JobId, _, _, _, _, _, Priority, SubmitTime, _, JobStatus),
	JobStatus.mapCount() == 0, JobStatus.state() == Constants.JobState.PREP;
	
public delete
jobQueue(JobId, Priority, SubmitTime, Phase) :-
	jobtracker::job(JobId, _, _, _, _, _, Priority, SubmitTime, _, Status),
	jobQueue(JobId, Priority, SubmitTime, Phase),
	Status.state() == Constants.JobState.SUCCEEDED || Status.state() == Constants.JobState.FAILED;
	
/* Switch to reduce phase when all maps finish. */
jobQueue(JobId, Priority, SubmitTime, Constants.TaskType.REDUCE) :-
	jobFinishedMapTasks#insert(JobId, FinishedMapCount), 
	jobtracker::job(JobId, _, _, _, _, _, _, _, _, JobStatus),
	jobQueue(JobId, Priority, SubmitTime, Constants.TaskType.MAP),
	FinishedMapCount == JobStatus.mapCount();

public
jobFinishedMapTasks(JobId, count<TaskId>) :-
	jobtracker::taskUpdate(JobId, TaskId, Type, Status),
	Type == Constants.TaskType.MAP, Status.state() == Constants.TaskState.SUCCEEDED;
	

/******************** Signal task tracker slots available *******************/

define(trackerSlots, keys(0), {String, String, Long, Integer, Integer});

public
trackerSlots(TrackerName, Host, Timestamp, MaxMap - MapCount, MaxReduce - ReduceCount) :-
	jobtracker::dutyCycle(), jobtracker::taskTracker(TrackerName, Host, _, _, Timestamp, _,  MapCount, ReduceCount, MaxMap, MaxReduce);
	
	
	