\section{Case Study: Quicksort}
\label{sec:qscs}

Consider the structure of the traditional Quicksort algorithm: a single element called the “pivot” is selected from a list, and the list is divided into two sublists -- one containing the elements in the original list less than the pivot and the other containing the elements in the original sublist greater than the pivot.  The division is performed in-place in memory.  Quicksort is then recursively applied to each list.

In our first step of the case study, we introduce disorder to enable asynchronous parallelism.  It is naturally observed that quicksort, like most divide and conquer algorithms, can perform splits in parallel.

Divide and conquer algorithms are usually easily parallelizable as written, as there is no logical dependence between independent divisions.  For example, the basic translation of the functional/imperative version of quicksort:

\wrm{show code}

Is translated as:

\wrm{show code}

In the next step of our case study, we introduce disorder in order to enable random selection of pivots.  To maintain determinism, it must be the case that the order of selecting pivots is immaterial.  In particular, it is the case that permuting two pivot selections does not have an effect.  Why is this the case?  In quicksort, a pivot operation establishes the information that any element $e$ that is greater than the pivot has a predecessor of at least the pivot.  No predecessor information is established for elements less than the pivot.  Thus, if two pivots are considered, the information established for those elements greater than both pivots is that the predecessor is at least the max of the two pivots.  Of course, max is order-independent.  Thus, the order of pivot consideration doesn’t matter.

Of course, considering the pivots in “the wrong” order could establish a substantial amount of redundant information.

In order to enable random pivot selection in quicksort while preserving determinism, we must rewrite quicksort to introduce disorder into the pivot selection.

\wrm{show code with disorderly pivot selection}

\wrm{show imperative code that generates the timeline based on random pivots}

\section{Case Study: Hamiltonian Path}

This is a well-known NP complete problem.  One known search strategy for this problem is a ``backtracking'' approach, where paths are extended until we either find a hamiltonian path or a dead-end.  Once we reach a dead-end, we backtrack to our last choice, and choose another link.

\wrm{Whereas in quicksort, we could get away with specifying an ordering on a single relation, in the Hamlitonian path case, we need to specify an order on the link relation PER JOINED PATH.  In other words, we need to exercise advanced control over the ordering of the join.}
