\section{Case Study: Quicksort}
\label{sec:qscs}

\wrm{todo put this syntax in the new syntax}

Consider the problem of sorting, here defined as the problem of assigning an ordering to a set of distinct elements.

Consider the structure of the traditional Quicksort algorithm: a single element called the {\em pivot} is selected from a list, and the list is divided into two sublists -- one containing the elements in the original list less than the pivot and the other containing the elements in the original sublist greater than the pivot.  The division is performed in-place in memory.  Quicksort is then recursively applied to each list.  Being a divide-and-conquer algorithm, Quicksort is naturally parallelizable.  Furthermore, quicksort's performance is contingent on the order in which pivots are selected.  Typically, one selects pivots at random, or utilizing a randomized approximation of the median.

In traditional programming languages, there are no confluence guarantees for a version of quicksort that does either or both of parallelism and randomized pivot selection.  Our goal is to write such a version of quicksort that is provably confluent.

In our first step of the case study, we consider asynchronous parallelism.  It is naturally observed that quicksort, like most divide and conquer algorithms, can perform each pivoting operatoin in parallel.  Divide and conquer algorithms are usually easily parallelizable as written, as there is no logical dependence between independent divisions.

Consider the following code:

\begin{alltt}
sublist(p,'LEFT',l), sublist(p,'RIGHT',r) <- sublist(x,y,l), sublist(x,y,r), f_select_pivot(x,y,p), l < p, r > p.
link(max<l>,p), link(p,min<r>) <- sublist(p,'LEFT',l), sublist(p,'RIGHT',r).
\end{alltt}

The first rule performs splits into sublists---a ``RIGHT'' sublist that contains the elements greater than the pivot, and a ``LEFT'' sublist that contains the elements less than the pivot.  The pivot selection is based on the results of some function {\tt f\_split\_pivot}.  The second rule expresses that in the final sorted list, represented by {\tt link}, the pivot $p$'s immediate predecessor is the maximum element of the sublist of smaller elements, and $p$'s immediate successor is the minimum element of the sublist of greater elements.

There is nothing that prohibits parallel pivot splitting -- the only prerequisite for splitting a sublist is that it exists.  In fact, one would have to write a far more complex program to prohibit pivot splitting from being done in parallel.  This is an example of where the language's default of disorderly behavior can help programmers add disorder to their programs.

In the next step of our case study, we introduce disorder in order to enable random selection of pivots.  In order to achieve determinism, it must be the case that the order of selecting pivots is immaterial.

In particular, it is the case that permuting two pivot selections does not have an effect.  Let's think about why this is the case for quicksort. In quicksort, a pivot operation establishes the information that any element $e$ that is greater than the pivot has a predecessor of at least the pivot.  Conversely, a pivot operation establishes the information that any element $e$ that is less than the pivot has a successor of at most the pivot.  No predecessor information is established for elements less than the pivot.  Thus, if two pivots are considered, the information established for those elements greater than both pivots is that the predecessor is at least the max of the two pivots.  Of course, this process of taking the maximum is order-independent.  Thus, the order of pivot consideration doesn't matter.

In order to enable random pivot selection in quicksort while preserving determinism, we must rewrite quicksort to introduce disorder into the pivot selection.

\begin{alltt}
link(x,p) <- pivot(p), list(x), link(x,z), link(p,z), x > p;
link(x,0) <- list(x);
\end{alltt}

In this case, {\tt link} is a set lattice over pairs whose operation is dependent on the value of its first argument.  If the two sets both contain a pair with the same first argument, the resultant set contains a single pair with this first argument, whose second argument is the maximum of the two second arguments.  If only one set contains a pair with a given first argument, the resultant set contains this pair.  In Haskell notation, the operation, {\tt lub}, can be written as:
\begin{alltt}
lub = unionWith max
\end{alltt}

The {\tt link} identifier represents the predecessor relation.  If $(x,y)$ is in {\tt link}, then element $x$'s predecessor is element $y$.

The first rule in the above code takes a set of pivots $p$ with predecessor $z$, and a set of list elements $x$ with the same predecessor $z$.  The maximum of the pivots $p$ is chosen as the predecessor for $x$, assuming $x > p$.

To understand the correspondence to quicksort, imagine that for each execution of the rule, there is only a single pivot $p$, and further imagine thhat {\tt link(x,z)} contains all $x$ with predecessor $z$.  Then, execution of the rule corresponds to considering all elements that should be in the right sublist of $p$, and putting them in the right sublist by updating each of their predecessors to $p$.  

Subsequent executions of the rule can only increase an element's predecessor, as it moves into further-right sublists.

Of course, considering the pivots in “the wrong” order could establish a substantial amount of redundant information, reducing performance of the algorithm.  What if we considered the pivots in sort order?  We would establish the information that $n-1$ elements are greater than the first pivot, $n-2$ elements are greater than both the first and second pivot, $n-3$ elements are greater than the first three pivots, etc.  Overall, we would establish $O(n^2)$ information.  However, assume we consider the pivots in an order corresponding to the optimum for quicksort.  The first selection is the median, so we establish $n/2$ elements are greater than the first pivot.  The second and third are the median of both of the sublists, so we establish that $n/2$ elements are greater than either the second or third.  The fourth, fifth, sixth, and seventh are the medias of the 4 resulting sublists, and again we stablish a total of $n/2$ elements are greater than either of these.  Overall, we establish $O(n log(n))$ information in this case.

The different performance for each of these orders motivates us to induce a specific order to tune the performance of our quicksort specification.  Recall that we induce a specific order by writing an ``ordering'' program that generates a timeline.  The code below selects pivots in random order.  From the algorithmic analysis of randomized quicksort, we know that in expectation, $O(n log(n))$ information is established.

\begin{alltt}
function main:
   for each (x) in list:
      add ``r2 : [(x)]'' to the timeline

   for each (p) in pivot in random order:
      for each (x) in list:
         if (z = (sorted_list[p] == sorted_list[x])) and x > p:
            add ``r1 : [(p),(x),(x,z),(p,z)]'' to the timeline
\end{alltt}


\section{Case Study: Hamiltonian Path}

This is a well-known NP complete problem.  One known search strategy for this problem is a ``backtracking'' approach, where paths are extended until we either find a hamiltonian path or a dead-end.  Once we reach a dead-end, we backtrack to our last choice, and choose another link.

\wrm{Whereas in quicksort, we could get away with specifying an ordering on a single relation, in the Hamlitonian path case, we need to specify an order on the link relation PER JOINED PATH.  In other words, we need to exercise advanced control over the ordering of the join.}

\wrm{single source longest path}

\begin{alltt}
path(x,y,\{x,y\}) <- link(x,y);
path(x,y,s \(\cup \{x\}\)) <- link(x,z), path(z,y,s), x \(\not\in\) s;
\end{alltt}

\wrm{ordering code}

\begin{alltt}
for each (x,y) in link in random order:
   add ``r1: [(x,y)]'' to timeline
   next_link(x,y,{x,y})

function next_link(z,y,s)
   for each (x,z) in link such that x \(\not\in\) s, in random order:
      add ``r2: [(x,z), (z,y,s)]'' to timeline
      next_link(x,z,s\(\cup\{x\}\))
\end{alltt}
