\section{\large \bf \lang}
\label{sec:foundation}

\subsection{Preliminary Definitions}

\todo{Thread a running example through the paper}
\todo{define head and body of rule}
\todo{say something about the partitioning or accessibility of the order}
\todo{make sure it's clear that $\univ$ includes \dedalus{node} but not \dedalus{time}}
\todo{make sure usage of ``relation'' vs ``relation schema'' is consistent}

We assume an infinite universe $\univ$.

A {\em relation schema} is a pair consisting of a relation name and its arity.
A {\em schema} $\schema$ is a set of relation schemas.  \nrc{Confusing:
  relation schema is a singleton, but ``schema'' is a set of relation schemas?} As in \wrm{cite Immerman}, we assume the existence of an order.  Thus, all schemas contain the following relational schemas: \dedalus{lt} -- a relation of arity two that is true whenever the second argument is greater than the first (we will write this relation in infix form using the \dedalus{<} symbol) -- \dedalus{suc} -- a relation of arity two that defines a total order over $\univ$ \wrm{different from succ}.

A {\em rule} over a schema $\schema$ is a clause of the form:

\begin{Dedalus}
p(\od{X\sub{0}}) <- b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}),
!c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}}).
\end{Dedalus}

where \dedalus{p}, \dedalus{b\sub{1}}, \ldots, \dedalus{b\sub{n}},
\dedalus{c\sub{1}}, \ldots, \dedalus{c\sub{m}} are relations in
$\schema$, and \od{X\sub{i}} and \od{Y\sub{j}}
denote a tuple (of the appropriate arity) consisting of variable symbols or
constants from $\univ$.  Note that we maintain the usual safety
restrictions of Datalog rules: any variable symbol \dedalus{V} that appears in
\od{Y\sub{i}} for some $1 \leq i \leq m$ must also appear in
\od{X\sub{j}} for some $1 \leq j \leq n$, but only if \dedalus{V}
appears in \od{X\sub{0}} or \dedalus{V} appears in
\od{Y\sub{k}} for some $k \neq i$ -- i.e., variable symbols that
only appear in a single negated atom and do not appear in the head need not also
appear in a positive atom \wrm{cite ullman}.

\wrm{describe recursion, rule out recursion through negation, define EDB}

A {\em fact} over a relation schema of arity $n$ is a pair consisting of the
relation name and an $n$-tuple $(c_1,\ldots,c_n)$, where each $c_i \in
\univ$.  An \emph{instance} $\mathcal{I}$ over a schema $\schema$ is a
set of facts. \todo{check the rest of the paper to make sure we're using ``instance'' as appropriate}

\todo{Following the terminology of...}  Given a schema $\schema$, we use
$\sschema$ to denote the extension of $\schema$ obtained by adding a
column to each relation schema in $\schema$ and adding an additional
relation schema to $\schema$.  The additional column is the {\em location
  specifier}, which gives the ``location'' of the tuple.  By convention, this is
represented as the first column.  The additional relation schema is \dedalus{node}, a
unary relation that represents all ``locations.''  We call $\sschema$ a
{\em spatial} schema.

\todo{``a'' vs ``the'' spatial schema}

Given a spatial schema $\sschema$, we use $\stschema$ to denote the
extension of $\sschema$ obtained by adding a column to each relation schema
in $\sschema$ and adding two additional relation schemas.  The additional
column is the {\em timestamp}, a natural number representing a logical time.  By
convention, the location specifier is the first column and the timestamp is the
second.  The additional relation schemas we add are: \dedalus{time}, a unary
relation equivalent to $\mathbb{N}$, and \dedalus{succ}, a binary relation
representing the natural successor relation over $\mathbb{N}$.  We call
$\stschema$ a {\em spatio-temporal} schema.

Given a spatio-temporal schema $\stschema$, there is a unique corresponding spatial schema that corresponds with dropping the additional relations, and the additional column from each relation schema.

A {\em spatial fact} over a relation schema of arity $n$ is a pair consisting of the relation name and an $n+1$ tuple $(l,c_1,\ldots,c_n)$ where each $c_i \in \univ$, $l \in \dedalus{node}$.

A {\em spatio-temporal fact} over a relation schema of arity $n$ is a pair consisting of the relation name and an $n+2$ tuple $(l,t,c_1,\ldots,c_n)$ where each $c_i \in \univ$, $l \in \dedalus{node}$, and $t \in \mathbb{N}$.

A {\em spatio-temporal rule} over a spatio-temporal schema $\stschema$ is a rule of one of the following three forms:

\todo{ensure sugaring diction reflects that we have a node(L) and time(T) in the body of all rules!}
\todo{ensure that it's clear that asynchronous rules can also be local}

A {\em deductive} rule:

\begin{Dedalus}
p(L,T,\od{X\sub{0}}) <- b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}),
!c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T).
\end{Dedalus}

An {\em inductive} rule:

\begin{Dedalus}
p(L,S,\od{X\sub{0}}) <- b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}),
!c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T), succ(T,S).
\end{Dedalus}

%An {\em asynchronous local} rule:
%
%\begin{Dedalus}
%p(L,S,\od{X\sub{0}}) <- b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}),
%!c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T), time(S),
%T < S, choice((L, T, \od{B}),(S)).
%\end{Dedalus}

An {\em asynchronous} rule:

\begin{Dedalus}
p(D,S,\od{X\sub{0}}) <- b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}),
!c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T), time(S),
T < S, choice((L, T, \od{B}),(S)), node(D).
\end{Dedalus}

\wrm{The latter two kinds of rules are referred to as temporal rules.}

where all symbols are as defined before, \od{B} is a list of all of the distinct variable symbols in \od{X\sub{1}}, \ldots, \od{X\sub{n}}, \od{Y\sub{1}}, \ldots, \od{Y\sub{m}}; \dedalus{D} and \dedalus{L} are variable symbols that may also appear in \od{B}, \dedalus{T} and \dedalus{S} are variable symbols that may not appear in \od{B}, and \dedalus{choice} is the construct of Sacc\`{a} and Zaniolo~\cite{sacca-zaniolo}, which we will presently describe.

A \lang\ {\em program} is a set of spatio-temporal rules over some spatio-temporal schema $\stschema$.  

%%Note that a given set of rules over a schema may give rise to many different \lang programs, depending on which type of spatio-temporal rule each rule is converted into, and depending on where or if the variable \dedalus{D} appears in the body in asynchronous communication rules. \paa{this confused me.  you are saying that the mapping from a 'plain old datalog' program to a dedalus program isn't 1-1?  this is obvious, right?  if this isn't what is intended, how do "rules" "give rise to" "dedalus programs"?}

A \lang\ {\em instance} is a program with a set of spatio-temporal facts specified for EDB relations. \todo{explain how a fact is really a sugared atemporal rule with no body; implicit in the sugaring is the time(T) and node(N) relations in the body.}

\noindent
\textbf{Syntactic sugar for space-time in \lang:}
The restrictions on temporal and location attributes suggest a natural syntactic sugar to improve readability.  Given the unification requirements for location and temporal attributes in rule bodies, we can omit these attributes from predicates without risk of ambiguity.  

The three temporal classes of rules listed above can be distinguished by annotating inductive head predicates with \dedalus{@next}, and asynchronous head predicates with \dedalus{@async}; simple deductive rules have no head annotation. 
Communication rules must include the location attribute of their head predicate; by definition this is a different variable than that of the body predicates.
 Given these conventions, the presence of appropriate \dedalus{successor}, \dedalus{choice} and \dedalus{node} predicates in the body are implicit and can be omitted.  The result is a syntax that reads like a simple temporal variant of Datalog.

Deductive:

\begin{Dedalus}
p(\od{X\sub{0}}) <- b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}),
!c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}}).
\end{Dedalus}

Inductive:

\begin{Dedalus}
p(\od{X\sub{0}})@next <- b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}),   
!c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}}).
\end{Dedalus}

%Asynchronous local:
%
%\begin{Dedalus}
%p(\od{X\sub{0}})@async <- b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}),
%!c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}}).
%\end{Dedalus}

Asynchronous:

\begin{Dedalus}
p(#D,\od{X\sub{0}})@async <- b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}),
!c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}}).
\end{Dedalus}


%Spatial entanglement involves making the location specifiers in the body explicit.  A rule with spatial entanglement may be of any of the varieties above.  As an example, here is an asynchronous rule with spatial entanglement:
The syntactic sugar is optional, and as we shall see it is often useful to explicitly reference location specifiers in rules.  A rule of any of the
varieties above may be \emph{spatially entangled} in this way. For example, the rule below is a spatially entangled asynchronous rule if $L$ appears
in $\od{X\sub{0}}$ or $D$ appears in $\od{X\sub{i}}$ or $\od{Y\sub{j}}$ for $0 < i < n$ and $0 < j < m$.


\begin{Dedalus}
p(#D,\od{X\sub{0}})@async <- b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{X\sub{n}}),
!c\sub{1}(#L,\od{Y\sub{1}}), \ldots, !c\sub{m}(#L,\od{Y\sub{m}}).
\end{Dedalus}




\subsection{Semantics}
One interpretation of a \lang instance is given by the possible worlds of the
stable model semantics~\cite{stable-model}.  The stable model semantics is proposed for \dedalus{choice} by Sacca and Zaniolo \wrm{cite}.
We do not review the stable model
semantics here -- the only salient detail is the interaction of \dedalus{choice}
with the stable model semantics.  Since the stable model semantics coincides with the locally stratified semantics \wrm{cite}, a \lang program without \dedalus{choice} (i.e., without an asynchronous rule) has a unique stable model as it is locally stratified.  A \lang program with asynchronous rules has infinitely many stable models.  Each stable model is the locally stratified model obtained by treating the \dedalus{choice} construct as an EDB relation, and adding facts for all chosen timestamps.

\begin{example}
Take the following \lang instance:

\begin{Dedalus}
p(#L,X)@async <- q(#L,X).
node(n1).
q(#n1,0).
q(#n1,1).
\end{Dedalus}

Let $\mathcal{N}$ represent the set of all infinite subsets of $\mathbb{N}$.  The possible stable models are exactly the elements $(n_1, n_2) \in \mathcal{N} \times \mathcal{N}$, where the first coordinate represents the set of all timestamps for which \dedalus{p(n1,0)} is true, and second represents the set of all timestamps for which \dedalus{p(n1,1)} is true.  Consider the unsugared version of the program:

\begin{Dedalus}
p(L,S,X) <- q(L,T,X), node(L), time(T), time(S), T < S, choice((L,T,X),(S)).
node(L,T,n1) <- node(L), time(T).
q(n1,T,0) <- time(T).
q(n1,T,1) <- time(T).
\end{Dedalus}

To compute a particular stable model $(n_1,n_2)$, we can treat \dedalus{choice} as an EDB relation, and for each of $n_1$ and $n_2$, create functions $f_1, f_2 : \mathbb{N} \rightarrow \mathbb{N}$, such that the image of $f_1$ is $n_1$, and the image of $f_2$ is $n_2$.  Then, add the appropriate infinite set of \dedalus{choice} facts to the EDB to encode the functions.  The resulting instance has a unique stable model as it is locally stratified, which coincides with its locally stratified model.
\end{example}

\paa{not ready to whack it yet, but we should consider breaking the above discussion into two (more chewable) pieces: first, making no assumptions about q's persistence, show that a single async rule induces an infinite number of stable models, and how each model may be viewed as fixing a 'choice function' as EDB.  then, mention among the 'problems' below that rules with
all persistent subgoals make an infinite number of choices, inducing an uncountable number of stable models}

There are two potential problems with considering a stable model as the meaning of a \lang instance.  
%%First, every program with at least one asynchronous rule has infinitely many stable models.  
First, a program with even one asynchronous rule may have uncountably many stable models.  
Not all of these stable models may be meaningfully different.  Second, a stable model of a \lang program may itself be infinite.  We address both concerns in our definition of an {\em ultimate model}.

%\paa{looks like we still need to define this.  perhaps we should define it exactly as we did in the other paper -- the UM is exactly the set of facts with trivial periodicities; the set of things eventually always true.  dedalus-c restricts the definition: the 
%UM is the set of output tuples that is eventually always true, and since these are simply peristed this reduces to the set of tuples that are ever true.  
%the burden is now on the programmer and coordination protocol to ensure that nothing goes into the output predicates until it is surely true.}

\todo{the above example also has an infinite stable model, but we like flip flop as well because it shows a nontrivial periodicity; integrate this with the definition of ultimate model}
\begin{example}
\label{ex:flipflop}
A \lang program with an infinite stable model.

\begin{Dedalus}
flipflop(Y,X)@next \(\leftarrow\) flipflop(X,Y);
flipflop(1,2)@1;
\end{Dedalus}

\dedalus{flipflop(1,2)} is true at all odd times, and \dedalus{flipflop(2,1)} is true at all even times.  Thus, \dedalus{flipflop(1,2)} and \dedalus{flipflop(2,1)} are each cyclic with period 2.
\end{example}

An {\em output schema} for a \lang program $P$ with spatio-temporal schema $\stschema$ is a subset of $\sschema$.  We denote the output schema as $\oschema$.

An {\em ultimate model} of a \lang program $P$ with spatio-temporal schema $\stschema$ is the spatial facts in $\oschema$ that are ``eventually always'' true.  In other words spatial fact $f$ is in the ultimate model if the relation of $f$ is in $\oschema$ and $\forall t : f@t => f@t+1$. \todo{make sure this notation is introduced}
An ultimate model is always finite, due to the finiteness of $\univ$, and by the same reasoning any \lang program has only a finite number of ultimate models.

Note that some nontrivial programs may have an empty ultimate model, such as the program in Example~\ref{ex:flipflop}.  Further, a \lang program may have multiple ultimate models.  We give two such examples:

\begin{example}
\label{ex:diffluent1}
A diffluent \lang program.

\begin{Dedalus}
output p.
q()@async <- q_edb();
r()@async <- r_edb();
p() <- q(), !r();
q()@next <- q();
r()@next <- r();
\end{Dedalus}

Assume an EDB of \dedalus{q\_edb(), r\_edb()}.  Any stable model where \dedalus{q()} has a lower timestamp than \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.  \wrm{The problem here is negation}.
\end{example}

\begin{example}
\label{ex:diffluent2}
A diffluent \lang program.

\begin{Dedalus}
output p.
q()@async <- q_edb();
r()@async <- r_edb();
p() <- q(), r();
q()@next <- q();
\end{Dedalus}

As before, assume an EDB of \dedalus{q\_edb(), r\_edb()}.  Any stable model where the timestamp of \dedalus{q()} is less than or equal to the timestamp of \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.
\end{example}

\subsection{Operational Interpretation}
\label{sec:operational}

\todo{See if any transducers/Dedalus stuff has been published, and cite it here.}
