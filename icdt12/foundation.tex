\section{\large \bf \lang}
\label{sec:foundation}

To arrive at a formal semantics for distributed programs, we present the
\lang~\cite{dedalus} language, which formally captures the intuitive notion of
logic programs being executed asynchronously across the nodes of a distributed
system.  In designing \lang, we extended the well-understood Datalog language
with temporal constructs that allowed us to model time-varying state and channel
non-determinism.  As we shall see, both extensions are made possible by
admitting a representation of logical time into the program schema, allowing the
consequences of deductions to hold ``at a different time'' than their
antecedents.  By narrowly constraining such temporal deductions, we argue that
\lang captures salient features of systems that communicate over unreliable
networks and mutate state over time.

%\todo{Get rid of ``stable model semantics''}
We begin this section by reviewing the syntax of \lang that was first presented
in~\cite{dedalus}. We then provide a model-theoretic semantics for \lang.  We
note that the stable model semantics~\cite{stable-model} may be used to assign
meanings to \lang programs that capture the mutation of state over logical time,
much as a trace or ``execution''~\cite{ioa}
captures the behavior of a typical imperative distributed program over time.
However, using the stable model semantics for \lang presents certain obstacles:
even if a \lang program has a deterministic final state, channel non-determinism
may induce an infinite number of stable models, each corresponding to a
different evolution toward that state over logical time.  To project away the
(potentially infinite) variety of these distinctions, we present the {\em
  ultimate model} semantics, an abstraction that associates a program with a
finite model of its ``eventual'' execution state.  Even with this
simplification, some programs may have more than one ultimate model.  We
conclude by showing a natural correspondence between the multiple ultimate
models and sensitivities of the specification to the main non-determinism
inherent in distributed systems: message delays and reordering.

%\jmh{PS: Should we make an argument that the ultimate models cover all possible message orderings?  Or all ``interesting'' (non-commuting) permutations of messages?}
% I couldn't find a way to make this an aside, since there is no discussion of message orderings in this section.

\subsection{Syntax}

\subsubsection{Preliminary Definitions}

%\todo{Thread a running example through the paper}
%\todo{ensure ``relation'' vs ``relation name'' usage is consistent}
%\todo{define ``relation'', ``maps''?}
%\todo{Put in examples of notation close to where the notation is introduced -Dave Maier} % deferred to camera-ready

We assume a finite universe $\univ$ of values.

A {\em relation schema} $(\dedalus{r},n)$ is a pair consisting of a relation name $\dedalus{r}$ and its arity $n$.
A {\em database schema} $\schema$ is a finite set of relation schemas.
%\nrc{Confusing: relation schema is a singleton, but ``schema'' is a set of relation schemas?} 
%I'm changing ``schema'' to ``database schema''.  A google search for [``relational schema'' ``database schema''] reveals this to be at least somewhat standard.

A {\em fact} over a relation schema $(\dedalus{r}, n)$ is a pair consisting of
the relation name \dedalus{r} and an $n$-tuple $(c_1,\ldots,c_n)$, where each
$c_i \in \univ$.  We denote a fact with relation name \dedalus{r} by
\dedalus{r(c\sub{1}, \ldots, c\sub{n})}.  As in Immerman~\cite{immerman-ptime}, we assume
the existence of an order: every database schema contains the relation schema
$(\dedalus{<},2)$.\footnote{We will often write \dedalus{<} in infix notation.} 
A {\em relation instance} for relation schema $(\dedalus{r},n)$ is a finite set of facts for
$(\dedalus{r},n)$.  A {\em database instance} maps each relation schema $(\dedalus{r},n) \ne
(\dedalus{<},2)$ to a relation instance for $(\dedalus{r},n)$, and maps $(\dedalus{<},2)$ to a
finite set of \dedalus{<} facts that encode a total ordering over $\univ$.

A {\em rule} over a database schema $\schema$ is a clause of the form:

\begin{Drules}
  \drule{p(\od{W})}
        {b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{l}(\od{X\sub{l}}), !c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}})}
\end{Drules}

\noindent where \dedalus{p}, \dedalus{b\sub{1}}, \ldots, \dedalus{b\sub{l}},
\dedalus{c\sub{1}}, \ldots, \dedalus{c\sub{m}} are relations in $\schema$, and \od{W},
\od{X\sub{i}} and \od{Y\sub{j}} denote a tuple (of the appropriate arity)
consisting of constants from $\univ$ or variable symbols.  The {\em atom} to the
left of the $\leftarrow$ is called the {\em head} of the rule, and the
conjunction of atoms to the right is called the rule's {\em body}.
%\jmh{Following on to the question above about \dedalus{<}, shouldn't we use
%  obligatory boilerplate about Horn clauses and finite Herbrand universes?}
The relation name in the rule head may not be \dedalus{<}. Furthermore, if
\dedalus{b\sub{i}} (resp.\ \dedalus{c\sub{i}}) is \dedalus{<}, then any variable
that appears in \dedalus{\od{X\sub{i}}} (resp.\ \dedalus{\od{Y\sub{i}}}) must
also appear in \dedalus{\od{X\sub{j}}} for some $b_j \neq \dedalus{<}$. That is,
variable symbols that appear in a \dedalus{<} atom must also appear in a
non-negated atom that is not \dedalus{<}.

\subsubsection{Safety}
\lang maintains the usual Datalog safety restrictions: any variable symbol
\dedalus{V} that appears in \od{Y\sub{i}} for some $1 \leq i \leq m$ must also
appear in \od{X\sub{j}} for some $1 \leq j \leq n$, but only if \dedalus{V}
appears in \od{W} or \dedalus{V} appears in \od{Y\sub{k}} for some $k \neq
i$. That is, variable symbols that only appear in a single negated atom and do not
appear in the head need not also appear in a positive atom~\cite{ullmanbook}.
Also, any variable symbol that appears in \od{W} must appear in some
\dedalus{\od{X\sub{1}}, \ldots, \od{X\sub{l}}}.

\subsubsection{Spatial and Temporal Extensions}

Given a database schema $\schema$, we use $\sschema$ to denote the extension of $\schema$
obtained as follows. For each relation schema $(\dedalus{r}, n) \in (\schema-\{\dedalus{<}\}$), we include a relation schema $(\dedalus{r}, n+1)$ in $\sschema$. The
additional column being added to each relation schema is called a {\em location specifier}. By convention, the
location specifier is the first column of every relation in $\sschema$.
Additionally, $\sschema$ includes $\dedalus{<}$, and a relation schema $(\dedalus{node},1)$.
We call $\sschema$ a {\em spatial schema}.~\footnote{The terms {\em spatial} and
  {\em spatio-temporal} are borrowed from Ameloot~\cite{ameloot-personal}.}

A {\em spatial fact} over a relation schema of arity $n$ is a pair consisting of the relation name and an $(n+1)$-tuple $(d,c_1,\ldots,c_n)$ where each $c_i \in \univ$ and $\dedalus{node}(l)$.  A {\em spatial database instance} is defined similarly to a database instance.

Given a database schema $\schema$, we use $\stschema$ to denote the extension of
$\schema$ obtained by adding two additional columns to each relation schema in ($\schema - \{\dedalus{<}\}$) and adding four additional relation schemas to $\schema$. 
The first additional column is a location specifier and the second is a {\em timestamp}.  By convention, the location specifier is the first column of every relation in $\stschema$ and the timestamp is the second.  
The additional relation schemas we add are: $(\dedalus{node},1)$,
$(\dedalus{time},1)$, $(\dedalus{succ},2)$, and $(\dedalus{time_lt},2)$.
We call $\stschema$ a {\em spatio-temporal} schema.

A {\em spatio-temporal fact} over a relation schema of arity $n$ is a pair consisting of the relation name and an $n+2$-tuple $(d,t,c_1,\ldots,c_n)$ where each $c_i \in \univ$, \dedalus{node(l)}, and \dedalus{time(t)}.  A {\em spatio-temporal database instance} is defined similarly to a database instance, \dedalus{time(t)} for all $\dedalus{t} \in \mathbb{N}$, \dedalus{succ(x,y)} for all $y = x + 1$, and \dedalus{time_lt(x,y)} for all $x < y$.

We will use the notation \dedalus{f@t} to mean the spatio-temporal fact obtained from the spatial fact \dedalus{f} by adding a timestamp column with the constant \dedalus{t}.

A {\em spatio-temporal rule} over a spatio-temporal schema $\stschema$ is a rule of one of the following three forms:

\begin{enumerate}
\item 
A {\em deductive} rule:

\begin{Drules}
  \drule{p(L,T,\od{W})}
        {b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{l}(L,T,\od{X\sub{l}}), !c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T)}
\end{Drules}
\item 
An {\em inductive} rule:

\begin{Drules}
  \drule{p(L,S,\od{W})}
        {b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{l}(L,T,\od{X\sub{l}}), !c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T), succ(T,S)}
\end{Drules}
\item 
An {\em asynchronous} rule:

\begin{Drules}
  \drule{p(D,S,\od{W})}
        {b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{l}(L,T,\od{X\sub{l}}),
          !c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}),
          node(L), time(T), time(S), time_lt(T,S), choice((L, T, \od{B}),(S)), node(D)}
\end{Drules}
\end{enumerate}
The latter two kinds of rules are collectively called {\em temporal} rules.

In the above rules, \od{B} is a tuple that contains all of the distinct variable
symbols in \od{X\sub{1}}, \ldots, \od{X\sub{l}}, \od{Y\sub{1}}, \ldots,
\od{Y\sub{m}}.  The variable symbols \dedalus{D} and \dedalus{L} may appear in
any of \dedalus{\od{W}, \od{X\sub{1}}, \ldots, \od{X\sub{l}}, \od{Y\sub{1}},
  \ldots, \od{Y\sub{m}}}, whereas \dedalus{T} and \dedalus{S} may not.
Head relation name \dedalus{p} may not be \dedalus{time}, \dedalus{succ}, or \dedalus{node}.
\dedalus{b\sub{1}, \ldots, b\sub{l}, c\sub{1}, \ldots, c\sub{m}} may not be
\dedalus{succ}, \dedalus{time}, \dedalus{time_lt}, or \dedalus{<}.

The unification of location specifiers and timestamps in rule bodies intuitively corresponds to considering deductions that can be evaluated at a single node at a single point in time.  Inductive rules use the \dedalus{succ} relation to carry the results of deductions into the next visible timestep.

The \dedalus{choice} construct is from Sacc\`{a} and Zaniolo~\cite{sacca-zaniolo}.
The meaning of \dedalus{choice((\od{X}), (\od{Y}))} is that the variables listed
in \od{Y} are non-deterministically functionally dependent on the variables in \od{X} with respect to
any function.  Due to variable binding restrictions, only asynchronous rules may
have a different value for the head location specifier than the body location
specifier.  Intuitively, different values for the head and body location specifiers represents
cross-node communication; a binding of \dedalus{L}, \dedalus{T}, and \od{B}
(which must include \dedalus{D} due to safety restrictions) represents a message
being sent from location \dedalus{L} to location \dedalus{D}.  To model the fact
that the network may arbitrarily delay, re-order, and batch messages, any single
value of head timestamp \dedalus{S} is permissible for a message as long as it
obeys the {\em causality constraint} \dedalus{time_lt(T,S)}.\footnote{Note that in
  other presentations of \lang (e.g.,~\cite{dedalus}), message timestamps are
  chosen from $\mathbb{N} \cup \{\Tau\}$, where $\Tau$ represents a special value
  indicating that the message was dropped by the network. In this paper, we
  assume reliable delivery of messages.}

A \lang \emph{program} is a set of spatio-temporal rules over some
spatio-temporal schema $\stschema$.  
%We will see in Section~\ref{sec:semantics}
%that the usage of negation (\dedalus{!}) in \lang programs is
%restricted. \nrc{Why does this sentence come here? Seems weird; if we don't
%  state the restrictions on negation in this section, why mention it?}

\subsubsection{Syntactic Sugar}
The restrictions on timestamps and location specifiers suggest a natural
syntactic sugar to improve readability.  We annotate inductive head relations
with \dedalus{@next} and asynchronous head relations with \dedalus{@async};
deductive rules have no head annotation.  These annotations allow us to omit the
boilerplate usage of \dedalus{node}, \dedalus{time}, \dedalus{succ} and
\dedalus{choice} in rule bodies, as well as the timestamp attributes from rule
heads and bodies.  We also omit location specifiers by default. The only
non-trivial use of location specifiers is in asynchronous rules; we include them
in such rules if the head location specifier is not equal to the body's. Using
this syntactic sugar, the three kinds of rules listed above can be expressed as
follows:

\begin{enumerate}

\item Deductive:

\begin{Drules}
  \drule{p(\od{W})}
        {b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{l}(\od{X\sub{l}}), !c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}})}
\end{Drules}

\item Inductive:

\begin{Drules}
  \drule{p(\od{W})@next}
        {b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{l}(\od{X\sub{l}}), !c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}})}
\end{Drules}

\item Asynchronous:

\begin{Drules}
  \drule{p(\od{W})@async}
        {b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{l}(\od{X\sub{l}}), !c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}})}
\end{Drules}
\end{enumerate}

A rule body's location specifier can be accessed by including a variable symbol
or constant prefixed with \dedalus{#} as any body atom's first argument.  In
asynchronous rules only, the head location specifier can be accessed by
including a variable symbol or constant prefixed with a \dedalus{#} as the head
atom's first argument.  The asynchronous rule below shows the pattern of binding location specifiers using \dedalus{#}; the
head and body location specifiers are bound to \dedalus{D} and \dedalus{L} respectively.
Recall that \dedalus{D} and \dedalus{L} may appear in any of \dedalus{\od{W},
  \od{X\sub{1}}, \ldots, \od{X\sub{l}}, \od{Y\sub{1}}, \ldots, \od{Y\sub{m}}}.
%\jmh{I'd give a little intuition about why spatial entanglement is cool (finite
%  domain of node) while temporal wouldn't be (infinite domain of time).}

\begin{Drules}
  \drule{p(#D,\od{W})@async}
        {b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{l}(#L,\od{X\sub{l}}), !c\sub{1}(#L,\od{Y\sub{1}}), \ldots, !c\sub{m}(#L,\od{Y\sub{m}})}
\end{Drules}

%\wrm{Previously, we had a definition of ``spatial entanglement'' here, which said that the above rule was ``spatially entangled'' if L appeared in \od{W}, or D appeared in the body.  I feel like we don't need to define this term, as we don't use it later.}

%The syntactic sugar is optional, and as we shall see it is often useful to explicitly reference location specifiers in rules.  A rule of any of the
%varieties above may be \emph{spatially entangled} in this way. For example, the rule below is a spatially entangled asynchronous rule if $L$ appears
%in $\od{W}$ or $D$ appears in $\od{X\sub{i}}$ or $\od{Y\sub{j}}$ for $0 <
%i \leq n$ and $0 < j \leq m$.
%\nrc{Do we also need to define temporal entanglement?} no, we're going to steer clear of that for this paper, I think it only adds complexity. -wrm.



\subsection{Semantics}
\label{sec:semantics}
To characterize the semantics of \lang we begin by introducing the {\em predicate dependency graph} (PDG), an abstraction of the \lang syntax that
captures the dependencies among predicates, temporal constraints and negation~\cite{ullmanbook}.
The PDG of a \lang program $P$ with spatio-temporal schema $\stschema$ is a
directed graph with one node per relation; each node $i$ has a label $L(i)$.  If node $i$ represents relation \dedalus{p}, then $L(i) = \dedalus{p}$.  There is an edge from the node with label $\dedalus{q}$ to the node with label $\dedalus{p}$ if relation \dedalus{p} appears in the head of a rule with \dedalus{q} in its body.  If some rule with \dedalus{p} in the head and \dedalus{q} in the body is asynchronous (resp.\ inductive), then the edge is said to be {\em asynchronous} (resp.\ {\em inductive}).  If some rule with \dedalus{p} in the head has \dedalus{!q} in its body, then the edge is said to be {\em negated}.  Collectively, asynchronous and inductive edges are referred to as {\em temporal edges}.  The PDG does not contain nodes for the \dedalus{node}, \dedalus{succ}, \dedalus{time}, \dedalus{time_lt}, or \dedalus{<} relations, or the \dedalus{choice} construct.

We restrict the usage of negation in \lang so that all cycles involving a negated edge in a \lang program's PDG must involve a temporal edge.
The {\em EDB relations} of a \lang program $P$ are the relations whose corresponding nodes in $P$'s PDG have no incoming edges.  All other relations are called {\em IDB}.
An {\em EDB instance} $\mathcal{E}$ is a spatial database instance that maps each EDB relation \dedalus{r} to a finite spatial relation instance for \dedalus{r}, each IDB relation to the empty spatial relation instance, and the \dedalus{node} relation to a relation instance for \dedalus{node}.
%\todo{Dave would expect something here about how the IDB is computed} % deferred to camera-ready

We define the $\Box$ operator which maps a spatial database instance $\mathcal{K}$ to a spatio-temporal database instance $\mathcal{\Box(\mathcal{K})}$.  For every \linebreak $\dedalus{r(d,c\sub{1},\ldots,c\sub{n})} \in \mathcal{K}$,  the fact $\dedalus{r(d,t,c\sub{1},\ldots,c\sub{n})} \in \mathcal{T}$ for all $\mathcal{T} \in \mathbb{N}$.
%\jmh{I'm confused---this is a non-deterministic mapping to some random timesteps?  To only one timestep $t$?}

We refer to a \lang program together with an EDB instance as a {\em \lang instance}.  A \lang program can be viewed as a mapping from EDB instances to spatio-temporal database instances.

Recall that \dedalus{choice} is only used in asynchronous rules, to model the fact that the network may arbitrarily delay, re-order, and batch messages.  A \lang program without \dedalus{choice} is {\em locally stratified}~\cite{local-strat} on the values of its timestamp attributes, because of the restriction that all PDG cycles involving a negated edge also involve a temporal edge; thus, it is natural to use the locally stratified semantics to define the mapping for a \lang program of this kind.  Sacc\`{a} and Zaniolo~\cite{sacca-zaniolo} propose the {\em stable model semantics} as a natural interpretation of \dedalus{choice}.  The only salient detail of the stable model semantics for our purposes is its interaction with choice.  Each stable model is a spatio-temporal database instance that defines a possible function for \dedalus{choice} that obeys the causality constraint; every possible function that obeys the causality constraint defines a stable model.  Intuitively, each stable model corresponds with the locally stratified model~\cite{stable-model} obtained by treating \dedalus{choice} as a normal EDB relation, and representing the choice function as part of the EDB instance.

\begin{example}
\label{ex:uncountable}
Take the following \lang program, with the EDB instance \{\dedalus{node(n1), q(n1,0), q(n1,1)}\}.

\begin{Drules}
  \drule{p(#L,X)@async}
        {q(#L,X)}
\end{Drules}

Let $\mathcal{N}$ represent the set of all infinite subsets of $\mathbb{N}$.
The stable models (with \dedalus{q} and \dedalus{node} facts omitted) are exactly \linebreak $\{ \, \dedalus{p(n1,i,0), p(n1,j,1)} \, | \, (i,j) \in \mathcal{N}
\times \mathcal{N} \, \}$.  To see this, consider the unsugared version of the program:

\begin{Drules}
  \drule{p(L,S,X)}
        {q(L,T,X), node(L), time(T), time(S), time_lt(T,S), choice((L,T,X),(S))}
\end{Drules}

A given stable model $\{ \, \dedalus{p(n1,i,0), p(n1,j,1)} \, | \, (i,j)\in \mathcal{N}                                                    
\times \mathcal{N} \, \}$ corresponds to a function $f : \left(\{\dedalus{n1}\} \times \mathbb{N} \times \{\dedalus{0},\dedalus{1}\}\right) \rightarrow \mathbb{N}$.  If $g(x) = f(\dedalus{n1}, x, \dedalus{0})$ and $h(x) = f(\dedalus{n1}, x, \dedalus{1})$, then the image of $g(x)$ is $t_1$ and the image of $h(x)$ is $t_2$.
\end{example}

%deferred to camera-ready
%\paa{not ready to whack it yet, but we should consider breaking the above discussion into two (more chewable) pieces: first, making no assumptions about q's persistence, show that a single async rule induces an infinite number of stable models, and how each model may be viewed as fixing a 'choice function' as EDB.  then, mention among the 'problems' below that rules with all persistent subgoals make an infinite number of choices, inducing an uncountable number of stable models}
%\jmh{Yes this stuff flies by too quickly and with too little motivation/explanation.}

\subsubsection{Ultimate Models}
There are two problems with using the stable model semantics to assign an
interpretation to a \lang program. First, a program with even one asynchronous
rule may have uncountably many stable models.  Many of these stable models have
temporal differences that we are not interested in distinguishing.  Second, a
stable model of a \lang program may itself be infinite, and we desire a finite
representation.  We address both concerns in our definition of an {\em ultimate
  model}.

An {\em output schema} for a \lang program $P$ with spatio-temporal schema
$\stschema$ is a subset of $P$'s spatial schema $\sschema$.  We denote the output schema as
$\oschema$.
%An \emph{output relation schema} is a member of $\oschema$.

Recall that a stable model defines a spatio-temporal database instance, which is a mapping from every relation \dedalus{r} in $\stschema$ to a spatio-temporal relation instance for \dedalus{r}, which itself is a set of spatio-temporal facts for \dedalus{r}.  We define the {\em eventually always true} function $\Diamond\Box$, which maps a spatio-temporal database instance $\mathcal{T}$ to a spatial database instance $\Diamond\Box\mathcal{T}$.  For every spatio-temporal fact $\dedalus{r(p,t,c\sub{1},\ldots,c\sub{n})} \in \mathcal{T}$, the spatial fact $\dedalus{r(p,c\sub{1},\ldots,c\sub{n})} \in \Diamond\Box\mathcal{T}$ if relation \dedalus{r} is in $\oschema$ and $\forall \dedalus{s}\, . \, \left(\dedalus{s} \in \mathbb{N} \land \dedalus{t} < \dedalus{s}\right) \Rightarrow$ \linebreak $\left(\dedalus{r(p,s,c\sub{1},\ldots,c\sub{n})} \in \mathcal{T}\right)$.

The set of {\em ultimate models} of a \lang instance $I$ is
$\{\Diamond\Box(\mathcal{T}) \, | \, \mathcal{T}$ $\text{is a stable model of
  I}\}$.  Intuitively, an ultimate model contains exactly the facts in relations
in the output schema that are eventually always true in a stable model.

Note that an ultimate model is always finite, because of the finiteness of the EDB, the safety conditions on rules, the restrictions on the use of \dedalus{succ} and \dedalus{time}, and the prohibition on binding timestamps to non-timestamp attributes.  A \lang program only has a finite number of ultimate models for the same reason.

\begin{example}
Assuming $\oschema = \{\dedalus{p}\}$, the set of ultimate models for the \lang instance shown in Example~\ref{ex:uncountable} is \linebreak $\{ \, \{\}, \{ \, \dedalus{p(n1,0)} \, \}, \{ \, \dedalus{p(n1,1)} \, \}, \{ \, \dedalus{p(n1,0), p(n1,1)} \, \} \, \}$.
\end{example}

%Note that some nontrivial programs may have an empty ultimate model, such as the
%following program:

%\begin{example}
%\label{ex:flipflop}
%Consider the following \lang program 
%\begin{Drules}
%  \drule{flipflop(Y,X)@next}
%        {flipflop(X,Y)}
%  \dfact{flipflop(1,2).}
%\end{Drules}

%\dedalus{flipflop(1,2)} is true at all odd times and \dedalus{flipflop(2,1)} is true at all even times.  Thus, \dedalus{flipflop(1,2)} and \dedalus{flipflop(2,1)} are each cyclic with period 2.                                                                       
%\end{example}

\begin{comment}
%% paa---I don't think we need these anymore
We give two more examples of programs with ultimate models:

In both examples, we assume that the output schema consists of \dedalus{p}, and the EDB instance consists of $\{\dedalus{q_edb(), r_edb()}\}$.

\begin{example}
\label{ex:diffluent1}
A \lang program with multiple ultimate models.

\begin{Drules}
  \drule{q()@async}
        {q_edb()}
  \drule{r()@async}
        {r_edb()}
  \drule{p()}
        {q(), !r()}
  \drule{q()@next}
        {q()}
  \drule{r()@next}
        {r()}
  \drule{p()@next}
        {p()}
\end{Drules}

Any stable model where \dedalus{q()} has a lower timestamp than \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.  %Note that all relations are inflationary.
The \lang instance obtained by removing the negation from \dedalus{r()} has a unique ultimate model.
\end{example}

\begin{example}
\label{ex:diffluent2}
A \lang program with multiple ultimate models.

\begin{Drules}
  \drule{q()@async}
        {q_edb()}
  \drule{r()@async}
        {r_edb()}
  \drule{p()}
        {q(), r()}
  \drule{q()@next}
        {q()}
  \drule{p()@next}
        {p()}
\end{Drules}

Any stable model where the timestamp of \dedalus{q()} is less than or equal to the timestamp of \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.  Note that the program is negation-free.  The \lang instance obtained by adding the rule \dedalus{r()@next $\leftarrow$ r().} has a unique ultimate model.
\end{example}
\end{comment}

%\subsection{Operational Interpretation}
%\label{sec:operational}

%\todo{Come up with ``PTIME w/ distribution'' model of computation?}
