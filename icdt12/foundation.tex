\section{\large \bf \lang}
\label{sec:foundation}

\subsection{Preliminary Definitions}

\todo{Thread a running example through the paper}
\todo{ensure ``relation'' vs ``relation name'' usage is consistent}
\todo{Cite Datalog 2.0 workshop paper}

We assume an infinite universe $\univ$.

A {\em relation schema} is a pair consisting of a relation name and its arity.
A {\em database schema} $\schema$ is a finite set of relation schemas.
%\nrc{Confusing: relation schema is a singleton, but ``schema'' is a set of relation schemas?} 
%I'm changing ``schema'' to ``database schema''.  A google search for [``relational schema'' ``database schema''] reveals this to be at least somewhat standard.

A {\em fact} over a relation schema $(\dedalus{r}, n)$ is a pair consisting of
the relation name \dedalus{r} and an $n$-tuple $(c_1,\ldots,c_n)$, where each
$c_i \in \univ$.  We denote a fact with relation name \dedalus{r} by
\dedalus{r(c\sub{1}, \ldots, c\sub{n})}.  As in~\cite{immerman-ptime}, we assume
the existence of an order: every database schema contains the relation schema
$(\dedalus{<},2)$~\footnote{We will often write \dedalus{<} in infix notation.}.
A {\em relation instance} for relation \dedalus{r} is a set of facts for
\dedalus{r}.  A {\em database instance} maps each relation $\dedalus{r} !=
\dedalus{<}$ to a relation instance for \dedalus{r}, and maps \dedalus{<} to an
infinite set of \dedalus{<} facts that encode a total ordering over $\univ$.

By a {\em rule} over a schema $\schema$, we mean a Datalog-style rule -- a clause of the form:

\begin{Drules}
  \drule{p(\od{W})}
        {b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}), !c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}})}
\end{Drules}

where \dedalus{p}, \dedalus{b\sub{1}}, \ldots, \dedalus{b\sub{n}},
\dedalus{c\sub{1}}, \ldots, \dedalus{c\sub{m}} are relations in
$\schema$, and \od{X\sub{i}} and \od{Y\sub{j}}
denote a tuple (of the appropriate arity) consisting of
constants from $\univ$ or variable symbols.  The {\em atom} to the left of the $\leftarrow$ is called the {\em head} of the rule, and the conjunction of atoms to the right is called the rule's {\em body}.

\dedalus{p} may not be \dedalus{<}.  Note that we maintain the usual safety
restrictions of Datalog rules: any variable symbol \dedalus{V} that appears in
\od{Y\sub{i}} for some $1 \leq i \leq m$ must also appear in
\od{X\sub{j}} for some $1 \leq j \leq n$, but only if \dedalus{V}
appears in \od{W} or \dedalus{V} appears in
\od{Y\sub{k}} for some $k \neq i$ -- i.e., variable symbols that
only appear in a single negated atom and do not appear in the head need not also
appear in a positive atom~\cite{ullmanbook}.  Also, any variable symbol \dedalus{V} that appears in \od{W} must appear in some \dedalus{\od{X\sub{1}}, \ldots, \od{X\sub{n}}}.
Furthermore, if \dedalus{b\sub{i}} (resp. \dedalus{c\sub{i}}) is \dedalus{<}, then any variable that appears in \dedalus{X\sub{i}} (resp. \dedalus{Y\sub{i}}) must also appear in \dedalus{X\sub{j}} for some $j \neq i$ -- i.e., variable symbols that appear in a \dedalus{<} atom must also appear in a non-negated atom.

Given a schema $\schema$, we use $\sschema$ to denote the extension of $\schema$
obtained by adding a column to each relation schema in $\schema$ (except
\dedalus{<}) and adding an additional relation schema to $\schema$.  The
additional column is called a {\em location specifier}.  By convention, the
location specifier is the first column of every relation in $\sschema$.  The
additional relation schema is $(\dedalus{node},1)$.  We call $\sschema$ a {\em
  spatial} schema.

A {\em spatial fact} over a relation schema of arity $n$ is a pair consisting of the relation name and an $n+1$-tuple $(l,c_1,\ldots,c_n)$ where each $c_i \in \univ$, $l \in \dedalus{node}$.  A {\em spatial database instance} is defined similarly to a database instance.

Given a schema $\schema$, we use $\stschema$ to denote the extension of
$\schema$ obtained by adding two additional columns to each relation schema in $\schema$ and adding three additional relation schemas to $\schema$. 
The first additional column is a location specifier, the second is a {\em timestamp}.  By convention, the location specifier is the first column of every relation in $\stschema$ and the timestamp is the second.  
The additional relation schemas we add are: $(\dedalus{node},1)$,
$(\dedalus{time},1)$, and $(\dedalus{succ},2)$.
We call $\stschema$ a {\em spatio-temporal} schema.

A {\em spatio-temporal fact} over a relation schema of arity $n$ is a pair consisting of the relation name and an $n+2$-tuple $(l,t,c_1,\ldots,c_n)$ where each $c_i \in \univ$, $l \in \dedalus{node}$, and $t \in \mathbb{N}$.  A {\em spatio-temporal database instance} is defined similarly to a database instance, except \dedalus{time} is mapped to an infinite set of \dedalus{time} facts representing $\mathbb{N}$, and \dedalus{succ} is mapped to an infinite set of \dedalus{succ} facts representing the natural successor relation over $\mathbb{N}$.

A {\em spatio-temporal rule} over a spatio-temporal schema $\stschema$ is a rule of one of the following three forms:

A {\em deductive} rule:

\begin{Drules}
  \drule{p(L,T,\od{W})}
        {b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}), !c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T)}
\end{Drules}

An {\em inductive} rule:

\begin{Drules}
  \drule{p(L,S,\od{W})}
        {b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}), !c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T), succ(T,S)}
\end{Drules}

An {\em asynchronous} rule:

\begin{Drules}
  \drule{p(D,S,\od{W})}
        {b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}),
          !c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}),
          node(L), time(T), time(S), T < S, choice((L, T, \od{B}),(S)), node(D)}
\end{Drules}

The latter two kinds of rules are collectively called {\em temporal} rules.

In the above rules, \od{B} is a tuple that contains all of the distinct variable symbols in  \od{X\sub{1}}, \ldots, \od{X\sub{n}}, \od{Y\sub{1}}, \ldots, \od{Y\sub{m}}.  The variable symbols \dedalus{D} and \dedalus{L} may appear in any of \dedalus{\od{W}, \od{X\sub{1}}, \ldots, \od{X\sub{n}}, \od{Y\sub{1}}, \ldots, \od{Y\sub{m}}}, whereas \dedalus{T} and \dedalus{S} may not.  \dedalus{p} may not be \dedalus{time}, \dedalus{succ}, or \dedalus{node}.  \dedalus{b\sub{1}, \ldots, b\sub{n}, c\sub{1}, \ldots, c\sub{m}} may not be \dedalus{succ} or \dedalus{time}.

\dedalus{choice} is the construct of Sacc\`{a} and Zaniolo~\cite{sacca-zaniolo}; the meaning of \dedalus{choice((\od{X}), (\od{Y}))} is that the variables listed in \od{Y} are functionally dependent on the variables in \dedalus{X} with respect to any function.  Due to variable binding restrictions, only asynchronous rules may have a different value for the head location specifier than the body location specifier.  Intuitively, different values for the location specifiers represents cross-node communication; a binding of \dedalus{L}, \dedalus{T}, and \od{B} (which must include \dedalus{D} due to safety restrictions) represents a message being sent from location \dedalus{L} to location \dedalus{D}.  To model the fact that the network may arbitrarily delay, re-order, and batch messages, any single value of head timestamp \dedalus{S} is permissible for a message as long as it obeys the {\em causality constraint} \dedalus{T < S}.

A \lang \emph{program} is a set of spatio-temporal rules over some spatio-temporal schema $\stschema$.  We restrict the usage of negation (\dedalus{!}) in \lang programs.

The {\em predicate dependency graph} (PDG)~\cite{ullmanbook} of a \lang program $P$ with spatio-temporal schema $\stschema$ is a directed graph with one node per relation -- each node $i$ has a label $L(i)$.  If node $i$ represents relation \dedalus{p}, then $L(i) = \{\dedalus{p}\}$.  There is an edge from the node with label $\{\dedalus{q}\}$ to the node with label $\{\dedalus{p}\}$ if relation \dedalus{p} appears in the head of a rule with \dedalus{q} in its body.  If some rule with \dedalus{p} in the head and \dedalus{q} in the body is asynchronous (resp. inductive), then the edge is said to be {\em asynchronous} (resp. {\em inductive}).  If some rule with \dedalus{p} in the head has \dedalus{!q} in its body, then the edge is said to be {\em negated}.  Collectively, asynchronous and inductive edges are referred to as {\em temporal edges}.  The PDG does not contain nodes for the \dedalus{time}, \dedalus{succ}, or \dedalus{<} relations, or the \dedalus{choice} construct.

All cycles involving a negated edge in a \lang program's PDG must also involve a temporal edge.

\noindent
\textbf{Syntactic sugar for space-time in \lang:}
The restrictions on timestamps and location specifiers suggest a natural syntactic sugar to improve readability.  We annotate inductive head predicates with \dedalus{@next} and asynchronous head predicates with \dedalus{@async}; deductive rules have no head annotation.  These annotations allow us to scrap the boilerplate \dedalus{node}, \dedalus{time}, \dedalus{succ} and \dedalus{choice} in rule bodies, as well as the timestamp attributes from rule heads and bodies.  We also hide location specifiers by default. The three kinds of rules listed above are expressed as follows:

Deductive:

\begin{Drules}
  \drule{p(\od{W})}
        {b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}), !c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}})}
\end{Drules}

Inductive:

\begin{Drules}
  \drule{p(\od{W})@next}
        {b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}), !c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}})}
\end{Drules}

Asynchronous:

\begin{Drules}
  \drule{p(\od{W})@async}
        {b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}), !c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}})}
\end{Drules}

A rule body's location specifier can be accessed by including a variable symbol or constant prefixed with a \dedalus{#} as any body atom's first argument.  In asynchronous rules only, the head location specifier can be accessed by including a variable symbol or constant prefixed with a \dedalus{#} as the head atom's first argument.  Below is an example of an asynchronous rule that binds body and head location specifiers to \dedalus{#L} and \dedalus{#D} respectively.  Recall that \dedalus{L} and \dedalus{D} may appear in any of \dedalus{\od{W}, \od{X\sub{1}}, \ldots, \od{X\sub{n}}, \od{Y\sub{1}}, \ldots \od{Y\sub{m}}}.

\begin{Drules}
  \drule{p(#D,\od{W})@async}
        {b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{X\sub{n}}), !c\sub{1}(#L,\od{Y\sub{1}}), \ldots, !c\sub{m}(#L,\od{Y\sub{m}})}
\end{Drules}

%\wrm{Previously, we had a definition of ``spatial entanglement'' here, which said that the above rule was ``spatially entangled'' if L appeared in \od{W}, or D appeared in the body.  I feel like we don't need to define this term, as we don't use it later.}

%The syntactic sugar is optional, and as we shall see it is often useful to explicitly reference location specifiers in rules.  A rule of any of the
%varieties above may be \emph{spatially entangled} in this way. For example, the rule below is a spatially entangled asynchronous rule if $L$ appears
%in $\od{W}$ or $D$ appears in $\od{X\sub{i}}$ or $\od{Y\sub{j}}$ for $0 <
%i \leq n$ and $0 < j \leq m$.
%\nrc{Do we also need to define temporal entanglement?} no, we're going to steer clear of that for this paper, I think it only adds complexity. -wrm.



\subsection{Semantics}
The {\em EDB relations} of a \lang program $P$ are the relations whose corresponding nodes $P$'s PDG have no incoming edges.  All other relations are called {\em IDB}.
An {\em EDB instance} $\mathcal{E}$ is a spatial database instance that maps each EDB relation \dedalus{r} to a finite spatial relation instance for \dedalus{r}, and maps each IDB relation \dedalus{r} to the empty spatial relation instance.

We define the $\Box$ operator which maps a spatial database instance $\mathcal{K}$ to a spatio-temporal database instance $\mathcal{T}$.  The mapping is defined by: $\dedalus{r(l,c\sub{1},\ldots,c\sub{n})} \in \mathcal{K} \Rightarrow \{ \, \dedalus{r(l,t,c\sub{1},\ldots,c\sub{n})} \, | \, t \in \mathbb{N} \, \} \subset \mathcal{T}$. 

We refer to a \lang program together with an EDB instance as a {\em \lang instance}.  A \lang program can be viewed as a mapping from EDB instances to spatio-temporal database instances.

A \lang program without \dedalus{choice} -- recall that choice is only used in asynchronous rules -- is {\em locally stratified}~\cite{local-strat}, because of restrictions on negation; thus, it is natural to use the locally stratified semantics to define the mapping for a \lang program of this kind.  Sacc\`{a} and Zaniolo~\cite{sacca-zaniolo} propose the {\em stable model semantics} as a natural interpretation of \dedalus{choice}.  We do not review the stable model semantics here.  Defining the mapping using the stable model semantics, it is not hard to see that each stable model is a spatio-temporal database instance that defines a possible function for \dedalus{choice} that obeys the causality constraint; every possible function that obeys the causality constraint defines a stable model.  It is known that the stable model semantics coincides with the locally stratified semantics~\cite{stable-model} for locally stratified programs.

\begin{example}
\label{ex:uncountable}
Take the following \lang program, with the empty EDB instance:

\begin{Drules}
  \drule{p(#L,X)@async}
        {q(#L,X)}
  \dfact{node(n1)}
  \dfact{q(#n1,0)}
  \dfact{q(#n1,1)}
\end{Drules}

Let $\mathcal{N}$ represent the set of all infinite subsets of $\mathbb{N}$.
The stable models are exactly $\{ \, \dedalus{q(n1,i,0), q(n1,j,1)} \, | \, (i,j) \in (t_1, t_2) \, \land \, (t_1, t_2) \in \mathcal{N}
\times \mathcal{N} \, \}$.  To see this, consider the unsugared version of the program:

\begin{Drules}
  \drule{p(L,S,X)}
        {q(L,T,X), node(L), time(T), time(S), T < S, choice((L,T,X),(S))}
  \drule{node(L,T,n1)}
        {node(L), time(T)}
  \drule{q(n1,T,0)}
        {time(T)}
  \drule{q(n1,T,1)}
        {time(T)}
\end{Drules}

\paa{not sure why we don't just say that all facts have a simple persistence rule.  we could retain the notational convenience of $\Box$ and $\Diamond$ by defining them
separately, and perhaps pointing out that $p \Rightarrow \Box p$ whenever $p$ is simply persisted}


A given stable model $\{ \, \dedalus{q(n1,i,0), q(n1,j,1)} \, | \, (i,j)\in (t_1, t_2) \, \land \, (t_1, t_2)\in \mathcal{N}                                                    
\times \mathcal{N} \, \}$ corresponds to the function $f : \left(\{\dedalus{n1}\} \times \mathbb{N} \times \{\dedalus{0},\dedalus{1}\}\right) \rightarrow \mathbb{N}$.  If $g(x) = f(\dedalus{n1}, x, \dedalus{0})$ and $h(x) = f(\dedalus{n1}, x, \dedalus{1})$, then the image of $g(x)$ is $t_1$, and the image of $h(x)$ is $t_2$.
\end{example}

\paa{not ready to whack it yet, but we should consider breaking the above discussion into two (more chewable) pieces: first, making no assumptions about q's persistence, show that a single async rule induces an infinite number of stable models, and how each model may be viewed as fixing a 'choice function' as EDB.  then, mention among the 'problems' below that rules with all persistent subgoals make an infinite number of choices, inducing an uncountable number of stable models}

There are two potential problems with considering the stable models as the meaning of a \lang instance.  
First, a program with even one asynchronous rule may have uncountably many stable models, and not all of these may be meaningfully different.  Second, a stable model of a \lang program may itself be infinite.  We address both concerns in our definition of an {\em ultimate model}.

An {\em output schema} for a \lang program $P$ with spatio-temporal schema
$\stschema$ is a subset of $P$'s spatial schema $\sschema$.  We denote the output schema as
$\oschema$.
%An \emph{output relation schema} is a member of $\oschema$.

Recall that a stable model defines a spatio-temporal database instance, which is a mapping from every relation \dedalus{r} in $\stschema$ to a spatio-temporal relation instance for \dedalus{r}, which itself is a set of spatio-temporal facts for \dedalus{r}.  We define the {\em eventually always true} function $\Diamond\Box$, which maps a spatio-temporal database instance $\mathcal{T}$ to a spatial database instance $\Diamond\Box\mathcal{T}$.  For every spatio-temporal fact $\dedalus{r(l,t,c\sub{1},\ldots,c\sub{n})} \in \mathcal{T}$, the spatial fact $\dedalus{r(l,c\sub{1},\ldots,c\sub{n})} \in \Diamond\Box\mathcal{T}$ if relation \dedalus{r} is in $\oschema$ and $\forall \dedalus{s}\, . \, \left(\dedalus{s} \in \mathbb{N} \land \dedalus{t} < \dedalus{s}\right) \Rightarrow \left(\dedalus{r(l,s,c\sub{1},\ldots,c\sub{n})} \in \mathcal{T}\right)$.

The set of {\em ultimate models} of a \lang instance $I$ is $\{\Diamond\Box(\mathcal{T}) \, | \, \mathcal{T}$  $\text{is a stable model of I}\}$.  Intuitively, an ultimate model contains exactly the facts in relations in the output schema that are eventually always true in a stable model.

Note that an ultimate model is always finite, because of the finiteness of the EDB, the safety conditions on rules, the restrictions on the use of \dedalus{time} and \dedalus{succ}, and the prohibition on binding timestamps to non-timestamp attributes.  A \lang program only has a finite number of ultimate models for the same reason.

\begin{example}
The set of ultimate models for the \lang instance shown in Example~\ref{ex:uncountable} is $\{ \, \{\}, \{ \, \dedalus{p(n1,0)} \, \}, \{ \, \dedalus{p(n1,1)} \, \}, \{ \, \dedalus{p(n1,0), p(n1,1)} \, \} \, \}$.
\end{example}

%Note that some nontrivial programs may have an empty ultimate model, such as the
%following program:

%\begin{example}
%\label{ex:flipflop}
%Consider the following \lang program 
%\begin{Drules}
%  \drule{flipflop(Y,X)@next}
%        {flipflop(X,Y)}
%  \dfact{flipflop(1,2).}
%\end{Drules}

%\dedalus{flipflop(1,2)} is true at all odd times and \dedalus{flipflop(2,1)} is true at all even times.  Thus, \dedalus{flipflop(1,2)} and \dedalus{flipflop(2,1)} are each cyclic with period 2.                                                                       
%\end{example}

We give two more examples of programs with ultimate models:

In both examples, we assume that the output schema consists of \dedalus{p}, and the EDB instance consists of $\{\dedalus{q_edb(), r_edb()}\}$.

\begin{example}
\label{ex:diffluent1}
A \lang program with multiple ultimate models.

\begin{Drules}
  \drule{q()@async}
        {q_edb()}
  \drule{r()@async}
        {r_edb()}
  \drule{p()}
        {q(), !r()}
  \drule{q()@next}
        {q()}
  \drule{r()@next}
        {r()}
  \drule{p()@next}
        {p()}
\end{Drules}

Any stable model where \dedalus{q()} has a lower timestamp than \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.  Note that all predicates are inflationary.  The \lang instance obtained by removing the negation from \dedalus{r()} has a unique ultimate model.
\end{example}

\begin{example}
\label{ex:diffluent2}
A \lang program with multiple ultimate models.

\begin{Drules}
  \drule{q()@async}
        {q_edb()}
  \drule{r()@async}
        {r_edb()}
  \drule{p()}
        {q(), r()}
  \drule{q()@next}
        {q()}
  \drule{p()@next}
        {p()}
\end{Drules}

Any stable model where the timestamp of \dedalus{q()} is less than or equal to the timestamp of \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.  Note that the program is negation-free.  The \lang instance obtained by adding the rule \dedalus{r()@next $\leftarrow$ r().} has a unique ultimate model.
\end{example}

\subsection{Operational Interpretation}
\label{sec:operational}

\todo{Come up with ``PTIME w/ distribution'' model of computation?}
