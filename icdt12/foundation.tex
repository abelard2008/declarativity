\section{\large \bf \lang}
\label{sec:foundation}

\subsection{Preliminary Definitions}

\todo{Thread a running example through the paper}
\todo{define head and body of rule}
\todo{make sure usage of ``relation'' vs ``relation schema'' is consistent}

We assume an infinite universe $\univ$.

A {\em relation schema} is a pair consisting of a relation name and its arity.
A {\em database schema} $\schema$ is a finite set of relation schemas.
%\nrc{Confusing: relation schema is a singleton, but ``schema'' is a set of relation schemas?} 
%I'm changing ``schema'' to ``database schema''.  A google search for [``relational schema'' ``database schema''] reveals this to be at least somewhat standard.

A {\em fact} over a relation schema $(\dedalus{r}, n)$ is a pair consisting of the
relation name \dedalus{r} and an $n$-tuple $(c_1,\ldots,c_n)$, where each $c_i \in \univ$.  We denote a fact with relation name \dedalus{r} by \dedalus{r(c\sub{1}, \ldots, c\sub{n})}.  As in~\cite{immerman-ptime}, we assume the existence of an order: every database schema contains the relation schema $(\dedalus{<},2)$~\footnote{We will often write \dedalus{<} in infix notation.}.  A {\em relation instance} for relation \dedalus{r} is a finite set of facts for\dedalus{r}.  A {\em database instance} maps each relation $\dedalus{r} != \dedalus{<}$ to a relation instance for \dedalus{r}, and maps \dedalus{<} to an infinite set of \dedalus{<} facts that encode a total ordering over $\univ$.

By a {\em rule} over a schema $\schema$, we mean a Datalog-style rule -- a clause of the form:

\begin{Drules}
  \drule{p(\od{W})}
        {b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}), !c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}})}
\end{Drules}

where \dedalus{p}, \dedalus{b\sub{1}}, \ldots, \dedalus{b\sub{n}},
\dedalus{c\sub{1}}, \ldots, \dedalus{c\sub{m}} are relations in
$\schema$, and \od{X\sub{i}} and \od{Y\sub{j}}
denote a tuple (of the appropriate arity) consisting of
constants from $\univ$ or variable symbols.  \dedalus{p} may not be \dedalus{<}.  Note that we maintain the usual safety
restrictions of Datalog rules: any variable symbol \dedalus{V} that appears in
\od{Y\sub{i}} for some $1 \leq i \leq m$ must also appear in
\od{X\sub{j}} for some $1 \leq j \leq n$, but only if \dedalus{V}
appears in \od{W} or \dedalus{V} appears in
\od{Y\sub{k}} for some $k \neq i$ -- i.e., variable symbols that
only appear in a single negated atom and do not appear in the head need not also
appear in a positive atom~\cite{ullmanbook}.  Furthermore, if \dedalus{b\sub{i}} (resp. \dedalus{c\sub{i}}) is \dedalus{<}, then any variable that appears in \dedalus{X\sub{i}} (resp. \dedalus{Y\sub{i}}) must also appear in \dedalus{X\sub{j}} for some $j \neq i$ -- i.e., variable symbols that appear in a \dedalus{<} atom must also appear in a non-negated atom.

\todo{describe recursion, rule out recursion through negation, define EDB}

Given a schema $\schema$, we use
$\sschema$ to denote the extension of $\schema$ obtained by adding a column to
each relation schema in $\schema$ (except \dedalus{<}) and adding an additional relation schema to $\schema$.  The
additional column is called a {\em location specifier}.  
By convention, the location specifier is the first column of every relation in $\sschema$.  The
additional relation schema is $(\dedalus{node},1)$.
We call $\sschema$ a {\em spatial} schema.

A {\em spatial fact} over a relation schema of arity $n$ is a pair consisting of the relation name and an $n+1$ tuple $(l,c_1,\ldots,c_n)$ where each $c_i \in \univ$, $l \in \dedalus{node}$.  A {\em spatial database instance} is defined similarly to a database instance.

Given a schema $\schema$, we use $\stschema$ to denote the extension of
$\schema$ obtained by adding two additional columns to each relation schema in $\schema$ and adding three additional relation schemas to $\schema$. 
The first additional column is a location specifier, the second is a {\em timestamp}.  By convention, the location specifier is the first column of every relation in $\stschema$, and the timestamp is the second.  
The additional relation schemas we add are: $(\dedalus{node},1)$,
$(\dedalus{time},1)$, and $(\dedalus{succ},2)$.
We call $\stschema$ a {\em spatio-temporal} schema.

A {\em spatio-temporal fact} over a relation schema of arity $n$ is a pair consisting of the relation name and an $n+2$ tuple $(l,t,c_1,\ldots,c_n)$ where each $c_i \in \univ$, $l \in \dedalus{node}$, and $t \in \mathbb{N}$.  A {\em spatio-temporal database instance} is defined similarly to a database instance, except \dedalus{time} is mapped to an infinite set of \dedalus{time} facts representing $\mathbb{N}$, and \dedalus{succ} is mapped to an infinite set of \dedalus{succ} facts representing the natural successor relation over $\mathbb{N}$.

A {\em spatio-temporal rule} over a spatio-temporal schema $\stschema$ is a rule of one of the following three forms:

\todo{ensure sugaring diction reflects that we have a node(L) and time(T) in the body of all rules!}
\todo{ensure that it's clear that asynchronous rules can also be local}

A {\em deductive} rule:

\begin{Drules}
  \drule{p(L,T,\od{W})}
        {b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}), !c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T)}
\end{Drules}

An {\em inductive} rule:

\begin{Drules}
  \drule{p(L,S,\od{W})}
        {b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}), !c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T), succ(T,S)}
\end{Drules}

An {\em asynchronous} rule:

\begin{Drules}
  \drule{p(D,S,\od{W})}
        {b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}),
          !c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}),
          node(L), time(T), time(S), T < S, choice((L, T, \od{B}),(S)), node(D)}
\end{Drules}

The latter two kinds of rules are collectively called {\em temporal} rules.

In the above rules, \od{B} is a tuple that contains all of the distinct variable symbols in  \od{X\sub{1}}, \ldots, \od{X\sub{n}}, \od{Y\sub{1}}, \ldots, \od{Y\sub{m}}.  The variable symbols \dedalus{D} and \dedalus{L} may appear in any of \dedalus{\od{W}, \od{X\sub{1}}, \ldots, \od{X\sub{n}}, \od{Y\sub{1}}, \ldots, \od{Y\sub{m}}}, whereas \dedalus{T} and \dedalus{S} may not.  \dedalus{p} may not be \dedalus{time}, \dedalus{succ}, or \dedalus{node}.  \dedalus{b\sub{1}, \ldots, b\sub{n}, c\sub{1}, \ldots, c\sub{m}} may not be \dedalus{succ} or \dedalus{time}.  \dedalus{choice} is the construct of
Sacc\`{a} and Zaniolo~\cite{sacca-zaniolo}, which we will describe later.

A \lang\ {\em program} is a set of spatio-temporal rules over some spatio-temporal schema $\stschema$.  

\noindent
\textbf{Syntactic sugar for space-time in \lang:}
The restrictions on timestamps and location specifiers suggest a natural syntactic sugar to improve readability.  We annotate inductive head predicates with \dedalus{@next} and asynchronous head predicates with \dedalus{@async}; deductive rules have no head annotation.  These annotations allow us to scrap the boilerplate \dedalus{node}, \dedalus{time}, \dedalus{succ} and \dedalus{choice} in rule bodies, as well as the timestamp attributes from rule heads and bodies.  We also hide location specifiers by default. The three kinds of rules listed above are expressed as follows:

Deductive:

\begin{Drules}
  \drule{p(\od{W})}
        {b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}), !c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}})}
\end{Drules}

Inductive:

\begin{Drules}
  \drule{p(\od{W})@next}
        {b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}), !c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}})}
\end{Drules}

Asynchronous:

\begin{Drules}
  \drule{p(\od{W})@async}
        {b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}), !c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}})}
\end{Drules}

A rule body's location specifier can be accessed by including a variable symbol or constant prefixed with a \dedalus{#} as any body atom's first argument.  In asynchronous rules only, the head location specifier can be accessed by including a variable symbol or constant prefixed with a \dedalus{#} as the head atom's first argument.  Below is an example of an asynchronous rule that binds body and head location specifiers to \dedalus{#L} and \dedalus{#D} respectively.  Recall that \dedalus{L} and \dedalus{D} may appear in any of \dedalus{\od{W}, \od{X\sub{1}}, \ldots, \od{X\sub{n}}, \od{Y\sub{1}}, \ldots \od{Y\sub{m}}}.

\begin{Drules}
  \drule{p(#D,\od{W})@async}
        {b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{X\sub{n}}), !c\sub{1}(#L,\od{Y\sub{1}}), \ldots, !c\sub{m}(#L,\od{Y\sub{m}})}
\end{Drules}

\wrm{Previously, we had a definition of ``spatial entanglement'' here, which said that the above rule was ``spatially entangled'' if L appeared in \od{W}, or D appeared in the body.  I feel like we don't need to define this term, as we don't use it later.}

%The syntactic sugar is optional, and as we shall see it is often useful to explicitly reference location specifiers in rules.  A rule of any of the
%varieties above may be \emph{spatially entangled} in this way. For example, the rule below is a spatially entangled asynchronous rule if $L$ appears
%in $\od{W}$ or $D$ appears in $\od{X\sub{i}}$ or $\od{Y\sub{j}}$ for $0 <
%i \leq n$ and $0 < j \leq m$.
%\nrc{Do we also need to define temporal entanglement?} no, we're going to steer clear of that for this paper, I think it only adds complexity. -wrm.



\subsection{Semantics}
One interpretation of a \lang instance is given by the possible worlds of the
stable model semantics~\cite{stable-model}.  The stable model semantics is proposed for \dedalus{choice} by Sacc\`{a} and Zaniolo~\cite{sacca-zaniolo}.
We do not review the stable model
semantics here -- the only salient detail is the interaction of \dedalus{choice}
with the stable model semantics.  Since the stable model semantics coincides with the locally stratified semantics \wrm{cite}, a \lang program without \dedalus{choice} (i.e., without an asynchronous rule) has a unique stable model as it is locally stratified.  A \lang program with asynchronous rules has infinitely many stable models.  Each stable model is the locally stratified model obtained by treating the \dedalus{choice} construct as an EDB relation and adding facts for all chosen timestamps.

\begin{example}
Take the following \lang instance:

\begin{Drules}
  \drule{p(#L,X)@async}
        {q(#L,X)}
  \dfact{node(n1)}
  \dfact{q(#n1,0)}
  \dfact{q(#n1,1)}
\end{Drules}

Let $\mathcal{N}$ represent the set of all infinite subsets of $\mathbb{N}$.
The possible stable models are exactly the elements $(n_1, n_2) \in \mathcal{N}
\times \mathcal{N}$, where the first coordinate represents the set of all
timestamps for which \dedalus{p(n1,0)} is true, and the second represents the
set of all timestamps for which \dedalus{p(n1,1)} is true.  Consider the
unsugared version of the program:

\begin{Drules}
  \drule{p(L,S,X)}
        {q(L,T,X), node(L), time(T), time(S), T < S, choice((L,T,X),(S))}
  \drule{node(L,T,n1)}
        {node(L), time(T)}
  \drule{q(n1,T,0)}
        {time(T)}
  \drule{q(n1,T,1)}
        {time(T)}
\end{Drules}

To compute a particular stable model $(n_1,n_2)$, we can treat \dedalus{choice} as an EDB relation, and for each of $n_1$ and $n_2$, create functions $f_1, f_2 : \mathbb{N} \rightarrow \mathbb{N}$, such that the image of $f_1$ is $n_1$, and the image of $f_2$ is $n_2$.  Then, add the appropriate infinite set of \dedalus{choice} facts to the EDB to encode the functions.  The resulting instance has a unique stable model as it is locally stratified, which coincides with its locally stratified model.
\end{example}

\paa{not ready to whack it yet, but we should consider breaking the above discussion into two (more chewable) pieces: first, making no assumptions about q's persistence, show that a single async rule induces an infinite number of stable models, and how each model may be viewed as fixing a 'choice function' as EDB.  then, mention among the 'problems' below that rules with
all persistent subgoals make an infinite number of choices, inducing an uncountable number of stable models}

There are two potential problems with considering a stable model as the meaning of a \lang instance.  
%%First, every program with at least one asynchronous rule has infinitely many stable models.  
First, a program with even one asynchronous rule may have uncountably many stable models.  
Not all of these stable models may be meaningfully different.  Second, a stable model of a \lang program may itself be infinite.  We address both concerns in our definition of an {\em ultimate model}.

%\paa{looks like we still need to define this.  perhaps we should define it exactly as we did in the other paper -- the UM is exactly the set of facts with trivial periodicities; the set of things eventually always true.  dedalus-c restricts the definition: the 
%UM is the set of output tuples that is eventually always true, and since these are simply peristed this reduces to the set of tuples that are ever true.  
%the burden is now on the programmer and coordination protocol to ensure that nothing goes into the output predicates until it is surely true.}

\todo{the above example also has an infinite stable model, but we like flip flop as well because it shows a nontrivial periodicity; integrate this with the definition of ultimate model}
\begin{example}
\label{ex:flipflop}
A \lang program with an infinite stable model.

\begin{Drules}
  \drule{flipflop(Y,X)@next}
        {flipflop(X,Y)}
  \dfact{flipflop(1,2)@1}
\end{Drules}

\dedalus{flipflop(1,2)} is true at all odd times and \dedalus{flipflop(2,1)} is true at all even times.  Thus, \dedalus{flipflop(1,2)} and \dedalus{flipflop(2,1)} are each cyclic with period 2.
\end{example}

An {\em output schema} for a \lang program $P$ with spatio-temporal schema
$\stschema$ is a subset of $\sschema$.  We denote the output schema as
$\oschema$. An \emph{output relation schema} is a member of $\oschema$.

An {\em ultimate model} of a \lang program $P$ with spatio-temporal schema
$\stschema$ and output schema $\oschema$ consists of all the spatial facts in
$\oschema$ that are ``eventually always'' true.  In other words spatial fact $f$
is in the ultimate model if the relation of $f$ is in $\oschema$ and $\forall t
: f@t => f@t+1$. \todo{make sure this notation is introduced} An ultimate model
is always finite, due to the finiteness of $\univ$, and by the same reasoning
any \lang program has only a finite number of ultimate models.

Note that some nontrivial programs may have an empty ultimate model, such as the
program in Example~\ref{ex:flipflop}.  Further, a \lang program may have
multiple ultimate models.  We give two such examples below. In both examples, we
assume that the output relation schema is \dedalus{p} and the EDB consists of
\dedalus{q\_edb(), r\_edb()}.

\begin{example}
\label{ex:diffluent1}
A \lang program with multiple ultimate models.

\begin{Drules}
  \drule{q()@async}
        {q_edb()}
  \drule{r()@async}
        {r_edb()}
  \drule{p()}
        {q(), !r()}
  \drule{q()@next}
        {q()}
  \drule{r()@next}
        {r()}
\end{Drules}

Any stable model where \dedalus{q()} has a lower timestamp than \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.  \wrm{The problem here is negation}.
\end{example}

\begin{example}
\label{ex:diffluent2}
A \lang program with multiple ultimate models.

\begin{Drules}
  \drule{q()@async}
        {q_edb()}
  \drule{r()@async}
        {r_edb()}
  \drule{p()}
        {q(), r()}
  \drule{q()@next}
        {q()}
\end{Drules}

Any stable model where the timestamp of \dedalus{q()} is less than or equal to the timestamp of \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.
\end{example}

\subsection{Operational Interpretation}
\label{sec:operational}

\todo{See if any transducers/Dedalus stuff has been published, and cite it here.}
