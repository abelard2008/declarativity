\section{\large \bf \lang}
\label{sec:foundation}

\subsection{Preliminary Definitions}

\todo{define head and body of rule}
\todo{say something about the partitioning or accessibility of the order}
\todo{make sure it's clear that $\univ$ includes \dedalus{node} but not \dedalus{time}}
\todo{make sure usage of ``relation'' vs ``relation schema'' is consistent}

We assume an infinite universe $\univ$.

A {\em relation schema} is a pair consisting of a relation name and its arity.
A {\em schema} $\schema$ is a set of relation schemas.  \nrc{Confusing:
  relation schema is a singleton, but ``schema'' is a set of relation schemas?} As in \wrm{cite Immerman}, we assume the existence of an order.  Thus, all schemas contain the following relational schemas: \dedalus{lt} -- a relation of arity two that is true whenever the second argument is greater than the first (we will write this relation in infix form using the \dedalus{<} symbol) -- \dedalus{suc} -- a relation of arity two that defines a total order over $\univ$ \wrm{different from succ}.

A {\em rule} over a schema $\schema$ is a clause of the form:

\begin{Dedalus}
p(\od{X\sub{0}}) <- b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}),
!c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}}).
\end{Dedalus}

where \dedalus{p}, \dedalus{b\sub{1}}, \ldots, \dedalus{b\sub{n}},
\dedalus{c\sub{1}}, \ldots, \dedalus{c\sub{m}} are relations in
$\schema$, and \od{X\sub{i}} and \od{Y\sub{j}}
denote a tuple (of the appropriate arity) consisting of variable symbols or
constants from $\univ$.  Note that we maintain the usual safety
restrictions of Datalog rules: any variable symbol \dedalus{V} that appears in
\od{Y\sub{i}} for some $1 \leq i \leq m$ must also appear in
\od{X\sub{j}} for some $1 \leq j \leq n$, but only if \dedalus{V}
appears in \od{X\sub{0}} or \dedalus{V} appears in
\od{Y\sub{k}} for some $k \neq i$ -- i.e., variable symbols that
only appear in a single negated atom and do not appear in the head need not also
appear in a positive atom \wrm{cite ullman}.

\wrm{describe recursion, rule out recursion through negation, define EDB}

A {\em fact} over a relation schema of arity $n$ is a pair consisting of the
relation name and an $n$-tuple $(c_1,\ldots,c_n)$, where each $c_i \in
\univ$.  An \emph{instance} $\mathcal{I}$ over a schema $\schema$ is a
set of facts. \todo{check the rest of the paper to make sure we're using ``instance'' as appropriate}

\todo{Following the terminology of...}  Given a schema $\schema$, we use
$\sschema$ to denote the extension of $\schema$ obtained by adding a
column to each relation schema in $\schema$ and adding an additional
relation schema to $\schema$.  The additional column is the {\em location
  specifier}, which gives the ``location'' of the tuple.  By convention, this is
represented as the first column.  The additional relation schema is \dedalus{node}, a
unary relation that represents all ``locations.''  We call $\sschema$ a
{\em spatial} schema.

\todo{``a'' vs ``the'' spatial schema}

Given a spatial schema $\sschema$, we use $\stschema$ to denote the
extension of $\sschema$ obtained by adding a column to each relation schema
in $\sschema$ and adding two additional relation schemas.  The additional
column is the {\em timestamp}, a natural number representing a logical time.  By
convention, the location specifier is the first column and the timestamp is the
second.  The additional relation schemas we add are: \dedalus{time}, a unary
relation equivalent to $\mathbb{N}$, and \dedalus{succ}, a binary relation
representing the natural successor relation over $\mathbb{N}$.  We call
$\stschema$ a {\em spatio-temporal} schema.

Given a spatio-temporal schema $\stschema$, there is a unique corresponding spatial schema that corresponds with dropping the additional relations, and the additional column from each relation schema.

A {\em spatial fact} over a relation schema of arity $n$ is a pair consisting of the relation name and an $n+1$ tuple $(l,c_1,\ldots,c_n)$ where each $c_i \in \univ$, $l \in \dedalus{node}$.

A {\em spatio-temporal fact} over a relation schema of arity $n$ is a pair consisting of the relation name and an $n+2$ tuple $(l,t,c_1,\ldots,c_n)$ where each $c_i \in \univ$, $l \in \dedalus{node}$, and $t = 0$ (all spatio-temporal facts must be supplied with timestamp 0).

A {\em spatio-temporal rule} over a spatio-temporal schema $\stschema$ is a rule of one of the following three forms:

\todo{ensure sugaring diction reflects that we have a node(L) and time(T) in the body of all rules!}
\todo{ensure that it's clear that asynchronous rules can also be local}

A {\em deductive} rule:

\begin{Dedalus}
p(L,T,\od{X\sub{0}}) <- b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}),
!c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T).
\end{Dedalus}

An {\em inductive} rule:

\begin{Dedalus}
p(L,S,\od{X\sub{0}}) <- b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}),
!c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T), succ(T,S).
\end{Dedalus}

%An {\em asynchronous local} rule:
%
%\begin{Dedalus}
%p(L,S,\od{X\sub{0}}) <- b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}),
%!c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T), time(S),
%T < S, choice((L, T, \od{B}),(S)).
%\end{Dedalus}

An {\em asynchronous} rule:

\begin{Dedalus}
p(D,S,\od{X\sub{0}}) <- b\sub{1}(L,T,\od{X\sub{1}}), \ldots, b\sub{n}(L,T,\od{X\sub{n}}),
!c\sub{1}(L,T,\od{Y\sub{1}}), \ldots, !c\sub{m}(L,T,\od{Y\sub{m}}), node(L), time(T), time(S),
T < S, choice((L, T, \od{B}),(S)), node(D).
\end{Dedalus}

\wrm{The latter two kinds of rules are referred to as asynchronous rules.}

where all symbols are as defined before, \od{B} is a list of all of the distinct variable symbols in \od{X\sub{1}}, \ldots, \od{X\sub{n}}, \od{Y\sub{1}}, \ldots, \od{Y\sub{m}}; \dedalus{D} and \dedalus{L} are variable symbols that may also appear in \od{B}, \dedalus{T} and \dedalus{S} are variable symbols that may not appear in \od{B}, and \dedalus{choice} is the construct of Sacc\`{a} and Zaniolo~\cite{sacca-zaniolo}, which we will presently describe.

A \lang\ {\em program} is a set of spatio-temporal rules over some spatio-temporal schema $\stschema$.  Note that a given set of rules over a schema may give rise to many different \lang programs, depending on which type of spatio-temporal rule each rule is converted into, and depending on where or if the variable \dedalus{D} appears in the body in asynchronous communication rules. \paa{this confused me.  you are saying that the mapping from a 'plain old datalog' program to a dedalus program isn't 1-1?  this is obvious, right?  if this isn't what is intended, how do "rules" "give rise to" "dedalus programs"?}

A \lang\ {\em instance} is a program with a set of spatio-temporal facts specified for EDB relations.

\noindent
\textbf{Syntactic sugar for space-time in \lang:}
The restrictions on temporal and location attributes suggest a natural syntactic sugar to improve readability.  Given the unification requirements for location and temporal attributes in rule bodies, we can omit these attributes from predicates without risk of ambiguity.  

The three temporal classes of rules listed above can be distinguished by annotating inductive head predicates with \dedalus{@next}, and asynchronous head predicates with \dedalus{@async}; simple deductive rules have no head annotation. 
Communication rules must include the location attribute of their head predicate; by definition this is a different variable than that of the body predicates.
 Given these conventions, the presence of appropriate \dedalus{successor}, \dedalus{choice} and \dedalus{node} predicates in the body are implicit and can be omitted.  The result is a syntax that reads like a simple temporal variant of Datalog.

Deductive:

\begin{Dedalus}
p(\od{X\sub{0}}) <- b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}),
!c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}}).
\end{Dedalus}

Inductive:

\begin{Dedalus}
p(\od{X\sub{0}})@next <- b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}),   
!c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}}).
\end{Dedalus}

%Asynchronous local:
%
%\begin{Dedalus}
%p(\od{X\sub{0}})@async <- b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}),
%!c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}}).
%\end{Dedalus}

Asynchronous:

\begin{Dedalus}
p(#D,\od{X\sub{0}})@async <- b\sub{1}(\od{X\sub{1}}), \ldots, b\sub{n}(\od{X\sub{n}}),
!c\sub{1}(\od{Y\sub{1}}), \ldots, !c\sub{m}(\od{Y\sub{m}}).
\end{Dedalus}

\todo{integrate this better:}

Spatial entanglement involves making the location specifiers in the body explicit.  A rule with spatial entanglement may be of any of the varieties above.  As an example, here is an asynchronous rule with spatial entanglement:

\begin{Dedalus}
p(#D,\od{X\sub{0}})@async <- b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{X\sub{n}}),
!c\sub{1}(#L,\od{Y\sub{1}}), \ldots, !c\sub{m}(#L,\od{Y\sub{m}}).
\end{Dedalus}




\subsection{Semantics}
One interpretation of a \lang instance is given by the possible worlds of the
stable model semantics~\cite{stable-model}.  We do not review the stable model
semantics here -- the only salient detail is the interaction of \dedalus{choice}
with the stable model semantics.  \dedalus{choice} induces a separate stable
model for each possible sequence of choices \paa{sequence of?} of timestamps.  Note that without
\dedalus{choice} -- i.e., without any asynchronous rules -- a \lang program has a unique stable model, because it is
locally stratified. \paa{cite dedalus paper?}

There are two potential problems with considering a stable model as the meaning of a \lang instance.  
%%First, every program with at least one asynchronous rule has infinitely many stable models.  
First, any program with even one asynchronous rule has infinitely many stable models.  
Not all of these stable models may be meaningfully different.  Second, a stable model of a \lang program may itself be infinite.  We address both concerns in our definition of an {\em ultimate model}.

\paa{looks like we still need to define this.  perhaps we should define it exactly as we did in the other paper -- the UM is exactly the set of facts with trivial periodicities; the set of things eventually always true.  dedalus-c restricts the definition: the 
UM is the set of output tuples that is eventually always true, and since these are simply peristed this reduces to the set of tuples that are ever true.  
the burden is now on the programmer and coordination protocol to ensure that nothing goes into the output predicates until it is surely true.}

\begin{example}
\label{ex:flipflop}
A \lang program with an infinite stable model.

\begin{Dedalus}
flipflop(Y,X)@next \(\leftarrow\) flipflop(X,Y);
flipflop(1,2)@1;
\end{Dedalus}

\dedalus{flipflop(1,2)} is true at all odd times, and \dedalus{flipflop(2,1)} is true at all even times.  Thus, \dedalus{flipflop(1,2)} and \dedalus{flipflop(2,1)} are each cyclic with period 2.
\end{example}

An {\em output schema} for a \lang program $P$ with spatio-temporal schema $\stschema$ is a subset of $\sschema$.  We denote the output schema as $\oschema$.

An {\em ultimate model} of a \lang program $P$ with spatio-temporal schema $\stschema$ is the contents of the relations in $\oschema$ \wrm{that are eventually always true...} \todo{copy/paste definition from PODS2011 submission}

Note that some nontrivial programs may have an empty ultimate model, such as the program in Example~\ref{ex:flipflop}.  Further, a \lang program may have multiple ultimate models.  We give two such examples:

\begin{example}
\label{ex:diffluent1}
A diffluent \lang program.

\begin{Dedalus}
output p.
q()@async <- q_edb();
r()@async <- r_edb();
p() <- q(), !r();
q()@next <- q();
r()@next <- r();
\end{Dedalus}

Assume an EDB of \dedalus{q\_edb(), r\_edb()}.  Any stable model where \dedalus{q()} has a lower timestamp than \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.  \wrm{The problem here is negation}.
\end{example}

\begin{example}
\label{ex:diffluent2}
A diffluent \lang program.

\begin{Dedalus}
output p.
q()@async <- q_edb();
r()@async <- r_edb();
p() <- q(), r();
q()@next <- q();
\end{Dedalus}

As before, assume an EDB of \dedalus{q\_edb(), r\_edb()}.  Any stable model where the timestamp of \dedalus{q()} is less than or equal to the timestamp of \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.
\end{example}

\subsection{Operational Interpretation}
\label{sec:operational}

Our goal in defining an operational formalism is to demonstrate that our model-theoretic view of distributed systems corresponds to the real-world behaviors of such systems.

\wrm{describe what kind of system this models, how it would be executed}
\wrm{describe failure model -- all messages eventually delivered}
