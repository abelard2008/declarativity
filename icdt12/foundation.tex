\section{\large \bf \lang}
\label{sec:foundation}

\subsection{Preliminary Definitions}

\todo{define head and body of rule}
\todo{say something about the partitioning or accessibility of the order}
\todo{make sure it's clear that $\mathcal{U}$ includes \dedalus{node} but not \dedalus{time}}
\todo{make sure usage of ``relation'' vs ``relation schema'' is consistent}

We assume an infinite universe $\mathcal{U}$.

A {\em relation schema} is a pair consisting of a relation name and its arity.
A {\em schema} $\mathcal{S}$ is a set of relation schemas.  \nrc{Confusing:
  relation schema is a singleton, but ``schema'' is a set of relation schemas?} As in \wrm{cite Immerman}, we assume the existence of an order.  Thus, all schemas contain the following relational schemas: \dedalus{lt} -- a relation of arity two that is true whenever the second argument is greater than the first (we will write this relation in infix form using the \dedalus{<} symbol) -- \dedalus{suc} -- a relation of arity two that defines a total order over $\mathcal{U}$ \wrm{different from succ}.

A {\em rule} over a schema $\mathcal{S}$ is a clause of the form:

\begin{Dedalus}
p(\(\overline{\dedalus{X}\sb{0}}\)) <- b\(\sb{1}\)({\(\overline{\dedalus{X}\sb{1}}\)}), \ldots, b\(\sb{n}\)(\(\overline{\dedalus{X}\sb{n}}\)),
!c\(\sb{1}\)(\(\overline{\dedalus{Y}\sb{1}}\)), \ldots, !c\(\sb{m}\)(\(\overline{\dedalus{Y}\sb{m}}\)).
\end{Dedalus}

where \dedalus{p}, \dedalus{\(\dedalus{b}_1\), \ldots, \(\dedalus{b}_n\)},
\dedalus{\(\dedalus{c}_1\), \ldots, \(\dedalus{c}_m\)} are relations in
$\mathcal{S}$, and $\overline{\dedalus{X}_i}$ and $\overline{\dedalus{Y}_j}$
denote a tuple (of the appropriate arity) consisting of variable symbols or
constants from $\mathcal{U}$.  Note that we maintain the usual safety
restrictions of Datalog rules: any variable symbol \dedalus{V} that appears in
$\overline{\dedalus{Y}_i}$ for some $1 \leq i \leq m$ must also appear in
$\overline{\dedalus{X}_j}$ for some $1 \leq j \leq n$, but only if \dedalus{V}
appears in $\overline{\dedalus{X}_0}$ or \dedalus{V} appears in
$\overline{\dedalus{Y}_k}$ for some $k \neq i$ -- i.e., variable symbols that
only appear in a single negated atom and do not appear in the head need not also
appear in a positive atom \wrm{cite ullman}.

\wrm{describe recursion, rule out recursion through negation, define EDB}

A {\em fact} over a relation schema of arity $n$ is a pair consisting of the
relation name and an $n$-tuple $(c_1,\ldots,c_n)$, where each $c_i \in
\mathcal{U}$.  An \emph{instance} $\mathcal{I}$ over a schema $\mathcal{S}$ is a
set of facts.

\todo{Following the terminology of...}  Given a schema $\mathcal{S}$, we use
$\mathcal{S}^+$ to denote the extension of $\mathcal{S}$ obtained by adding a
column to each relation schema in $\mathcal{S}$ and adding an additional
relation schema to $\mathcal{S}$.  The additional column is the {\em location
  specifier}, which gives the ``location'' of the tuple.  By convention, this is
represented as the first column.  The additional relation schema is \dedalus{node}, a
unary relation that represents all ``locations.''  We call $\mathcal{S}^+$ a
{\em spatial} schema.

Given a spatial schema $\mathcal{S}^+$, we use $\mathcal{S}^*$ to denote the
extension of $\mathcal{S}^+$ obtained by adding a column to each relation schema
in $\mathcal{S}^+$ and adding two additional relation schemas.  The additional
column is the {\em timestamp}, a natural number representing a logical time.  By
convention, the location specifier is the first column and the timestamp is the
second.  The additional relation schemas we add are: \dedalus{time}, a unary
relation equivalent to $\mathbb{N}$, and \dedalus{succ}, a binary relation
representing the natural successor relation over $\mathbb{N}$.  We call
$\mathcal{S}^*$ a {\em spatio-temporal} schema.

Given a spatio-temporal schema $\mathcal{S}^*$, there is a unique corresponding spatial schema that corresponds with dropping the additional relations, and the additional column from each relation schema.

A {\em spatial fact} over a relation schema of arity $n$ is a pair consisting of the relation name and an $n+1$ tuple $(l,c_1,\ldots,c_n)$ where each $c_i \in \mathcal{U}$, $l \in \dedalus{node}$.

A {\em spatio-temporal fact} over a relation schema of arity $n$ is a pair consisting of the relation name and an $n+2$ tuple $(l,t,c_1,\ldots,c_n)$ where each $c_i \in \mathcal{U}$, $l \in \dedalus{node}$, and $t = 0$ (all spatio-temporal facts must be supplied with timestamp 0).

A {\em spatio-temporal rule} over a spatio-temporal schema $\mathcal{S}^*$ is a rule of one of the following three forms:

\wrm{put node(L) and time(T) in the body of all rules!}

A {\em deductive} rule:

\begin{Dedalus}
p(L,T,\(\overline{\dedalus{X}\sb{0}}\)) <- b\(\sb{1}\)(L,T,\(\overline{\dedalus{X}\sb{1}}\)), \ldots, b\(\sb{n}\)(L,T,\(\overline{\dedalus{X}\sb{n}}\)),
!c\(\sb{1}\)(L,T,\(\overline{\dedalus{Y}\sb{1}}\)), \ldots, !c\(\sb{m}\)(L,T,\(\overline{\dedalus{Y}\sb{m}}\)).
\end{Dedalus}

An {\em inductive} rule:

\begin{Dedalus}
p(L,S,\(\overline{\dedalus{X}\sb{0}}\)) <- b\(\sb{1}\)(L,T,\(\overline{\dedalus{X}\sb{1}}\)), \ldots, b\(\sb{n}\)(L,T,\(\overline{\dedalus{X}\sb{n}}\)),
!c\(\sb{1}\)(L,T,\(\overline{\dedalus{Y}\sb{1}}\)), \ldots, !c\(\sb{m}\)(L,T,\(\overline{\dedalus{Y}\sb{m}}\)), succ(T,S).
\end{Dedalus}

An {\em asynchronous local} rule:

\begin{Dedalus}
p(L,S,\(\overline{\dedalus{X}\sb{0}}\)) <- b\(\sb{1}\)(L,T,\(\overline{\dedalus{X}\sb{1}}\)), \ldots, b\(\sb{n}\)(L,T,\(\overline{\dedalus{X}\sb{n}}\)),
!c\(\sb{1}\)(L,T,\(\overline{\dedalus{Y}\sb{1}}\)), \ldots, !c\(\sb{m}\)(L,T,\(\overline{\dedalus{Y}\sb{m}}\)), time(S),
T < S, choice((L, T, \(\overline{\dedalus{B}}\)),(S)).
\end{Dedalus}

An {\em asynchronous communication} rule:

\begin{Dedalus}
p(D,S,\(\overline{\dedalus{X}\sb{0}}\)) <- b\(\sb{1}\)(L,T,\(\overline{\dedalus{X}\sb{1}}\)), \ldots, b\(\sb{n}\)(L,T,\(\overline{\dedalus{X}\sb{n}}\)),
!c\(\sb{1}\)(L,T,\(\overline{\dedalus{Y}\sb{1}}\)), \ldots, !c\(\sb{m}\)(L,T,\(\overline{\dedalus{Y}\sb{m}}\)), time(S),
T < S, choice((L, T, \(\overline{\dedalus{B}}\)),(S)), node(D).
\end{Dedalus}

\wrm{The latter two kinds of rules are referred to as asynchronous rules.}

where all symbols are as defined before, $\overline{\dedalus{B}}$ is a list of all of the distinct variable symbols in $\overline{\dedalus{X}_1}, \ldots, \overline{\dedalus{X}_n}, \overline{\dedalus{Y}_1}, \ldots, \overline{\dedalus{Y}_m}$; \dedalus{D} and \dedalus{L} are variable symbols that may also appear in $\overline{\dedalus{B}}$, \dedalus{T} and \dedalus{S} are variable symbols that may not appear in $\overline{\dedalus{B}}$, and \dedalus{choice} is the construct of Sacc\`{a} and Zaniolo~\cite{sacca-zaniolo}, which we will presently describe.

A \lang\ {\em program} is a set of spatio-temporal rules over some spatio-temporal schema $\mathcal{S}^*$.  Note that a given set of rules over a schema may give rise to many different \lang programs, depending on which type of spatio-temporal rule each rule is converted into, and depending on where or if the variable \dedalus{D} appears in the body in asynchronous communication rules. \paa{this confused me.  you are saying that the mapping from a 'plain old datalog' program to a dedalus program isn't 1-1?  this is obvious, right?  if this isn't what is intended, how do "rules" "give rise to" "dedalus programs"?}

A \lang\ {\em instance} is a program with a set of spatio-temporal facts specified for EDB relations.

\noindent
\textbf{Syntactic sugar for space-time in \lang:}
The restrictions on temporal and location attributes suggest a natural syntactic sugar to improve readability.  Given the unification requirements for location and temporal attributes in rule bodies, we can omit these attributes from predicates without risk of ambiguity.  

The three temporal classes of rules listed above can be distinguished by annotating inductive head predicates with \dedalus{@next}, and asynchronous head predicates with \dedalus{@async}; simple deductive rules have no head annotation. 
Communication rules must include the location attribute of their head predicate; by definition this is a different variable than that of the body predicates.
 Given these conventions, the presence of appropriate \dedalus{successor}, \dedalus{choice} and \dedalus{node} predicates in the body are implicit and can be omitted.  The result is a syntax that reads like a simple temporal variant of Datalog.

Deductive:

\begin{Dedalus}
p(\(\overline{\dedalus{X}\sb{0}}\)) <- b\(\sb{1}\)(\(\overline{\dedalus{X}\sb{1}}\)), \ldots, b\(\sb{n}\)(\(\overline{\dedalus{X}\sb{n}}\)),
!c\(\sb{1}\)(\(\overline{\dedalus{Y}\sb{1}}\)), \ldots, !c\(\sb{m}\)(\(\overline{\dedalus{Y}\sb{m}}\)).
\end{Dedalus}

Inductive:

\begin{Dedalus}
p(\(\overline{\dedalus{X}\sb{0}}\))@next <- b\(\sb{1}\)(\(\overline{\dedalus{X}\sb{1}}\)), \ldots, b\(\sb{n}\)(\(\overline{\dedalus{X}\sb{n}}\)),
!c\(\sb{1}\)(\(\overline{\dedalus{Y}\sb{1}}\)), \ldots, !c\(\sb{m}\)(\(\overline{\dedalus{Y}\sb{m}}\)).
\end{Dedalus}

Asynchronous local:

\begin{Dedalus}
p(\(\overline{\dedalus{X}\sb{0}}\))@async <- b\(\sb{1}\)(\(\overline{\dedalus{X}\sb{1}}\)), \ldots, b\(\sb{n}\)(\(\overline{\dedalus{X}\sb{n}}\)),
!c\(\sb{1}\)(\(\overline{\dedalus{Y}\sb{1}}\)), \ldots, !c\(\sb{m}\)(\(\overline{\dedalus{Y}\sb{m}}\)).
\end{Dedalus}

Asynchronous communication:

\begin{Dedalus}
p(#D,\(\overline{\dedalus{X}\sb{0}}\))@async <- b\(\sb{1}\)(#L,\(\overline{\dedalus{X}\sb{1}}\)), \ldots, b\(\sb{n}\)(#L,\(\overline{\dedalus{X}\sb{n}}\)),
!c\(\sb{1}\)(#L,\(\overline{\dedalus{Y}\sb{1}}\)), \ldots, !c\(\sb{m}\)(#L,\(\overline{\dedalus{Y}\sb{m}}\)).
\end{Dedalus}

Asynchronous communication rules require the body location specifier to be explicit, because it may be unified with other body attributes.





\subsection{Semantics}
One interpretation of a \lang instance is given by the possible worlds of the
stable model semantics~\cite{stable-model}.  We do not review the stable model
semantics here -- the only salient detail is the interaction of \dedalus{choice}
with the stable model semantics.  \dedalus{choice} induces a separate stable
model for each possible sequence of choices \paa{sequence of?} of timestamps.  Note that without
\dedalus{choice} -- i.e., without any asynchronous local or asynchronous
communication rules -- a \lang program has a unique stable model, because it is
locally stratified. \paa{cite dedalus paper?}

There are two potential problems with considering a stable model as the meaning of a \lang instance.  
%%First, every program with at least one asynchronous rule has infinitely many stable models.  
First, any program with even one asynchronous rule has infinitely many stable models.  
Not all of these stable models may be meaningfully different.  Second, a stable model of a \lang program may itself be infinite.  We address both concerns in our definition of an {\em ultimate model}.

\paa{looks like we still need to define this.  perhaps we should define it exactly as we did in the other paper -- the UM is exactly the set of facts with trivial periodicities; the set of things eventually always true.  dedalus-c restricts the definition: the 
UM is the set of output tuples that is eventually always true, and since these are simply peristed this reduces to the set of tuples that are ever true.  
the burden is now on the programmer and coordination protocol to ensure that nothing goes into the output predicates until it is surely true.}

\begin{example}
\label{ex:flipflop}
A \lang program with an infinite stable model.

\begin{Dedalus}
flipflop(Y,X)@next \(\leftarrow\) flipflop(X,Y);
flipflop(1,2)@1;
\end{Dedalus}

\dedalus{flipflop(1,2)} is true at all odd times, and \dedalus{flipflop(2,1)} is true at all even times.  Thus, \dedalus{flipflop(1,2)} and \dedalus{flipflop(2,1)} are each cyclic with period 2.
\end{example}


\subsection{Termination}

\wrm{There are two cases: (1) Predicate is computed immediately upon receipt of all messages; (2) some time is taken (async or @next recursion).  Maybe just expose the former case here, and latter case goes in the appendix?}

The {\em predicate dependency graph} (PDG)~\cite{ullmanbook} of a \lang program is a directed graph with one node per relation -- each node's label is a singleton set representing a different relation.  There is an edge from the node with label $\{\dedalus{q}\}$ to the node with label $\{\dedalus{p}\}$ if relation \dedalus{p} appears in the head of a rule with \dedalus{q} in its body.  If \dedalus{q} is negated, the edge is said to be negated.  The PDG does not contain any nodes or edges involving the \dedalus{time} or \dedalus{successor} relations, or \dedalus{choice}.

A {\em collapsed PDG} of a \lang program is the graph obtained by replacing each strongly connected component of the program's PDG with a single node whose label comprises the set of all relation names from the component.  Each collapsed node is called a {\em recursive} node.  Each collapsed node whose label contains a member of the program's output schema is called an {\em output} node.  A collapsed PDG is acyclic.  Let the nodes are numbered $1,\ldots,n$.

\todo{make more formal}
We will compute 0-ary relations \dedalus{\(\dedalus{done}\sb{1}\)()}, \ldots, \dedalus{\(\dedalus{done}\sb{n}\)()}, one for each node in the collapsed PDG.  Without loss of generality, let the output nodes be $1,\ldots,k$; we add the rule: \dedalus{done() <- \(\dedalus{done}\sb{1}\)(), \ldots, \(\dedalus{done}\sb{k}\)().}.

For ease of exposition, we will first show a simple protocol that can compute \dedalus{\(\dedalus{done}\sb{i}\)()} for non-recursive nodes $i$.  There is a generalized protocol that can compute \dedalus{\(\dedalus{done}\sb{i}\)()} for all nodes $i$.

\wrm{Note that \dedalus{done} is never true for some programs; these programs have no ultimate model.  This is another problem solved by \slang.}

%Given a relation \dedalus{p}, the set of relations that \dedalus{p} depends on is the union of the labels of all edges to \dedalus{p}.

%A program has terminated when the \dedalus{done()} relation is nonempty.  We define \dedalus{done()} relations for each node in the collapsed PDG.  Intuitively, a \dedalus{done()} relation is true when all of the relations in that node's label are ``at fixpoint'', and there are no ``unacknowledged'' messages in relations in that node's label.

%\wrm{Rewrite all asyncs to acknowledge}
%\wrm{}




An {\em output schema} for a \lang program $P$ with spatio-temporal schema $\mathcal{S}^*$ is a subset of $\mathcal{S}^+$.  An ultimate model of a \lang program $P$ is a set of spatial facts in relations 

\wrm{explain the ultimate model in terms of defining an output schema, and everything that is ever asserted into that output schema is part of the output; output is finalized when 0-ary predicate done() is true; user-defined}.

\subsection{Operational Interpretation}
\label{sec:operational}

Our goal in defining an operational formalism is to demonstrate that our model-theoretic view of distributed systems corresponds to the real-world behaviors of such systems.

\wrm{describe what kind of system this models, how it would be executed}
\wrm{describe failure model -- all messages eventually delivered}
