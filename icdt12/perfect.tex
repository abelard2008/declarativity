\subsection{Perfect Ultimate Model}

\todo{Put in running example here.}

\paa{we need some transition text here.  dedalus-c is nice, but as we remember from datalog ;) IDB negation makes it easier to write programs (should be easy to give an example).  can we get some IDB negation back
without sacrificing what's we've gained going to dedalus-c?}

Returning to our running examples, it is easy to see that neither program is directly expressible in \slang.  The marriage program
from Example~\ref{ex:marriage} uses IDB negation to determine the truth value of \dedalus{runaway}.
%%, and the garbage collection program
%%from Example~\ref{ex:gc} negates the recursively-defined IDB predicate \dedalus{reach} to define \dedalus{unreach}.  
We may, however, rewrite the program to
``push down'' negation to the EDB relations \dedalus{groom_i_do} and \dedalus{bride_i_do}, and then derive the \dedalus{runaway}
IDB predicate positively as shown in Example~\ref{ex:marriage2}
%~\footnote{Note that because the predicates are 0-ary (i.e., propositional), the first two rules obey our safety restrictions, in spite of the fact that they have a single negated subgoal.}.
% commenting this out because there's no reason to believe, based on our presentation of range restriction, that this would be a problem.  we say it like ``any variable that appears in a negated subgoal...''
While the rewrite is straightforward, a majority of the program statements need to be modified.

\begin{example}
\label{ex:marriage2}
An asynchronous marriage ceremony with no IDB negation:

\begin{Drules}
  \drule{groom_i_dont()@async}
        {!groom_i_do_edb()}
  \drule{bride_i_dont()@async}
        {!bride_i_do_edb()}
  \drule{runaway()}        {groom_i_dont()}
  \drule{runaway()}        {groom_i_dont()}
  \drule{groom_i_dont()@next}
        {groom_i_dont()}
  \drule{bride_i_dont()@next}
        {bride_i_dont()}
  \drule{runaway()@next}
        {runaway()}
\end{Drules}
\end{example}

The garbage collection program from Example~\ref{ex:gc} is likewise outside \slang due to IDB negation, but it presents a slightly more difficult problem, as negation must be pushed down through recursion.  The rules for positively computing the negation of a transitive closure are not particularly intuitive, and expressing the negation of an arbitrary recursive computation is even more difficult~\cite{immerman-ptime}.  Furthermore, the best known strategies involve a blowup in the arity of the relations.
%Because of the negation of a transitive closure computation in the rule defining \dedalus{unreach},
%``pushing down'' the negation to EDB would entail moving the negation sign into the recursion. \paa{cite something}.
%It is not immediately obvious how to do this in a way that preserves the intended semantics of the program.
In general, the restriction of negation to EDB predicates presents a significant barrier to expressing practical programs.

\paa{do we now introduce a third language?}
\wrm{yes}

There is a usage of negation that is both intuitive and corresponds to distributed systems practices.  Negation is not applied until the negated relation is ``done'' being computed.  Formally, if a rule body in program $P$ contains a negated atom \dedalus{!p()}, the rule body must also contain an atom \dedalus{p_done()}.  The relation \dedalus{p_done()} has the property that in any stable model $\mathcal{S}$ if $\dedalus{done_p(l,t)} \in \mathcal{S}$,  then $\dedalus{done_p(l,s)} \in \mathcal{S}$ for all timestamps $\dedalus{s} > \dedalus{t}$.  Furthermore, if $\dedalus{done_p(l,t)} \in \mathcal{S}$, then $\dedalus{p(l,t,c\sub{1},\ldots,c\sub{n})} \in \mathcal{S}$ implies that $\dedalus{p(l,s,c\sub{1},\ldots,c\sub{n})} \in \mathcal{S}$ for all timestamps $\dedalus{s} > \dedalus{t}$.  Intuitively, \dedalus{p_done()} is true when the contents of \dedalus{p} is {\em sealed} (henceforth unchanging).

We will explain how to define \dedalus{p_done()} after introducing some preliminary definitions.

A {\em collapsed PDG} of $P$ is the graph obtained by replacing each strongly
connected component of the PDG of $P$ with a single node whose label comprises
the set of all relation names from the component.  If a strongly connected
component has any asynchronous edges, we call the resulting collapsed node {\em
  async recursive}.  If a strongly connected component has inductive edges but
no asynchronous edges, we call the resulting collapsed node {\em inductive
  recursive}.  These two types of nodes are collectively referred to as {\em
  temporally recursive}.  Each node in the collapsed PDG whose label contains a
relation name in $\oschema$ is called an {\em output} node.  Note that a
collapsed PDG is acyclic.

For EDB relations \dedalus{p}, $P$ must contain the rule \dedalus{p_done()}.  For
IDB relations, defining \dedalus{p_done()} takes some work.  A rule defining
\dedalus{p_done()} for IDB relation \dedalus{p} may use \dedalus{q_done()} in
its body only if there is an edge in the collapsed PDG from a node $i$ with
$\dedalus{p} \in L(i)$ to a node $j$ with $\dedalus{q} \in L(j)$.

For ease of exposition, we will first present the computation of \dedalus{p_done()} for \dedalus{p} in non-temporally-recursive nodes.  We will then explain how to support temporally recursive nodes.

\subsubsection{Non-Temporally-Recursive Nodes}

For each non-temporally-recursive node $i$, note that $L(i)$ is a set consisting
of a single relation \dedalus{p}.  Assume the rules in $P$ with head relation
\dedalus{p} are numbered $1, \ldots, i_p$.  The rule for \dedalus{p_done()}
is:
%\nrc{why p\_done()() on the LHS?}
%removed the extra parenthesis, is this what you were objecting to?

\begin{Drules}
  \drule{p_done()}
        {r\sub{1}_done(), \ldots, r\sub{i\sb{p}}_done()}
\end{Drules}

Let the nodes in the collapsed PDG connected via incoming edges to node $i$ be denoted by $E(i)$.  Let the relations $\bigcup_{k \in E(i)} L(k)$ be named $\dedalus{p}_1, \ldots, \dedalus{p}_{i_q}$.

For each rule $1 \leq j \leq i_p$ in $P$ with head relation \dedalus{p}, if $j$ is:

\noindent
\textbf{Atemporal:}
Add the rule:

\begin{Drules}
  \drule{r\sub{j}_done()}
        {p\sub{1}_done(), \ldots, p\sub{i\sb{q}}_done()}
\end{Drules}

\noindent
\textbf{Inductive:}
Add the rule:

\begin{Drules}
  \drule{r\sub{j}_done()@next}
        {p\sub{1}_done(), \ldots, p\sub{i\sb{q}}_done()}
\end{Drules}

\noindent
\textbf{Asynchronous:}
Replace the original rule:

\begin{Drules}
  \drule{p(#N,\od{W})@async}
        {b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{X\sub{n}}), !c\sub{1}(#L,\od{Y\sub{1}}), \ldots, !c\sub{m}(#L,\od{Y\sub{m}})}
\end{Drules}

with the following set of rules:

%uq\sub{\phi}(\od{W}, \od{X}, 1) <- min(\od{X}), $\phi(\od{W}, \od{X})$.
%uq\sub{\phi}(\od{W}, \od{X}, 0) <- min(\od{X}), $!\phi(\od{W}, \od{X})$.
%uq\sub{\phi}(\od{W}, \od{Y}, 0) <- uq\sub{\phi}(\od{W}, \od{X}, 0), succ(\od{X}, \od{Y}).
%uq\sub{\phi}(\od{W}, \od{Y}, 1) <- uq\sub{\phi}(\od{W}, \od{X}, 1), succ(\od{X}, \od{Y}), $\phi(\od{W}, \od{X})$.
\begin{Drules}
\drule{p\sub{j}_to_send(N,\od{W})}
      {b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{X\sub{n}}), !c\sub{1}(#L,\od{Y\sub{1}}), \ldots, !c\sub{m}(#L,\od{Y\sub{m}})}
\drule{p\sub{j}_send(#N,L,\od{X})@async}
      {p\sub{j}_to_send(#L,N,\od{X})}
\drule{p\sub{j}_ack(#N,L,\od{X})@async}
      {p\sub{j}_send(#L,N,\od{X})}

\drule{r\sub{j}_done_node(#L,N)@async}
      {p\sub{1}_done(#N), \ldots, p\sub{i\sb{q}}_done(#N), \(\left(\forall \od{X} . \dedalus{p\sub{j}_to_send(#N,L,\od{X})} \Rightarrow \dedalus{p\sub{j}_ack(#N,L,\od{X})}\right)\)}

\drule{r\sub{j}_done()}
      {\(\left(\forall \dedalus{N} . \dedalus{node(N)} \Rightarrow \dedalus{r\sub{j}_done_node(N)}\right)\)}
\end{Drules}

The formula \dedalus{\(\forall \od{X} . \phi(\od{W},\od{X})\)} where $\phi(\od{W},\od{X})$ is of the form $\dedalus{p(\od{W},\od{X})} \Rightarrow \dedalus{q(\od{W},\od{X})}$ translates to \dedalus{forall\sub{\phi}(\od{W})}, and the following rules are added:

\begin{Drules}
\drule{p\sub{\phi}_min(\od{W},\od{X})}
      {p(\od{W},\od{X}), !p\sub{\phi}_succ(\od{W},\od{_},\od{X}), p\sub{\phi}_succ_done()}
\drule{p\sub{\phi}_max(\od{W},\od{X})}
      {p(\od{W},\od{X}), !p\sub{\phi}_succ(\od{W},\od{X},\od{_}), p\sub{\phi}_succ_done()}
\drule{p\sub{\phi}_succ(\od{W},\od{X},\od{Y})}
      {p(\od{W},\od{X}), p(\od{W},\od{Y}), !p\sub{\phi}_not_succ(\od{W},\od{X},\od{Y}), p\sub{\phi}_not_succ_done()}
\drule{p\sub{\phi}_not_succ(\od{W},\od{X},\od{Y})}
      {p(\od{W},\od{X}), p(\od{W},\od{Y}), p(\od{W},\od{Z}), \od{X} < \od{Z}, \od{Z} < \od{Y}}
\drule{p\sub{\phi}_not_succ_done()}
      {p_done()}
\drule{p\sub{\phi}_succ_done()}
      {p\sub{\phi}_not_succ_done()}
\drule{forall\sub{\phi}_ind(\od{W},\od{X})}
      {p\sub{\phi}_min(\od{W},\od{X}), q(\od{W},\od{X}).}
\drule{forall\sub{\phi}_ind(\od{W},\od{X})}
      {forall\sub{\phi}_ind(\od{W},\od{Y}), p\sub{\phi}_succ(\od{W},\od{Y},\od{X}), q(\od{W},\od{X}).}
\drule{forall\sub{\phi}(\od{W})}
      {forall\sub{\phi}_ind(\od{W},\od{X}), p\sub{\phi}_max(\od{W},\od{X})}
\drule{forall\sub{\phi}(\od{W})}
      {!p(\od{W},\od{_}), p_done()}
\end{Drules}

Note that we are abusing notation for the \dedalus{<} relation.  We previously defined \dedalus{<} as a binary relation, but it is easy to define a $2n$-ary version of \dedalus{<} that encodes a lexicographic ordering over $n$-ary relations.  Here, we use \dedalus{<} to refer to the latter.

\subsubsection{Inductive Recursive Nodes}

\todo{Figure out how this can be done in \slang; the below rules are broken.}

For each inductive recursive node $i$, assume that the relations in $L(i)$ are numbered $1,\ldots,i_p$.  For each $1 \leq j \leq i_p$, add the rules:

\begin{Drules}
\drule{p\sub{j}_prev(\od{X})@next}
      {p\sub{j}(\od{X})}
\drule{n\sub{i}_done()}
      {\(\left(\forall \od{X} . p\sub{j}(\od{X}) \Rightarrow p\sub{j}_prev(\od{X})\right)\)}
\drule{p\sub{j}_done()}
      {n\sub{i}_done()}
\end{Drules}

\subsubsection{Async Recursive Nodes}

\todo{Figure out if/how this can be done in \slang.}

\subsection{Connection with Practice}

\paa{or a discussion section, at least, in which we point out that we can run those same example programs and get an intuitive,
unambiguous semantics}

\todo{Connect stratification with coordination protocols used in practice in distributed systems.}


