\section{Perfect Ultimate Model}
\label{sec:perfect}

Returning to our running examples, it is easy to see that neither program is
directly expressible in \slang.  The marriage program from
Example~\ref{ex:marriage} uses IDB negation to determine the truth value of
\dedalus{runaway}. To avoid using IDB negation, we can rewrite the program to
``push down'' negation to the EDB relations \dedalus{groom_i_do} and
\dedalus{bride_i_do}, and then derive the \dedalus{runaway} IDB relation
positively as shown in Example~\ref{ex:marriage2}.  While the rewrite is
straightforward, a majority of the program's rules need to be modified. Note
that since Example~\ref{ex:marriage2} is written in \slang, the program must be
confluent; therefore, it is not subject to the non-deterministic output observed
for the original marriage program (Example~\ref{ex:marriage}).

\begin{example}
\label{ex:marriage2}
An asynchronous marriage ceremony without IDB negation:

\begin{Drules}
  \drule{groom_i_dont()@async}
        {!groom_i_do_edb()}
  \drule{bride_i_dont()@async}
        {!bride_i_do_edb()}
  \drule{runaway()}        {groom_i_dont()}
  \drule{runaway()}        {bride_i_dont()}
  \drule{runaway()@next}
        {runaway()}
  \drule{groom_i_dont()@next}
        {groom_i_dont()}
  \drule{bride_i_dont()@next}
        {bride_i_dont()}
\end{Drules}
\end{example}

The garbage collection program from Example~\ref{ex:gc} is likewise outside
\slang due to IDB negation but it presents a rather more difficult problem, as
negation must be pushed down through recursion.  The rules for positively
computing the negation of a transitive closure are not particularly intuitive,
and expressing the negation of an arbitrary recursive computation is even more
difficult~\cite{immerman-ptime}.  Furthermore, the best known strategies involve
at least a doubling in the arity of the relations.

In general, the restriction of negation to EDB relations presents a significant
barrier to expressing practical programs. In this section, we introduce \plang,
an extension of \slang that allows a limited form of IDB negation but retains
the benefits of \slang: \plang also captures PTIME exactly and allows only
confluent programs. First, we show how to safely allow IDB negation in \plang by
inserting a coordination protocol between nodes, ensuring that negation is used
safely. We then prove that \plang and \slang are equivalently expressive: any
\plang program can be translated into an \slang program with the same ultimate
model.

\subsection{Safe IDB Negation}
\label{sec:perfect-construction}

There is a usage of negation that is both intuitive and corresponds to distributed systems practices.  Negation is not applied until the negated relation is ``done'' being computed.  Formally, we will require that if a rule body in program $P$ contains a negated atom \dedalus{!p()}, the rule body must also contain an atom \dedalus{p_done()}. \jmh{\dedalus{p_done()} vs. \dedalus{done_p()}?  Check throughout!} The relation \dedalus{p_done()} has the property that in any stable model $\mathcal{S}$ if $\dedalus{done_p(l,t)} \in \mathcal{S}$,  then $\dedalus{done_p(l,s)} \in \mathcal{S}$ for all timestamps $\dedalus{s} > \dedalus{t}$.  Furthermore, if $\dedalus{done_p(l,t)} \in \mathcal{S}$, then $\dedalus{p(l,t,c\sub{1},\ldots,c\sub{n})} \in \mathcal{S}$ implies that $\dedalus{p(l,s,c\sub{1},\ldots,c\sub{n})} \in \mathcal{S}$ for all timestamps $\dedalus{s} > \dedalus{t}$.  Intuitively, \dedalus{p_done()} is true when the content of \dedalus{p} is {\em sealed} (henceforth unchanging).

We will present a specification of \dedalus{p_done()} after introducing some preliminary definitions.

A {\em collapsed PDG} of $P$ is the graph obtained by replacing each strongly
connected component of the PDG of $P$ with a single node whose label comprises
the set of all relation names from the component.  If a strongly connected
component has any asynchronous edges, we call the resulting collapsed node {\em
  async recursive}.  Each node in the collapsed PDG whose label contains a
relation name in $\oschema$ is called an {\em output} node.  Note that a
collapsed PDG is acyclic.

For EDB relations \dedalus{p}, $P$ must contain the rule \dedalus{p_done()} \jmh{Huh?  \dedalus{p_done()} is not a rule.  What do you mean here?}.  For
IDB relations, defining \dedalus{p_done()} takes some work.  A rule defining
\dedalus{p_done()} for IDB relation \dedalus{p} may use \dedalus{q_done()} in
its body only if there is an edge in the collapsed PDG from a node $i$ with
$\dedalus{p} \in L(i)$ to a node $j$ with $\dedalus{q} \in L(j)$.  \jmh{Now you lost me -- you seem to have dipped into a proofy discussion without the requisite setup.  Rewrite and stick to intuition/introduction.}

For ease of exposition, we will first present the computation of \dedalus{p_done()} for \dedalus{p} in non-async-recursive nodes.  We will then explain how to support async recursive nodes.  We assume that all inductive rules have been rewritten to deductive rules (Lemma~\ref{lem:no-inductive}).

\subsubsection{Non-Async-Recursive Nodes}
\label{sec:nonasyncrecursive}

\jmh{Give intuition about your strategy, and point out that it comes from a natural distributed ``protocol'' (and cite if you can.)}

Let $i$ be a non-async-recursive node.  Repeat the following for each element of $\dedalus{p} \in L(i)$.
Assume the rules in $P$ with head relation
\dedalus{p} are numbered $1, \ldots, i_p$.  The rule for \dedalus{p_done()}
is:
%\nrc{why p\_done()() on the LHS?}
%removed the extra parenthesis, is this what you were objecting to?

\begin{Drules}
  \drule{p_done()}
        {r\sub{1}_done(), \ldots, r\sub{i\sb{p}}_done()}
\end{Drules}

Let the nodes in the collapsed PDG connected via incoming edges to node $i$ be denoted by $E(i)$.  Let the relations $\bigcup_{k \in E(i)} L(k)$ be named $\dedalus{p}_1, \ldots, \dedalus{p}_{i_q}$.

For each rule $1 \leq j \leq i_p$ in $P$ with head relation \dedalus{p}, if $j$ is:

\noindent
\textbf{Deductive:}
Add the rule:

\begin{Drules}
  \drule{r\sub{j}_done()}
        {p\sub{1}_done(), \ldots, p\sub{i\sb{q}}_done()}
\end{Drules}

\noindent
\textbf{Asynchronous:}
Replace the original rule:

\begin{Drules}
  \drule{p(#N,\od{W})@async}
        {b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{X\sub{n}}), !c\sub{1}(#L,\od{Y\sub{1}}), \ldots, !c\sub{m}(#L,\od{Y\sub{m}})}
\end{Drules}

with the following set of rules:

%uq\sub{\phi}(\od{W}, \od{X}, 1) <- min(\od{X}), $\phi(\od{W}, \od{X})$.
%uq\sub{\phi}(\od{W}, \od{X}, 0) <- min(\od{X}), $!\phi(\od{W}, \od{X})$.
%uq\sub{\phi}(\od{W}, \od{Y}, 0) <- uq\sub{\phi}(\od{W}, \od{X}, 0), succ(\od{X}, \od{Y}).
%uq\sub{\phi}(\od{W}, \od{Y}, 1) <- uq\sub{\phi}(\od{W}, \od{X}, 1), succ(\od{X}, \od{Y}), $\phi(\od{W}, \od{X})$.
\begin{Drules}
\drule{p\sub{j}_to_send(N,\od{W})}
      {b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{X\sub{n}}), !c\sub{1}(#L,\od{Y\sub{1}}), \ldots, !c\sub{m}(#L,\od{Y\sub{m}})}
\drule{p\sub{j}_send(#N,L,\od{X})@async}
      {p\sub{j}_to_send(#L,N,\od{X})}
\drule{p\sub{j}_ack(#N,L,\od{X})@async}
      {p\sub{j}_send(#L,N,\od{X})}

\drule{r\sub{j}_done_node(#L,N)@async}
      {p\sub{1}_done(#N), \ldots, p\sub{i\sb{q}}_done(#N), \(\left(\forall \od{X} . \dedalus{p\sub{j}_to_send(#N,L,\od{X})} \Rightarrow \right.\) \(\left. \dedalus{p\sub{j}_ack(#N,L,\od{X})}\right)\)}

\drule{r\sub{j}_done()}
      {\(\left(\forall \dedalus{N} . \dedalus{node(N)} \Rightarrow \dedalus{r\sub{j}_done_node(N)}\right)\)}
\end{Drules}

The formula \dedalus{\(\forall \od{X} . \phi(\od{W},\od{X})\)} where $\phi(\od{W},\od{X})$ is of the form $\dedalus{p(\od{W},\od{X})} \Rightarrow \dedalus{q(\od{W},\od{X})}$ translates to \dedalus{forall\sub{\phi}(\od{W})}, and the following rules are added:

\begin{Drules}
\drule{p\sub{\phi}_min(\od{W},\od{X})}
      {p(\od{W},\od{X}), !p\sub{\phi}_succ(\od{W},\od{_},\od{X}), p\sub{\phi}_succ_done()}
\drule{p\sub{\phi}_max(\od{W},\od{X})}
      {p(\od{W},\od{X}), !p\sub{\phi}_succ(\od{W},\od{X},\od{_}), p\sub{\phi}_succ_done()}
\drule{p\sub{\phi}_succ(\od{W},\od{X},\od{Y})}
      {p(\od{W},\od{X}), p(\od{W},\od{Y}), \od{X} < \od{Y}, !p\sub{\phi}_not_succ(\od{W},\od{X},\od{Y}), p\sub{\phi}_not_succ_done()}
\drule{p\sub{\phi}_not_succ(\od{W},\od{X},\od{Y})}
      {p(\od{W},\od{X}), p(\od{W},\od{Y}), p(\od{W},\od{Z}), \od{X} < \od{Z}, \od{Z} < \od{Y}}
\drule{p\sub{\phi}_not_succ_done()}
      {p_done()}
\drule{p\sub{\phi}_succ_done()}
      {p\sub{\phi}_not_succ_done()}
\drule{forall\sub{\phi}_ind(\od{W},\od{X})}
      {p\sub{\phi}_min(\od{W},\od{X}), q(\od{W},\od{X})}
\drule{forall\sub{\phi}_ind(\od{W},\od{X})}
      {forall\sub{\phi}_ind(\od{W},\od{Y}), p\sub{\phi}_succ(\od{W},\od{Y},\od{X}), q(\od{W},\od{X})}
\drule{forall\sub{\phi}(\od{W})}
      {forall\sub{\phi}_ind(\od{W},\od{X}), p\sub{\phi}_max(\od{W},\od{X})}
\drule{forall\sub{\phi}(\od{W})}
      {!p(\od{W},\od{_}), p_done()}
\end{Drules}

The first four rules above compute a dense order over \dedalus{p\sub{phi}}, the next two rules compute completeness information used in the first four rules.  The final four rules iterate over the dense order of \dedalus{p\sub{phi}}, and checking each \dedalus{p\sub{phi}} to see if \dedalus{q} also holds.  If \dedalus{q} does not hold for any \dedalus{p}, iteration will cease.  However, if \dedalus{q} holds for all \dedalus{p} (or there are no \dedalus{p}) then \dedalus{forall\sub{\phi}} is true.

Note that we are abusing notation for the \dedalus{<} relation.  We previously defined \dedalus{<} as a binary relation, but it is easy to define a $2n$-ary version of \dedalus{<} that encodes a lexicographic ordering over $n$-ary relations.  Here, we use \dedalus{<} to refer to the latter.

\subsubsection{Async Recursive Nodes}

\todo{Mention that this is not in \plang}  \jmh{What does that suggest?  Isn't there something wrong with annotating \plang programs with non-\plang stuff in order to achieve a property you are asserting for \plang?}

Consider an async recursive node $i$.

Let the asynchronous rules with head relations in $L(i)$ be numbered $1, \ldots, i_p$.  Add the rule:

\begin{Drules}
  \drule{all_ack\sub{i}()}
        {r\sub{1}_done(), \ldots, r\sub{i\sb{p}}_done()}
\end{Drules}

For each rule $j$, perform the asynchronous rewrite from the previous section, except for the last two rules.  Instead write:

\begin{Drules}
\drule{r\sub{j}_not_done()}
      {p\sub{j}_to_send(\od{X}), !p\sub{j}_ack(\od{X})}
\drule{r\sub{j}_done()}
      {!r\sub{j}_not_done()}
\end{Drules}

We perform a two-round voting protocol amongst the nodes; the node with the minimum identifier is the master.  We assume that guarded asynchrony does not apply to the relations that appear in the head of any asynchronous rule in the following.  The following rules begin the first round of voting.  Nodes vote \dedalus{complete_1\sub{i}} if \dedalus{all_ack\sub{i}} is true -- intuitively, if they have no outstanding unacknowledged messages.  Votes are sent to the node with minimum identifier (the master).

\begin{Drules}
\drule{start_round_1\sub{i}()}
      {node_min(#L,L), !round_1\sub{i}()}
\drule{round_1\sub{i}()@next}
      {start_round_1\sub{i}()}
\drule{round_1\sub{i}()@next}
      {round_1\sub{i}(), !start_round_2\sub{i}()}
\drule{vote_1\sub{i}(#N)@async}
      {start_round_1\sub{i}(), node(N)}
\drule{complete_1\sub{i}(#M,N)@async}
      {vote_1\sub{i}(#N), all_ack\sub{i}(#N), node_min(#N,M)}
\drule{incomplete_1\sub{i}(#M,N)@async}
      {vote_1\sub{i}(#N), !all_ack\sub{i}(#N), node_min(#N,M)}
\end{Drules}

To persist votes until round 1 begins again, the following rules are instantiated for $k=1$ and $2$.

\begin{Drules}
\drule{complete_k\sub{i}(N)@next}
      {complete_k\sub{i}(N), !start_round_1\sub{i}()}
\drule{incomplete_k\sub{i}(N)@next}
      {incomplete_k\sub{i}(N), !start_round_1\sub{i}()}
\end{Drules}

To count votes, we assume the following rules are instantiated for $k=1$ and $2$.  Round 1 is restarted if some node votes \dedalus{incomplete_1\sub{i}} in round 1 -- i.e., it has an outstanding unacknowledged message -- or \dedalus{incomplete_2\sub{i}} in round 2.

\begin{Drules}
\drule{recv_k\sub{i}(N)}
      {complete_k\sub{i}(N)}
\drule{recv_k\sub{i}(N)}
      {incomplete_k\sub{i}(N)}
\drule{not_all_recv_k\sub{i}()}
      {node(N), !recv_k\sub{i}(N)}
\drule{not_all_comp_k\sub{i}()}
      {node(N), !complete_k\sub{i}(N)}
\drule{start_round_1\sub{i}()}
      {!not_all_recv_k\sub{i}(), not_all_comp_k\sub{i}()}
\end{Drules}

Once a node has received a \dedalus{vote_1\sub{i}} vote solicitation, it also begins keeping track of whether it has sent any messages in the async recursive component; this information is erased if another \dedalus{vote_1\sub{i}} solicitation is received.  The causality constraint implies that \dedalus{!all_ack\sub{i}()} is true if a message is sent, because messages cannot be instantly acknowledged.

\begin{Drules}
\drule{sent\sub{i}()}
      {!all_ack\sub{i}()}
\drule{sent\sub{i}()@next}
      {sent\sub{i}(), !vote_1\sub{i}()}
\end{Drules}

Round 2 is started by the master if no node has an outstanding message.

\begin{Drules}
\drule{start_round_2\sub{i}()}
      {!not_all_recv_1\sub{i}(), !not_all_comp_1\sub{i}()}
\end{Drules}

The voting for round 2 is shown below.  Notes vote \dedalus{incomplete_2\sub{i}} if they have sent any messages since the last \dedalus{vote_1\sub{i}} solicitation.  Recall that any \dedalus{incomplete_2\sub{i}} votes result in the protocol restarting with round 1.

\begin{Drules}
\drule{vote_2\sub{i}(#N)@async}
      {start_round_2\sub{i}(), node(N)}
\drule{complete_2\sub{i}(#M,N)@async}
      {vote_2\sub{i}(#N), all_ack\sub{i}(#N), !sent\sub{i}(#N), node_min(#N,M)}
\drule{incomplete_2\sub{i}(#M,N)@async}
      {vote_2\sub{i}(#N), sent\sub{i}(#N), node_min(#N,M)}
\end{Drules}

The entire async recursive node $i$ is done when all nodes have voted \dedalus{complete_2\sub{i}}.

\begin{Drules}
\drule{done_recursion\sub{i}()}
      {!not_all_recv_2\sub{i}(), !not_all_comp_2\sub{i}()}
\end{Drules}

For every relation $\dedalus{p} \in L(i)$, add the rule:

\begin{Drules}
\drule{p_done()}
      {done_recursion\sub{i}()}
\end{Drules}

\subsection{Properties of \plang}
\jmh{A bit of connective flow text here?}
\begin{lemma}[Sealing]
\label{lem:plang-done-right}
The relation \dedalus{p_done()} has the property that in any stable model $\mathcal{S}$ if $\dedalus{p_done(l,t)} \in \mathcal{S}$,  then $\dedalus{p_done(l,s)} \in \mathcal{S}$ for all timestamps $\dedalus{s} > \dedalus{t}$.  Furthermore, if $\dedalus{p_done(l,t)} \in \mathcal{S}$, then $\dedalus{p(l,t,c\sub{1},\ldots,c\sub{n})} \in \mathcal{S}$ implies that $\dedalus{p(l,s,c\sub{1},\ldots,c\sub{n})} \in \mathcal{S}$ for all timestamps $\dedalus{s} > \dedalus{t}$.
\end{lemma}
\begin{proof}
We assume that \dedalus{p\sub{1}_done(), \ldots, p\sub{i\sb{q}}_done()} are correct.

Clearly, \dedalus{p_done()} has the properties mentioned in the Lemma for the atemporal case.

In the asynchronous case, \dedalus{p_done()} is similarly correct; the causality constraint implies that the timestamp on acknowledgements is later than the timestamp on the facts they acknowledge, and thus the timestamp on each node's \dedalus{r\sub{j}_node_done} fact is greater than the timestamp on the acknowledged facts.  Thus, before a node concludes \dedalus{p_done()}, that node has all facts, assuming that \dedalus{p\sub{1}_done(), \ldots, p\sub{i\sb{q}}_done()} are correct.

\todo{fix up}
In the asynchronous recursive case, the causality constraint ensures that every response in the second round is received at a time greater than every response in the first round.  Thus, between at least the last response of the first round, and the last response of the second round, no node has outstanding messages, and no node sends a message.  This implies that no node ever sends a message again.
\end{proof}

\begin{lemma}
\label{lem:plang-inflationary}
\plang programs are inflationary.
\end{lemma}
\begin{proof}
Since a \dedalus{!p} atom in a rule body must appear in conjunction with a \dedalus{p_done()} atom, by Lemma~\ref{lem:plang-done-right}, all negation is applied to complete sets; the negation of a complete set yields a complete set.
\end{proof}

\todo{ensure recursion through negation is ruled out earlier...}

\jmh{A bit of intuitive text here about the appeal to ideas from stratified negation?  And perhaps connection to ``global barrier'' protocols?}

The {\em stratum} of a relation \dedalus{r} is the maximum number of negated edges on any path in the PDG from \dedalus{r} to an EDB relation.  Clearly this is finite, as \plang programs do not have recursion through negation.

Note that we can convert an $n$-stratum \plang program into $n$ \slang programs, one per stratum.  Stratum $i$'s program, $P_i$, consists of all rules whose head relation is in stratum $i$.  The output schema of $P_i$ contains all relations in stratum $i+1$, and $P_i$'s EDB contains all relations in stratum $j < i$.  $P_0$'s EDB contains all EDB relations.  $P_n$'s output schema contains all relations in $P$'s output schema.  We will show that running these programs in sequence gives the same result as $P(E)$:

\begin{lemma}
\label{lem:can-stratify}
The ultimate model of $P(E)$ is equivalent to the ultimate model of $P_n(\ldots P_1(P_0(E)) \ldots ) = Q(E)$
\end{lemma}
\begin{proof}
Note that for any fact \dedalus{p@t} in any stable model of $P_0(E)$, \dedalus{p} is in the ultimate model of $P_0(E)$ (Lemma~\ref{lem:inflationary}).

Any path from \dedalus{p} to any EDB relation in the PDG passes through no negations.  Thus, we can consider a derivation tree of \dedalus{p@t}, and use a similar argument as in Lemma~\ref{lem:inflationary} to show that \dedalus{p@s} is in any stable model of $P(E)$ for some \dedalus{s}, and thus is the ultimate model of $P(E)$ (Lemma~\ref{lem:plang-inflationary}).

We can continue this proof inductively; if the ultimate model of $P_0(E)$ is contained in the ultimate model of $P(E)$, then we apply Lemmas~\ref{lem:inflationary} and~\ref{lem:plang-inflationary} to obtain a contradiction of the ultimate model of $P_{i+1}(\ldots P_1(P_0(E)) \ldots)$ is not contained in the ultimate model of $P(E)$.  Thus, the ultimate models are equal.
\end{proof}

As corollaries of the above Lemma, we can apply several previous results, treating each stratum as a separate program with only EDB negation.

\begin{corollary}
\label{cor:plang-confluent}
\plang programs are confluent.
\end{corollary}

Note that every \slang program is a \plang program.  Thus we have:

\begin{corollary}
\label{cor:plang-ptime}
\plang programs capture exactly PTIME.
\end{corollary}

%\begin{theorem}
%\label{thm:plang-ptime}
%\plang programs capture exactly PTIME
%\end{theorem}
%\begin{proof} 
%Since \plang programs are confluent, Corollary~\ref{cor:no-async} applies.  Thus, asynch%ronous rules may be replaced with inductive rules.  We can assume these are the only ind%uctive rules in the program, by Lemma~\ref{lem:no-inductive}.  Using a proof in the styl%e of Lemma~\ref{lem:no-inductive}, considering each stratum at a time, we can also see t%hat these inductive rules can be converted into atemporal rules with no effect to the ul%timate model.  The stable model of the resulting program is unique, and is also the same% for every timestamp.

%As in Theorem~\ref{thm:ptime}, we remove the timestamp attribute from all relations, and% the \dedalus{time} relations from all rule bodies.  The result is a Datalog program wit%h stratified negation.  The perfect model of the Datalog program is exactly the ultimate% model, as the stable model semantics coincides with the perfect model semantics for str%atified programs.  It is known that for ordered structures, stratified Datalog is also e%quivalent to PTIME, due to negation pushdown results in~\cite{immerman-ptime}.

%In the other direction, it is clear that we can encode any stratified Datalog program in% \plang using atemporal rules: the ultimate model coincides wieh the perfect model of th%e Datalog program.                                                                   %\end{proof}  

\subsection{Discussion}
The garbage collection program from Example~\ref{ex:gc} can be made a legal 
\plang program by adding the following rules:

\begin{example}
Synthesized rules for the garbage collection program:

\begin{Drules}
  \drule{points_to_to_send(M,Src,Dst)}
        {local_ptr_edb(N, Src,Dst), master(M)}
  \drule{points_to_send(#M, L, Src, Dst)@async}
        {points_to_to_send(#L, M, Src, Dst)}
  \drule{points_to_ack(#N, L, Src, Dst)}
        {points_to_send(#L, N, Src, Dst)}
  \drule{points_to_done_node(#M, N)@async}
        {local_ptr_edb_done(#N), master(#N, M), (\(\forall \od{X}.points_to_to_send(#N, M, \od{X}) \Rightarrow points_to_ack(#N, M, \od{X})\)}
  \drule{points_to_done(M)}
        {\(\forall N.nodes(N) \Rightarrow points_to_done_node(M, N)\)}
  \drule{reach_done()}
        {points_to_done()}

  \drule{\(\forall\) N.nodes(N) \(\Rightarrow\) local_ptr_edb_done(N)} {}
\end{Drules}
\end{example}

One rule from the original program must also be rewritten to include the
new subgoal \dedalus{reach\_done}:

\begin{example}
Garbage collection rewrite

\begin{Drules}
  \drule{unreach(Addr)} 
        {addr_edb(Addr), root_edb(Root), !reach(Root,Addr), reach_done()}
\end{Drules}
\end{example}

As we have shown, the resulting program has a single ultimate model.  This model
corresponds exactly with one of the ultimate models of the original program from
Example~\ref{ex:gc}: the model in which \dedalus{!reach} is not evaluated until
\dedalus{reach} is fully determined.  The rewrite has effectively forced an
evaluation strategy analogous to stratum-order evaluation in a centralized
Datalog program.

Note also that the rewrite code is a generalization of the ``coordination'' code
that a \lang programmer could have written by hand to ensure that the local
relation \dedalus{points\_to} is a faithful representation of global state.  \jmh{The following feels like it should come earlier as motivation, and then be reiterated here.}
In
distributed systems, global computation barriers are commonly enforced by
protocols based on voting: the two-phase commit protocol from distributed
databases is a straightforward example~\cite{gray-tp}.  In the synthesized protocol shown above, every agent
responsible for a fragment of the global state must ``vote'' that every message
they send to the coordinator has been acknowledged.  The coordinator must tally
these votes and ensure that the vote is unanimous for all agents.  If the
protocol completes successfully, the coordinator may proceed past the barrier.

\jmh{Same with this intro sentence: seems like the ``explicit goal'' should come much earlier, and be referenced again here as a form of bragging that we hit an important yardstick.}
An explicit goal of our work with \lang has been to view general distributed
systems through a model-theoretic lens.  From this perspective, the connection
between coordination protocols that enforce barriers and stratified evaluation
of logic programs is unsurprising.  Indeed, when distributed systems are
implemented in \plang, the two strategies have exactly the same consequences
with respect to an appropriate model-theoretic semantics. \jmh{I'm not sure what the previous sentence says, since we don't have a formal notion of coordination protocols or barriers.} Both ensure that among
the multiplicity of models induced by nonmonotonic logic, program evaluation
will always select the model that corresponds to an intuitive evaluation order
in which negation (a form of universal quantification) is applied only when it
is certain that its consequences will never be retracted.



