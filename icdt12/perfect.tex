\section{Perfect Ultimate Model}
\label{sec:perfect}

Returning to our running examples, it is easy to see that neither program is
directly expressible in \slang.  The marriage program from
Example~\ref{ex:marriage} uses IDB negation to determine the truth value of
\dedalus{runaway}.  We may, however, rewrite the program to ``push down''
negation to the EDB relations \dedalus{groom_i_do} and \dedalus{bride_i_do}, and
then derive the \dedalus{runaway} IDB predicate positively as shown in
Example~\ref{ex:marriage2}.  While the rewrite is straightforward, a majority of
the program statements need to be modified. Note that since
Example~\ref{ex:marriage2} is written in \slang, the program is confluent;
therefore, it is not subject to the non-deterministic output observed for the
original marriage program (Example~\ref{ex:marriage}).

\begin{example}
\label{ex:marriage2}
An asynchronous marriage ceremony without IDB negation:

\begin{Drules}
  \drule{groom_i_dont()@async}
        {!groom_i_do_edb()}
  \drule{bride_i_dont()@async}
        {!bride_i_do_edb()}
  \drule{runaway()}        {groom_i_dont()}
  \drule{runaway()}        {bride_i_dont()}
  \drule{runaway()@next}
        {runaway()}
  \drule{groom_i_dont()@next}
        {groom_i_dont()}
  \drule{bride_i_dont()@next}
        {bride_i_dont()}
\end{Drules}
\end{example}

The garbage collection program from Example~\ref{ex:gc} is likewise outside
\slang due to IDB negation but it presents a slightly more difficult problem, as
negation must be pushed down through recursion.  The rules for positively
computing the negation of a transitive closure are not particularly intuitive,
and expressing the negation of an arbitrary recursive computation is even more
difficult~\cite{immerman-ptime}.  Furthermore, the best known strategies involve
at least a doubling in the arity of the relations.

In general, the restriction of negation to EDB predicates presents a significant
barrier to expressing practical programs. In this section, we introduce \plang,
an extension of \slang that allows a limited form of IDB negation but retains
the benefits of \slang: \plang also captures PTIME exactly and allows only
confluent programs.

\subsection{Safe IDB Negation}

There is a usage of negation that is both intuitive and corresponds to distributed systems practices.  Negation is not applied until the negated relation is ``done'' being computed.  Formally, if a rule body in program $P$ contains a negated atom \dedalus{!p()}, the rule body must also contain an atom \dedalus{p_done()}.  The relation \dedalus{p_done()} has the property that in any stable model $\mathcal{S}$ if $\dedalus{done_p(l,t)} \in \mathcal{S}$,  then $\dedalus{done_p(l,s)} \in \mathcal{S}$ for all timestamps $\dedalus{s} > \dedalus{t}$.  Furthermore, if $\dedalus{done_p(l,t)} \in \mathcal{S}$, then $\dedalus{p(l,t,c\sub{1},\ldots,c\sub{n})} \in \mathcal{S}$ implies that $\dedalus{p(l,s,c\sub{1},\ldots,c\sub{n})} \in \mathcal{S}$ for all timestamps $\dedalus{s} > \dedalus{t}$.  Intuitively, \dedalus{p_done()} is true when the contents of \dedalus{p} is {\em sealed} (henceforth unchanging).

We will explain how to define \dedalus{p_done()} after introducing some preliminary definitions.

A {\em collapsed PDG} of $P$ is the graph obtained by replacing each strongly
connected component of the PDG of $P$ with a single node whose label comprises
the set of all relation names from the component.  If a strongly connected
component has any asynchronous edges, we call the resulting collapsed node {\em
  async recursive}.  Each node in the collapsed PDG whose label contains a
relation name in $\oschema$ is called an {\em output} node.  Note that a
collapsed PDG is acyclic.

For EDB relations \dedalus{p}, $P$ must contain the rule \dedalus{p_done()}.  For
IDB relations, defining \dedalus{p_done()} takes some work.  A rule defining
\dedalus{p_done()} for IDB relation \dedalus{p} may use \dedalus{q_done()} in
its body only if there is an edge in the collapsed PDG from a node $i$ with
$\dedalus{p} \in L(i)$ to a node $j$ with $\dedalus{q} \in L(j)$.

For ease of exposition, we will first present the computation of \dedalus{p_done()} for \dedalus{p} in non-async-recursive nodes.  We will then explain how to support async recursive nodes.  We assume that all inductive rules have been rewritten to deductive rules (Lemma~\ref{lem:no-inductive}).

\subsubsection{Non-Async-Recursive Nodes}
\label{sec:nonasyncrecursive}

Let $i$ be a non-async-recursive node.  Repeat the following for each element of $\dedalus{p} \in L(i)$.
Assume the rules in $P$ with head relation
\dedalus{p} are numbered $1, \ldots, i_p$.  The rule for \dedalus{p_done()}
is:
%\nrc{why p\_done()() on the LHS?}
%removed the extra parenthesis, is this what you were objecting to?

\begin{Drules}
  \drule{p_done()}
        {r\sub{1}_done(), \ldots, r\sub{i\sb{p}}_done()}
\end{Drules}

Let the nodes in the collapsed PDG connected via incoming edges to node $i$ be denoted by $E(i)$.  Let the relations $\bigcup_{k \in E(i)} L(k)$ be named $\dedalus{p}_1, \ldots, \dedalus{p}_{i_q}$.

For each rule $1 \leq j \leq i_p$ in $P$ with head relation \dedalus{p}, if $j$ is:

\noindent
\textbf{Deductive:}
Add the rule:

\begin{Drules}
  \drule{r\sub{j}_done()}
        {p\sub{1}_done(), \ldots, p\sub{i\sb{q}}_done()}
\end{Drules}

\noindent
\textbf{Asynchronous:}
Replace the original rule:

\begin{Drules}
  \drule{p(#N,\od{W})@async}
        {b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{X\sub{n}}), !c\sub{1}(#L,\od{Y\sub{1}}), \ldots, !c\sub{m}(#L,\od{Y\sub{m}})}
\end{Drules}

with the following set of rules:

%uq\sub{\phi}(\od{W}, \od{X}, 1) <- min(\od{X}), $\phi(\od{W}, \od{X})$.
%uq\sub{\phi}(\od{W}, \od{X}, 0) <- min(\od{X}), $!\phi(\od{W}, \od{X})$.
%uq\sub{\phi}(\od{W}, \od{Y}, 0) <- uq\sub{\phi}(\od{W}, \od{X}, 0), succ(\od{X}, \od{Y}).
%uq\sub{\phi}(\od{W}, \od{Y}, 1) <- uq\sub{\phi}(\od{W}, \od{X}, 1), succ(\od{X}, \od{Y}), $\phi(\od{W}, \od{X})$.
\begin{Drules}
\drule{p\sub{j}_to_send(N,\od{W})}
      {b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{X\sub{n}}), !c\sub{1}(#L,\od{Y\sub{1}}), \ldots, !c\sub{m}(#L,\od{Y\sub{m}})}
\drule{p\sub{j}_send(#N,L,\od{X})@async}
      {p\sub{j}_to_send(#L,N,\od{X})}
\drule{p\sub{j}_ack(#N,L,\od{X})@async}
      {p\sub{j}_send(#L,N,\od{X})}

\drule{r\sub{j}_done_node(#L,N)@async}
      {p\sub{1}_done(#N), \ldots, p\sub{i\sb{q}}_done(#N), \(\left(\forall \od{X} . \dedalus{p\sub{j}_to_send(#N,L,\od{X})} \Rightarrow \right.\) \(\left. \dedalus{p\sub{j}_ack(#N,L,\od{X})}\right)\)}

\drule{r\sub{j}_done()}
      {\(\left(\forall \dedalus{N} . \dedalus{node(N)} \Rightarrow \dedalus{r\sub{j}_done_node(N)}\right)\)}
\end{Drules}

The formula \dedalus{\(\forall \od{X} . \phi(\od{W},\od{X})\)} where $\phi(\od{W},\od{X})$ is of the form $\dedalus{p(\od{W},\od{X})} \Rightarrow \dedalus{q(\od{W},\od{X})}$ translates to \dedalus{forall\sub{\phi}(\od{W})}, and the following rules are added:

\begin{Drules}
\drule{p\sub{\phi}_min(\od{W},\od{X})}
      {p(\od{W},\od{X}), !p\sub{\phi}_succ(\od{W},\od{_},\od{X}), p\sub{\phi}_succ_done()}
\drule{p\sub{\phi}_max(\od{W},\od{X})}
      {p(\od{W},\od{X}), !p\sub{\phi}_succ(\od{W},\od{X},\od{_}), p\sub{\phi}_succ_done()}
\drule{p\sub{\phi}_succ(\od{W},\od{X},\od{Y})}
      {p(\od{W},\od{X}), p(\od{W},\od{Y}), \od{X} < \od{Y}, !p\sub{\phi}_not_succ(\od{W},\od{X},\od{Y}), p\sub{\phi}_not_succ_done()}
\drule{p\sub{\phi}_not_succ(\od{W},\od{X},\od{Y})}
      {p(\od{W},\od{X}), p(\od{W},\od{Y}), p(\od{W},\od{Z}), \od{X} < \od{Z}, \od{Z} < \od{Y}}
\drule{p\sub{\phi}_not_succ_done()}
      {p_done()}
\drule{p\sub{\phi}_succ_done()}
      {p\sub{\phi}_not_succ_done()}
\drule{forall\sub{\phi}_ind(\od{W},\od{X})}
      {p\sub{\phi}_min(\od{W},\od{X}), q(\od{W},\od{X})}
\drule{forall\sub{\phi}_ind(\od{W},\od{X})}
      {forall\sub{\phi}_ind(\od{W},\od{Y}), p\sub{\phi}_succ(\od{W},\od{Y},\od{X}), q(\od{W},\od{X})}
\drule{forall\sub{\phi}(\od{W})}
      {forall\sub{\phi}_ind(\od{W},\od{X}), p\sub{\phi}_max(\od{W},\od{X})}
\drule{forall\sub{\phi}(\od{W})}
      {!p(\od{W},\od{_}), p_done()}
\end{Drules}

The first four rules above compute a dense order over \dedalus{p\sub{phi}}, the next two rules compute completeness information used in the first four rules.  The final four rules iterate over the dense order of \dedalus{p\sub{phi}}, and checking each \dedalus{p\sub{phi}} to see if \dedalus{q} also holds.  If \dedalus{q} does not hold for any \dedalus{p}, iteration will cease.  However, if \dedalus{q} holds for all \dedalus{p} (or there are no \dedalus{p}) then \dedalus{forall\sub{\phi}} is true.

Note that we are abusing notation for the \dedalus{<} relation.  We previously defined \dedalus{<} as a binary relation, but it is easy to define a $2n$-ary version of \dedalus{<} that encodes a lexicographic ordering over $n$-ary relations.  Here, we use \dedalus{<} to refer to the latter.

\subsubsection{Async Recursive Nodes}


\todo{Todo: not expresible in \plang}


\subsection{Properties of \plang}

\todo{Show that \plang programs are confluent.}\\
\todo{Show that \plang captures exactly PTIME.}


\subsection{Connection with Practice}

\paa{or a discussion section, at least, in which we point out that we can run those same example programs and get an intuitive,
unambiguous semantics}

\todo{Connect stratification with coordination protocols used in practice in distributed systems.}


