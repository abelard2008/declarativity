\section{Proof of Lemma 1}
\begin{proof}

Using the construction in~\cite{undecidable-datalog}, it is possible to write a Datalog program that encodes any two-counter machine's transition relation and an arbitrarily long finite successor relation in the EDB, and define a 0-ary output predicate \dedalus{accept} that is true if and only if the two-counter machine accepts and the transition and successor relations are valid.  As the construction is possible in Datalog, it is also possible in \lang.

We add the following rules to the construction, to nondeterministically decide whether to run the machine or not:

\begin{Drules}
  \dfact{message(0)@async}
  \dfact{message(1)@async}
  \drule{run_machine()}
        {message(0), message(1)}
  \drule{accept()}
        {message(0), !message(1), input_valid()}
  \drule{accept()}
        {!message(0), message(1), input_valid()}
\end{Drules}

Note that the first two lines are actually rules.  The unsugared form of the first rule is \dedalus{message(L,S,0) <- node(L), time(T), time(S), T < S, choice((L, T, 0), (S)).}

For valid inputs, the ultimate model is ${\dedalus{accept()}}$ if and only if either \dedalus{message(0)} and \dedalus{message(1)} are assigned the same timestamp and the machine accepts, or if the timestamps are different.  For invalid inputs, all ultimate models are empty.

If we could decide confluence for this program, we could decide whether there is any valid input for which an arbitrary two-counter machine halts in an accepting state.
\end{proof}
