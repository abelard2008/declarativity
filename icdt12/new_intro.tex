\section{Introduction}

In recent years there has been optimism that declarative languages grounded in
Datalog can provide a clean foundation for distributed
programming~\cite{declarative-imperative}.  This has led to activity in language
and system design (e.g.,~\cite{boom,Belaramani:2009,Chu:2007,Loo2009-CACM}), as well as formal
models for distributed computation using such
languages (e.g.,~\cite{relational-transducers,navarro-oper-sem,card-abstraction}).

The bulk of this work has presented (or assumed) a formal semantics based on transition systems
and traces of input events. 
\paa{plug declarativity?  this is all well and good, but I thought that programming
in a declarative language means I don't need to reason about execution to understand my program's meaning}  
In a recent (companion) paper, we developed a model-theoretic 
semantics for Dedalus, a distributed logic language based on Datalog, in which the ``meaning''
of a program precisely its set of stable models~\cite{zaniolo}~\footnote{given a set of constraints that 
model happens-before~\cite{lamport}}.  We show an equivalence between the model-theoretic semantics
and the operational semantics.

Distributed systems are difficult to reason about because of their inherent concurrency and asynchrony: multiple 
isolated processes simultaneously compute, and communicate via networks that may arbitrarily delay, reorder or batch messages.
We are required to model this nondeterminism, as it may affect the outcome of the program on different runs.  Our work on
\lang provides a model-theoretic foundation upon which to reason about the meaning of distributed programs, based on their possible 
\emph{eventual} outcomes or \emph{ultimate models}.  In this paper, we use this formal framework to develop a constrained variant
of \lang that allows only \emph{confluent} programs, or programs that have a unique ultimate model, without sacrificing its ....

The CALM theorem~\cite{calm, ameloot, imperative, ameloot} establishes a strong connection between confluence
and logical monotonicity: monotonic distributed programs are confluent.  In principle, a language that allows only
monotonic programs should be sufficiently expressive to implement the vast majority of practical distributed systems:
Immerman~\cite{??} has demonstrated that semipositive Datalog (in which negation is restricted to EDB relations) captures PTIME.  
%%We will show that confluence is undecidable for \lang programs in general, and that \lang subsumes PSPACE
\lang is perhaps ``too large'' a language for this space: we will show that it subsumes PSPACE, and that confluence is in general
undecidable for \lang programs.  This motivates us to propose a semipositive fragment of \lang we call \slang, 
for which confluence is easy to prove.

Unfortunately, unlike \lang, \slang is not a natural or convenient language for specifying systems.  Later in the paper we will give 
an example of a distributed garbage collection algorithm in which ``orphaned'' memory is intuitively specified as the negation of the transitive 
closure of a points-to relation.  The theoretical result that this program \emph{could} be specified in the semipositive fragment
of \lang is unsatisfying from a programmability perspective.  The wealth of research on stratified Datalog and the perfect model semantics
suggests ....

In a recent paper targeting the systems community, we presented \emph{Bloom}, a domain-specific language (DSL) for implementing distributed 
systems.  While its semantics are based on \lang, Bloom is intended to be a practical programming language: we have used
Bloom to build a wide array of distributed protocols and several complete
applications, including a distributed file system.
Following the intuition of stratified negation, Bloom allows negation (and various forms of aggregation) over derived relations, provided
that the program has a stratification.  If the program has no asynchrony or has only a single stratum, Bloom's static analysis flags the 
program as confluent.  If either of these conditions is false, the analysis tool identifies the asynchronously-derived relations that fall 
at stratum boundaries as ``points of order'' which must be ``sealed'' by additional logic that prevents them from changing once the effects 
of their negation have propagated to higher strata.  The specific techniques for sealing relations closely resemble coordination protocols
familiar from the distributed systems literature.

The inadequacy of \slang and the intuition behind Bloom leads us to propose a confluent language with a natural stratified semantics that we
call \plang.  To achieve a corresponding operational semantics for \plang, we reduce it to a confluent subset of Dedalus.  
That is, we present a construction in which any \plang program may be rewritten to a confluent \lang program.  The rewrite, in which nodes ``vote''
to seal strata, likewise echoes coordination protocols in widespread use.

This paper makes three principal contributions.  We begin by proposing a new model-theoretic semantics for (possibly nondeterministic) \dedalus 
programs based on the models of their \emph{eventual} outcomes.  These \emph{ultimate models} represent a finite (and unique in the case of confluent 
programs) equivalence classes among the infinite stable models of a \lang program.  We then prove the intuitive result that \slang, the semipositive fragment of \lang, only admits confluent programs.  Finally, we propose \plang, a practical distributed logic language that likewise admits only confluent programs.
We show that \plang has a natural model-theoretic semantics corresponding to the stratified semantics for Datalog programs, and an equivalent
operational semantics that echoes coordination protocols common in distributed systems.
