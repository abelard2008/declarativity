\section{Introduction}

In recent years there has been optimism that declarative languages grounded in
Datalog can provide a clean foundation for distributed
programming~\cite{declarative-imperative}.  This has led to activity in language
and system design (e.g.,~\cite{boom,Belaramani:2009,Chu:2007,Loo2009-CACM}), as well as formal
models for distributed computation using such
languages (e.g.,~\cite{relational-transducers,navarro-oper-sem,card-abstraction}).

The bulk of this work has presented (or assumed) a formal semantics for behavior based on transition systems
and traces of input events.  A model-theoretic semantics for behavior has been notably absent.
%\paa{plug declarativity?  this is all well and good, but I thought that programming
%in a declarative language means I don't need to reason about execution to understand my program's meaning}  
In a recent (companion) paper~\cite{ameloot-operational}, we developed a model-theoretic behavior
semantics for Dedalus, a distributed logic language based on Datalog, in which the ``meaning''
of of a program is precisely its set of stable models~\cite{sacca-zaniolo}. %~\footnote{given a set of constraints that model happens-before~\cite{lamport}}.
In the same paper, we show an equivalence between the model-theoretic semantics and an operational semantics for behavior based on network transducers which is familiar from the literature.

It is difficult to reason about the output of distributed systems because of their inherent concurrency and asynchrony: multiple 
isolated processes simultaneously compute, and communicate via networks that may arbitrarily delay, reorder or batch messages.
We are required to model this nondeterminism, as it may affect the outcome of the program on different runs.  Our work on
\lang gives us a model-theoretic semantics for reasoning about the outcomes of distributed programs, based on their \emph{eventual} states or \emph{ultimate models}.  In this paper, we present this formal framework, and use it to develop a constrained variant
of \lang that allows only \emph{confluent} programs, or programs that have a unique ultimate model.
%, without sacrificing its ....

The CALM theorem~\cite{cidr11, declarative-imperative, relational-transducers} establishes a connection between confluence
and logical monotonicity: monotonic distributed programs are confluent.  In principle, a language that allows only
monotonic programs should be sufficiently expressive to implement all confluent distributed systems.
%%It is unlikely that practical distributed systems will be written in languages that allow computations beyond PTIME.  
Immerman~\cite{immerman-ptime} has demonstrated that semipositive Datalog (Datalog$\lnot$ where negation is restricted to EDB relations) with an ordering over the universe captures PTIME.
%%We will show that confluence is undecidable for \lang programs in general, and that \lang subsumes PSPACE
We show that \lang is too expressive a language for this space, as it subsumes PSPACE, and that confluence is in general
undecidable for \lang programs.  This motivates us to propose \slang, a restricted version of \lang that is intuitively similar to semipositive Datalog.  \slang captures PTIME, and \slang programs are guaranteed to be confluent.

Unfortunately, \lang and \slang are not natural or convenient languages for programming certain kinds of systems.  Later in the paper we give 
an example of a distributed garbage-collection algorithm that detects ``orphaned'' memory and marks it for deletion.  Orphaned memory is naturally thought of as memory that is not contained in the transitive closure of a refers-to relation.  The negation of a transitive closure is theoretically specifiable -- but inconvenient
to express -- in both \lang and \slang.  It is inconvenient to write in \lang because of the issue of {\em coordination} -- ensuring the transitive closure is complete before applying negation (otherwise, multiple ultimate models may result).  It is inconvenient to write in \slang because although \slang programs are guaranteed to have a unique ultimate model, it is challenging to correctly specify the negation of a transitive closure using only semipositive rules.

%The theoretical result that this program \emph{could} be specified in the semipositive fragment
%of \lang is unsatisfying from a programmability perspective.  The wealth of research on stratified Datalog and the perfect model semantics suggests ....

In a recent paper targeting the systems community, we presented \emph{Bloom}, a domain-specific language (DSL) for implementing distributed 
systems.  While its semantics are based on \lang, Bloom is intended to be a practical programming language: we have used it to build a wide array of distributed protocols and several complete
applications, including a distributed file system.
Following the intuition of stratified negation, Bloom allows negation (and various forms of aggregation) over derived relations, provided that the program has a stratification.
If a Bloom program has no asynchrony or has only a single stratum, Bloom's static analysis flags the 
program as confluent.  If either of these conditions is false, the analysis tool identifies the asynchronously-derived relations that fall 
at stratum boundaries as ``points of order'' which must be ``sealed'' by additional logic that prevents them from changing once the effects 
of their negation have propagated to higher strata.  One would typically use a protocol similar to a coordination protocol from the distributed systems literature to ensure sealing.

The intuition behind Bloom leads us to propose a confluent language with a natural stratified semantics that we call \plang.  Since the negation semantics of \plang is so different than \lang, we do not automatically get a corresponding operational semantics for \plang like we do for \slang.  To achieve an operational semantics, we reduce \plang to a subset of \lang through a rewrite.  The rewrite, in which nodes ``vote'' to seal strata, likewise echoes coordination protocols from the distributed systems literature.

This paper makes three principal contributions.  We begin by proposing a new model-theoretic semantics for the output of \dedalus 
programs based on the models of their \emph{eventual} outcomes.  These \emph{ultimate models} represent an equivalent class with a finite (single in the case of confluent 
programs) number of members, among the infinite stable models of a \lang program.  We then show why \slang, the semipositive fragment of \lang, only admits confluent programs.  Finally, we propose \plang, a practical distributed logic language that likewise admits only confluent programs.
We show that \plang has a natural model-theoretic semantics corresponding to the stratified semantics for Datalog programs, and an equivalent operational semantics that echoes coordination protocols common in distributed systems.
