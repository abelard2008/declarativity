\section{Future Work}
\label{sec:conclusion}

An obvious area for future work is extending our focus on ``one-shot'' programs with well-defined inputs and outputs to reactive systems.  
Many distributed computations are long-lived services whose semantics need to be described with respect to subsets or subsequences of their inputs and outputs.  To this end, models from stream queries may be useful (e.g.,~\cite{Chandramouli2009}).  
Our network model is similarly restricted---in particular we have ignored message ``drops'' (infinite delays) and the standard ``timeout'' logic for dealing with them.  In our applied work~\cite{boom,cidr11} we have modeled timeouts as messages that arrive asynchronously under the control of an external ``clock'' agent.  Programs that reason about timeouts typically ``seal'' the contents of IDB relations based on the inherently non-deterministic subset of messages that ``beat the clock.''  It would be interesting to characterize a useful family of ultimate models in such programs without resorting to the full power of \lang.

Concurrent with this research, our team has been developing a practical language for implementing distributed
systems called \emph{Bloom}.  Bloom has built-in support for input streams, including ``periodic'' relations,
in which tuples appear at regular (wall clock) intervals and which are the basis of timeout logic.
Instead of relying on language restrictions like those presented in this paper, Bloom allows programmers to use the full
power of \lang, instead providing a conservative static analysis for confluence.
This design choice allows programmers to choose from (and implement) a wide variety of coordination protocols, rather than
simply allowing the system to synthesize a simple, generic protocol like the one we describe here.  
In practice, these protocols will perform very differently under different assumptions about the execution environment.

Formalizing these practical concerns is another area for future research.  The asymptotic result that \plang is PTIME
does not help us to distinguish among protocols with different performance characteristics relevant to practical
implementations, like message complexity.  We are pursuing work on a formal model of ...


