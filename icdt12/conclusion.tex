\section{Future Work}
\label{sec:conclusion}

An obvious area for future work is extending our focus on ``one-shot'' programs with well-defined inputs and outputs to reactive systems.  
Many distributed computations are long-lived services whose semantics need to be described with respect to subsets or subsequences of their inputs and outputs.  To this end, models from stream queries may be useful (e.g.,~\cite{Chandramouli2009}).  
Our network model is similarly restricted---in particular we have ignored message ``drops'' (infinite delays) and the standard ``timeout'' logic for dealing with them.  In our applied work~\cite{boom,cidr11} we have modeled timeouts as messages that arrive asynchronously under the control of an external ``clock'' agent.  Programs that reason about timeouts typically ``seal'' the contents of IDB relations based on the inherently non-deterministic subset of messages that ``beat the clock.''  It would be interesting to characterize a useful family of ultimate models in such programs without resorting to the full power of \lang.

Concurrent with this research, our team has been developing a practical language for implementing distributed
systems called \emph{Bloom}.  Bloom has built-in support for input streams, including ``periodic'' relations,
in which tuples appear at regular (wall clock) intervals and which are the basis of timeout logic.
Instead of relying on language restrictions like those presented in this paper, Bloom implements \lang, and provides a conservative static analysis for confluence.  The analysis marks the program as confluent if it is in \slang.  Otherwise, it alerts the programmer to uses of negation (and aggregation).  The programmer must then manually instrument their program with coordination logic, and manually verify its confluence.
This allows programmers to choose from (and implement) a wide variety of coordination protocols, rather than the system synthesizing a simple, generic protocol like the one we describe here.  
In practice, these protocols will perform very differently under different assumptions about the execution environment.

Formalizing these practical concerns is another area for future research.  That two programs have the same complexity in a Turing Machine model does not mean they have similar network performance characteristics in the operational semantics of network transducers.  We are pursuing work on a complexity model that will address this.
