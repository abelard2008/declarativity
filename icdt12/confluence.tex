\section{Problems}
\label{sec:confluence}

Although \lang is a natural language for distributed systems, and it is easy to compactly specify complex distributed systems \wrm{cite something?}, \lang has several problems.

First, it is easy to write programs with non-deterministic behavior (multiple ultimate models).

%Recall that nondeterminism in \lang only arises due to \dedalus{choice} in asynchronous rules, 
%which only occurs in asynchronous rules to model network nondeterminism.  
%which model temporal nondeterminism in unreliable networks.
%Model-theoretically, a nondeterministic result is manifest in multiple ultimate models.

\begin{definition}
A \lang program is {\em confluent} (has a deterministic output) if, for every instance of the program, it has a unique ultimate model.  A program that is not confluent is {\em diffluent}.
\end{definition}

Two examples of diffluent programs:

\begin{Dedalus}
output p.
q()@async <- q_edb();
r()@async <- r_edb();
p() <- q(), !r();
q()@next <- q();
r()@next <- r();
\end{Dedalus}

Assume an EDB of \dedalus{q\_edb(), r\_edb()}.  Any stable model where \dedalus{q()} has a lower timestamp than \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.  \wrm{The problem here is negation}.

\begin{Dedalus}
output p.
q()@async <- q_edb();
r()@async <- r_edb();
p() <- q(), r();
q()@next <- q();
\end{Dedalus}

As before, assume an EDB of \dedalus{q\_edb(), r\_edb()}.  Any stable model where the timestamp of \dedalus{q()} is less than or equal to the timestamp of \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.
%However, this example becomes confluent if we admit the last rule of Example~\ref{ex:nonconfluent2}: \dedalus{r()@next <- r();}.

\wrm{these examples show the only things that can cause non-confluence}

Unfortunately, confluence is an undecidable property of \lang programs:

\begin{lemma}
\label{lem:confluence-undecidable}
Confluence of a \lang program is undecidable.
\end{lemma}
\begin{proof}
Using the construction in~\cite{undecidable-datalog}, it is possible to write a Datalog program that encodes any two-counter machine's transition relation and an arbitrarily long finite successor relation in the EDB, and define a 0-ary output predicate \dedalus{accept} that is true if and only if the two-counter machine accepts and the transition and successor relations are valid.  As the construction is possible in Datalog, it is also possible in Dedalus.

We add the following rules to the construction, to nondeterministically decide whether to run the machine or not:

\begin{Dedalus}
message(0)@async.
message(1)@async.

run_machine() <- message(0), message(1).
accept() <- message(0), !message(1), input_valid().
accept() <- !message(0), message(1), input_valid().
\end{Dedalus}

Note that the first two lines are actually rules.  The unsugared form of the first rule is \dedalus{message(L,S,0) <- node(L), time(T), time(S), T < S, choice((L, T, 0), (S)).}

For valid inputs, the ultimate model is ${\dedalus{accept()}}$ if and only if either \dedalus{message(0)} and \dedalus{message(1)} are assigned the same timestamp and the machine accepts, or if the timestamps are different.  For invalid inputs, all ultimate models are empty.

If we could decide confluence for this program, we could decide whether there is any valid input for which an arbitrary two-counter machine halts in an accepting state.
\end{proof}

\wrm{Given undecidability, it would be great to have a restricted language that only allows us to write confluent stuff.}

Another problem is that \lang is too expressive -- it captures PSPACE as shown by the following Lemma.

\begin{lemma}
\label{lem:lang-pspace}
\lang captures PSPACE.
\end{lemma}
\begin{proof}
We show how to write QBF in Dedalus.

Assuming the formula is in prenex normal form, the textbook recursive algorithm for QBF involves removing the first quantifier, and checking both $0$ and $1$ for the first variable.  If the first quantifier was existential, then we return true if QBF of one of the subformulas is true.  If the first quantifier was universal, then we return true if QBF of both of the subformulas is true.

If the quantifier depth is $n$, then it is clear that each leaf in the recursive call tree can be represented as an $n$-bit binary number.  If we assume that the left child is always $0$ and the right child $1$, then we can view our algorithm as a postorder traversal of the recursive call tree.

First, we iterate through all of the $n$-bit binary numbers, one per timestamp.  We assume that the order over the variables is such that the leftmost variable in the formula (the high-order bit) is the first, and the rightmost is the last.  Thus, our addition is ``backwards'' in that it propagates carries to the predecessors:

\begin{Dedalus}
carry(V) <- var_last(V).
one(V)@next <- carry(V), !one(V).
one(V)@next <- one(V), !carry(V).
carry(U) <- carry(V), one(V), var_succ(U, V).
\end{Dedalus}

At each timestep, we check whether the current variable assignment is true.  If it is true, then \dedalus{formula\_true()} is true at that timestep.  We omit these rules.

We propagate truth information up the recursive call tree.  A node propagates a $1$ to its parent if the quantifier associated with that node is existential and at least one of its children is true, or the quantifier is universal and both of its children are true.  A node propagates a $0$ to its parent otherwise.  If the output of the root is $1$, the formula is satisfiable, otherwise it is not: \wrm{more explanation here}

\begin{Dedalus}
var_sat_in(V, 1) <- formula_true(), var_last(V).

var_sat(0, V, B)@next <- var_sat_in(V, B),
!var_sat(_, V, _).
var_sat(1, V, B)@next <- var_sat_in(V, B),
var_sat(0, V, _).

// existential quantifier
var_sat_left_in(vn, 1) <- exists(vn),
var_sat(_, vn, 1).
var_sat_left_in(vn, 0) <- exists(vn),
var_sat(0, vn, 0), var_sat(1, vn, 0).

// universal quantifier
var_sat_left_in(vn_succ, 1) <- forall(vn),
var_sat(0, vn, 1), var_sat(1, vn, 1).
var_sat_left_in(vn_succ, 0) <- forall(vn),
var_sat(_, vn, false).

var_sat_in(N, U, B) <- var_sat_left_in(V, B),
var_succ(U, V).

// persist var_sat until we get 2 of them
var_sat(N, V, B)@next <- var_sat(N, V, B),
!var_sat(1, V, _);

// the output of the last 
satisfiable(B) <- var_sat_left_in(V, B), var_last(V).
\end{Dedalus}
\end{proof}


\wrm{We will present a natural restriction of \lang that is confluent, and prove that it captures exactly PTIME.  Negation free, and guarded asynchrony.}
\wrm{DON'T FORGET UNIVERSAL QUANTIFIERS -- easy, use order, what about recursion thru universal quantification?}


\begin{definition}
A \lang program is {\em negation-free} if the \dedalus{!} symbol does not appear in the program.
\end{definition}


\begin{definition}
A \lang program has {\em guarded asynchrony} if all relations
%\jmh{we have async rules, not async preds} 
appearing in the heads of \dedalus{async} rules
are simply persisted. \wrm{define simply persisted}
\end{definition}

We will refer to the language of negation-free \lang programs with guarded asynchrony as \slang.

\wrm{look at this proof again}
\begin{theorem}
\label{thm:confluence}
\slang programs are confluent.
\end{theorem}
\begin{proof}

Towards a proof by contradiction, consider a negation-free \lang program that 
induces more than one ultimate model.  There must be a ground atom $a$ for a predicate $p$
that is true in one but
not in another model, and $a$ must be persistent, or it would not be
in the ultimate model.  Consider a derivation of $a$: a finite tree of applications of
implication whose leaves are EDB atoms.  If none of the implications involve a nondeterministic
choice of timestamp via an {\em async} rule, then certainly 
$a$ occurs in all stable models of the program,
%there is only one stable model of the program
%\jmh{I don't buy this; we're scoped down to atom $a$ here and the rules that feed into it}, 
so there must be at least one {\em async} rule in $a$'s derivation, contributing an atom
$r$.  
If $p$ is derived directly from 
$r$ via a series of derivation steps without any joins, then every stable
model $m$ will have a tuple $a_m$ in $p$ that differs from $a$ only in its timestamp, 
and hence correspond to the same ultimate model.
Therefore, $a$ must have at least one join step (i.e., a rule with at least two subgoals)
in its derivation following $r$,
which succeeded in this stable model (producing $a$), but did not succeed in another.  
%Guarded joins always
%eventually succeed, \jmh{don't you need to define ``join success'' and prove that guarded asynchrony does what you say?} what it and 

Consider such  a join rule.  One of its subgoals $s$ corresponds to a derivation that depends
on the async-derived atom $r$.  If any predicate between $s$ and $r$ is simply persisted and 
the program is negation-free,
then $s$ is persistent.  Regardless of the nondeterministic choice of timestamp for $r$, there
is some timestamp $V_m$ in every stable model $m$ of the program such that $s$ is true
for all $W > V$.  Hence in all stable models, $s$ is ``eventually'' true.  The same argument holds
for all subgoals of the rule under consideration, and hence guarded asynchrony implies that
all joins will eventually succeed.
Hence $a$ must exist in all ultimate models.
\end{proof}


If either qualification is false, problems can result, as we have previously illustrated.

\wrm{improve the diction here}
\begin{theorem}
\slang programs capture exactly PTIME.
\end{theorem}
\begin{proof}
We will show how to convert any \slang program to an FO[IFP] formula, and how to convert any FO[IFP] formula to a \slang program.  It is known that FO[IFP] captures exactly PTIME over ordered structures.

Since \slang has only EDB negation, we first show that in any FO[IFP] formula, negation can be pushed down to the EDB.  This is not hard to show.  Since FO[IFP] has a negation normal form where negation only applies to atoms \wrm{cite}, we can always push negation down through quantifiers and boolean operators using the usual DeMorgan dualities.  \wrm{Universal quantifiers are expressed like...}

Since \slang admits a least fixpoint in each iteration, we need to show we can rewrite this formula to an inflationary fixpoint formula.  \wrm{But we can rewrite the least fixpoint as an FO[IFP] formula, and nesting of inflationary fixpoints does not increase expressive power -- citation?}

We need to show that non-determinism does not increase expressive power.  Clearly it does not because all ultimate models are equivalent in \slang, so in particular, we could correctly compute the unique ultimate model of any \slang program deterministically by replacing \dedalus{@async} with \dedalus{@next}.

Thus, we can convert a \slang program into an FO[IFP] formula. \wrm{need to say something about simultaneous inductions, blah blah?}.

We can convert any FO[IFP] formula with only EDB negation into a \slang program by converting it into rule form \wrm{i.e. splitting up each disjunct into a rule, rewrite universal quantification using order, etc.}.
\end{proof}

%\subsection{Monotonic Properties}
%\wrm{The gist of this section is that we want to somehow expand ``negation-free'' to ``positive''.  I'm not sure if this works in general, so maybe we just axe this section.}


This discussion formalizes the CALM Conjecture mentioned above with respect to confluence, and proves it in one direction.
Clearly, there are confluent programs not in \slang.  For example:

\begin{example}
A confluent \lang program that is not a \slang program.

\begin{Dedalus}
//client
b(#S, I)@async :- b_edb(I), server(S);

//server
b(I)@next <- b(I), !dequeued(I);
b_lt(I, J) <- b(I), b(J), I < J;
dequeued(I)@next <- b(I), !b_lt(_, I);
mem(I) <- dequeued(I), !bt_lt(_, _);

\end{Dedalus}
\end{example}

This program has a single ultimate model in which \dedalus{mem()} contains the highest
element in \dedalus{b\_edb()} according to the order \dedalus{<}.
Thus it is confluent.  However, the program is not logically monotonic because neither \dedalus{dequeued()} nor \dedalus{!dequeued()} are monotonic, so \dedalus{mem()} is not supported by only monotonic properties. Thus the program is not logically monotonic.


\subsection{Perfect Ultimate Model}
%\wrm{rework definition to make clear we aren't coordinating @nexts}
% this will have to wait -wrm
% \jmh{motivate coordination by analogy to practice}

%While our definition of a monotonic property is quite permissive, there are still many cases in practice where programs will not satisfy that property.

\wrm{It would be nice to allow negation in Dedalus programs. Describe how we add stratified negation back to programs.}
\wrm{TOTALLY redo this section to tie in with our running example.}

%These programs are not in themselves confluent, but they often have a single ``natural'' ultimate model that corresponds to evaluating non-monotonic properties only when they can no longer change.  Evaluation of a Datalog program with negation has the same concern: the program has multiple minimal models, so one defines a {\em perfect model} as the minimal model generated by a local synchronous evaluation procedure called {\em stratified evaluation}~\cite{ullmanbook}.
% 
% 
% Programs that are not confluent often have a single ``natural'' ultimate model that corresponds to intuition, much as Datalog programs with negation have a {\em perfect model} corresponding to the model obtained by evaluating the program in a ``natural'' order.  
Similarly, for various uses of negation, we define a {\em perfect ultimate model}, and present a rewrite technique to convert a \lang program into a confluent program that computes this model.

Consider the following example, which is analogous to Example~\ref{ex:nonconfluent2} above:

\begin{example}
\label{ex:sayers}
The diffluent ``sayers'' program.

\begin{Dedalus}
//sayer
statement(#L, S, X)@async <- statement_edb(#S, X),
                             node(L);
s_false(#L, S, X)@async <- statement_edb(#S, X),
                           false_edb(#S, X),
                           node(L);

//listener
true(X) <- statement(_, S, X), !s_false(_, S, X);
false(X) <- statement(_, S, X), s_false(_, S, X);
statement(L, S, X)@next <- statement(L, S, X);
s_false(L, S, X)@next <- s_false(L, S, X);
true(X)@next <- true(X);
\end{Dedalus}
\end{example}

Intuitively this program represents a group of nodes (the ``sayers'') making statements to all nodes (the ``listeners'').  The sayers also occasionally remark that a statement is false (but a sayer may only declare one of his own statements to be false -- not the statement of another sayer).  One may expect the contents of \dedalus{true} to contain all statements that are not \dedalus{false}.  However, this is not necessarily the case.  Recall that the un-sugared version of the third rule is:

\begin{Dedalus}
true(X,T) <- statement(X,T), !false(X,T);
\end{Dedalus}

\noindent
Thus, the contents of \dedalus{true} at time \dedalus{T} are those items in \dedalus{statement} at time \dedalus{T} that are not in \dedalus{false} at time \dedalus{T}.  So in fact, the contents of \dedalus{true} in the ultimate model consist of ``everything stated that was ever not false''.  Such counter-intuitive results are enabled because the closed-world assumption is being applied to incomplete sets.

\begin{definition}
The {\em perfect ultimate model} of a \lang program with no negative cycles in its PDG, denoted $\mathcal{P}(P, E)$, is the ultimate model induced by ensuring all asynchrony is guarded, and no rule containing a \dedalus{!} or a \dedalus{count} is satisfiable before the timestamp when the complete set of facts in the negated or aggregated predicates is sealed: a predicate \dedalus{p} is {\em sealed} at time \dedalus{t} if any fact in \dedalus{p} at time $\dedalus{s} > \dedalus{t}$ is also in \dedalus{p} at time \dedalus{t}.  
%\jmh{This doesn't seem formal enuf to me.  What does it mean. model-theoreticlly, to evaluate a rule?  What do you mean "until"?}
%In other words, one must have ``complete information'' before applying the closed-world assumption for negation.
This intuitively corresponds to the definition of a perfect model from the Datalog literature.
%\wrm{make more formal}  \paa{this is an incomplete definition, right?  we are also interested in
%programs which when temporally flattened are not syntactically stratifiable, yet have a single ultimate model 
%corresponding to their ``coordinated'' evaluation(s)}
%\wrm{Insert UCS Here}
%The perfect ultimate model of a universally constraint stratified~\cite{ross-ucs} program that is universally constraint stratified~\cite{ross-ucs} is the ultimate model induced by ensuring that for every predicate that appears negated in the program subsets are completed in the partial order associated with the stratification.
\end{definition}

%There is always a stable model representing the perfect ultimate model of a \lang program whose flattening is syntactically stratified, because there is no recursion through negation, and Lemma~\ref{cron} tells us that any choice of timestamps is permissible in this case.\jmh{huh?}

Example~\ref{ex:sayers} has no negative cycles in its PDG, thus the rule with \dedalus{!s\_false} in the body should not be evaluated until the \dedalus{s\_false} set is complete.  We can check completeness by having each sayer send a digest of \dedalus{s\_false} messages to all listeners; the listeners recompute the digest over the \dedalus{s\_false} messages they have received; when the computed digest matches the received digest, a data dependency is satisfied, which enables the rule with \dedalus{!s\_false}.

%In Example~\ref{ex:sayers}, any stable model where no \dedalus{false} message arrives after a \dedalus{statement} message with the same value results in the perfect ultimate model.
%In particular, we can modify the program to be confluent with the perfect ultimate model by ensuring that negation is not applied until the \dedalus{false} set is complete.  It turns out we can generalize this into an algorithm for all \lang programs whose temporal flattening is syntactically stratified.

%\wrm{for unstratifiable flattenings, we can introduce another notion of the ``synchronous flattening'', and fully order individual messages passing through an unstratifiable recursion through negation, and call this the perfect ultimate model...}

One possible digest is a \dedalus{count} of \dedalus{s\_false} messages\footnote{A different digest strategy that does not use \dedalus{count} has each sayer sort their messages, and send the sorted order, as well as the maximum message.}.  We add the following two rules to compute counts of false messages at each sayer, and each listener:

\begin{Dedalus}
count_false_sent(#N, S, 0) <- 
  !false_edb(#S, _), node(N);
count_false_sent(#N, S, count<X>) <- 
  false_edb(#S, X), node(N);
count_false_recv(S, count<X>) <- s_false(_, S, X);
\end{Dedalus}

Furthermore, we add a dependency on the equality of the counts into the body of the \dedalus{!s\_false} rule:

\begin{Dedalus}
true(X) <- statement(_, S, X), !s_false(_, S, X),
           count_false_recv(S, X),
           count_false_sent(_, S, X);
\end{Dedalus}

Now, independent of the assignment of timestamps, no statement from a sayer \dedalus{S} is considered to be true by any listener unless the listener has complete information about which statements are false.

\subsubsection{Coordination}
\label{sec:coord}
Given a \lang program $P$ with no negative cycles in its PDG\footnote{A similar algorithm is possible for other statically checkable stratification conditions, such as Universal Constraint Stratification~\cite{ucs}.}, we can generate a confluent program $\textsc{Coord}(P)$, such that \linebreak $\mathcal{U}(\textsc{Coord}(P), E) = \mathcal{P}(P, E)$.

\begin{algorithmic}[1]
  \Procedure{Coord}{$P$}%\Comment{}
  \ForAll{\dedalus{p} such that $\dedalus{q} \Diamondright \dedalus{p} \nrightarrow \dedalus{r}$}
  \ForAll{async rules with \dedalus{p} in the head}
  \State{change head predicate name to \dedalus{p\_local}}
  \State{remove location attribute of every atom in rule}
  \EndFor
  \State{add rules in Figure 1} \label{alg:addrules} %XXX
  \ForAll{rules with \dedalus{!p} in the body} \label{alg:lastfor}
  \State{add \dedalus{!p\_incomplete()} to body}
  \EndFor
  \EndFor%\label{euclidendwhile}
  \State \textbf{return} $P$
  \EndProcedure
\end{algorithmic}


\begin{figure}[h!]
\label{fig:coordcode}
\begin{Dedalus}
p_count_send(#Y,S,count<*>)@async <- p_local(#S,Y,\dbar{X});
p_count_send(#Y,S,0)@async <- !p_local(#S,Y,\dbar{_});
p_send(#Y,S,\dbar{X})@async <- p_local(#S,Y,\dbar{X});
p_count_recv(S,count<*>) <- p(S,\dbar{X});
p_count_send(#Y,S,C)@next <- p_count_send(#Y,S,C);
p(\dbar{X}) <- p_send(\dbar{X});
p(\dbar{X})@next <- p(\dbar{X});
p_incomplete() <- node(S), !p_count_recv(S,_);
p_incomplete() <- node(S), !p_count_send(S,_);
p_incomplete() <- p_count_recv(S, C1),
                  p_count_send(S, C2), C1 < C2;
\end{Dedalus}
\caption{Coordination code}
\end{figure}

\begin{theorem}
For any program $P$, $\mathcal{U}(\textsc{Coord}(P), E)|_{\text{Pred}(P)} = \mathcal{P}(P, E)$, where $\text{Pred}(P)$ is the set of predicates in program $P$\footnote{We consider $\mathcal{U}(\textsc{Coord}(P), E)|_{\text{Pred}(P)}$ instead of $\mathcal{U}(\textsc{Coord}(P), E)$ because the latter contains facts in the predicates \dedalus{p\_count\_send}, \dedalus{p\_count\_recv}, and \dedalus{p\_incomplete}.}.
\end{theorem}

A straightforward argument shows that if \dedalus{p\_incomplete()} is false at time \dedalus{t}, then it is false at time \dedalus{t+1}.  It is easy to see if \dedalus{p\_incomplete} is false at time \dedalus{t}, then there cannot exist a \dedalus{p} fact derived by an asynchronous rule at timestamp $\dedalus{t+1}$.  Thus, any rule with \dedalus{!p\_incomplete()} will not be satisfiable until all elements in the \dedalus{p} set are known.
