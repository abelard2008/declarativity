%%\section{\large \bf \slang}
\section{Refining \large \bf \lang}
\label{sec:confluence}

%\todo{Brag that \slang has a well-defined termination condition, whereas \lang does not}

%Although \lang is a natural language for distributed systems, and it is easy to compactly specify complex distributed systems \wrm{cite something?}, \lang has several problems.
\lang can express a broad class of distributed systems but this flexibility comes at a cost.
As we have shown, a \lang program may have multiple ultimate models. %it is easy to write programs that have multiple ultimate models, 
%which intuitively means that the program has non-deterministic output.
%corresponding to executions that produce different outputs.
%\wrm{Also say something about non-trivial programs with an empty ultimate model.}
%as well as nontrivial programs with an empty ultimate model.
However, it is often desirable to ensure that a program has a single, deterministic output, regardless of non-determinism in its behavior. %in the order of message arrivals (captured in \lang by \dedalus{choice}).  
% Such programs are rarely desired and may indicate a bug.
%\nrc{Dubious:
%  long-running services might well have no ultimate model according to this
%  formulation. Somewhere, we should probably concede that confluence, as formulated, is not
%  a general correctness criteria.}
% Commented out for now, because Dedalus_C doesn't model long-running services, as the entire EDB is assumed to be given at time 0.
%%First, the problem of multiple ultimate models, or no ultimate model, is a problem.  In practice, such programs are rarely desired and indeed often indicate a bug.  
% We typically would like our distributed program to have a single output, regardless of any non-deterministic behavior within an execution.

Having defined the \lang language, we will refer to two running examples for the remainder of the paper.  

\begin{example}
\label{ex:marriage}
A simple asynchronous marriage ceremony:

\begin{Drules}
  \drule{groom_i_do()@async}
        {groom_i_do_edb()}
  \drule{bride_i_do()@async}
        {bride_i_do_edb()}
  \drule{runaway()}        {$\lnot$bride_i_do(), groom_i_do()}  
  \drule{runaway()}        {$\lnot$groom_i_do(), bride_i_do()}  
  \drule{runaway()@next}
        {runaway()}
  \drule{groom_i_do()@next}
        {groom_i_do()}
  \drule{bride_i_do()@next}
        {bride_i_do()}
\end{Drules}
\end{example}
In a classic paper, Gray notes the similarity between distributed commit
protocols and marriage ceremonies~\cite{graytransactionconcept}.  For simplicity
(and felicity), Example~\ref{ex:marriage} presents a simple asynchronous voting
program with a fixed set of members: a bride and a groom.  The marriage is off
(\dedalus{runaway()} is true) if one party says ``I do'' and the other does not.

However, the \lang program as given does not correctly implement such a vote. 
% as it relies on a non-deterministic ``synchronicity'' of the two parties.
Any stable model where \dedalus{groom_i_do()} and \dedalus{bride_i_do()}
disagree in their first chosen timestamps yields an ultimate model
containing \dedalus{runaway()}.  By contrast, if the votes are assigned the same timestamp,
the ultimate model does not contain \dedalus{runaway()}. In operational terms,
this program exhibits a race condition: when the EDB contains ``I do'' votes
from both parties, the truth value of \dedalus{runaway()} depends on the (non-deterministic) times at which their messages are delivered.
%Note that all predicates are inflationary.
%Removed this, because "inflationary" has not yet been defined; not sure it is
%crucial, anyway. -nrc

\begin{example}
\label{ex:gc}
Distributed garbage collection:

\begin{Drules}
  \drule{addr(Addr)@async}
        {addr_edb(Addr)}
  \drule{refers_to(#M, Src, Dst)@async}
        {local_ptr_edb(#N, Src, Dst), master(#M)}
  \drule{refers_to(Src, Dst)@next}{refers_to(Src, Dst)}
  \drule{reach(Src, Dst)}
        {refers_to(Src, Dst)}
  \drule{reach(Src, Next)}
        {reach(Src, Dst), refers_to(Dst, Next)}
  \drule{garbage(Addr)}
        {addr(Addr), root_edb(Root), $\lnot$reach(Root, Addr)}
  \drule{garbage(Addr)@next} {garbage(Addr)}
\end{Drules}
\end{example}
Example~\ref{ex:gc} presents a simple garbage collection program for a
distributed memory system. Each node manages a set of pointers and forwards this
information to a central master node. The master computes the set of
transitively reachable addresses; if an address is not reachable from the root
address, it can be garbage collected. For
simplicity, we assume that each node owns a fixed set of pointers, stored in the
EDB relation \dedalus{local_ptr_edb}.

This more complicated example suffers from the same ambiguity as the marriage
ceremony presented previously.  While the program has an ultimate model
corresponding to executions in which \dedalus{garbage} is not computed until the
transitive closure of \dedalus{refers\_to} has been fully determined (i.e.,
after all messages have been delivered), it also has ultimate models
corresponding to executions in which \dedalus{garbage} is ``prematurely''
computed.  When \dedalus{garbage} is computed before all the \dedalus{refers_to}
messages have been delivered, there is a correctness violation: reachable memory
addresses appear in the \dedalus{garbage} relation.

Note that for both examples, there is a single ultimate model corresponding to
the execution in which negation is not applied to a set until the content of the
set has been fully determined.  This ``preferred'' model is akin to the perfect
model computed by a centralized Datalog evaluator that evaluates rules in
stratum order~\cite{ullmanbook}, applying the closed-world assumption to
relations only when it is certain that they will no longer change.
Unfortunately, in an asynchronous distributed system it is difficult to
distinguish the absence of a message (e.g., the \dedalus{bride_i_do} or some
expected \dedalus{refers_to} messages) from channel delay.  Hence both programs
above are underspecified insofar as they conclude, as soon as they receive any
messages, that no others will arrive.  In practice, a programmer could remediate
the problem by augmenting their programs with \emph{coordination} code that
enforces a computation barrier.  This technique generally entails a protocol
(e.g., voting or consensus) that takes place between all communicating agents to
ensure that there are no outstanding messages in flight.

In the remainder of this section, we explore the aspects of \lang that allow
such ambiguities and propose a restricted language \slang that rules them out
(but complicates the specification of programs like our examples above).  In
Section~\ref{sec:perfect}, we consider a different language---\plang---that allows
relatively intuitive program specifications like our examples, but narrows their
interpretation to a single, ``preferred'' model.

\subsection{Problems with \large \bf \lang}

\begin{definition}
  A \lang program is {\em confluent} if, for every EDB instance, it has a single ultimate model.  A program that is not confluent is {\em diffluent}.
\end{definition}

%Confluence corresponds to the intuition that a program has a
%deterministic output set. Examples~\ref{ex:diffluent1} and \ref{ex:diffluent2}
%are two examples of diffluent programs.

Confluence is a desirable, albeit conservative, correctness property for a
distributed program.  A program that is confluent produces deterministic output
despite any non-deterministic behaviors that might occur during its
execution. For example, if we could show that a data replication protocol was
confluent, we could prove a version of the commonly desired property that all
replicas be ``eventually consistent'' after all messages have been
delivered~\cite{bayou,doug-terry}.  Confluence may be viewed as a specialization of the
more general notion of consistency of distributed state, which the CALM
theorem~\cite{declarative-imperative} argues is strongly connected with the
model-theoretic property of logical monotonicity.

Unfortunately, confluence is an undecidable property of \lang programs:

\begin{lemma}
\label{lem:confluence-undecidable}
Confluence of \lang programs is undecidable.
\end{lemma}
This result is perhaps not surprising, as confluence is defined over all EDB instances.  We present a proof in the appendix.

%\wrm{Given undecidability, it would be great to have a restricted language that only allows us to write confluent stuff.}

Another symptom of \lang being ``too big'' a language is its expressive power: it subsumes PSPACE.  

\begin{lemma}
\label{lem:lang-pspace}
\lang %captures exactly
subsumes PSPACE.
\end{lemma}

\begin{proof}
%If we define the output of a \lang program to be the union of all ultimate models, then it is easy to see that there is an NPSPACE Turing Machine that can execute any \lang program: the maximum amount of space that a \lang program may use at any timestamp is bounded by $O(n^k)$, where $n$ is the size of the universe, and $k$ is the maximum arity of any relation.  Thus $\lang \subseteq \text{NPSPACE}$, and it is known that $\text{NPSPACE} = \text{PSPACE}$.

%In the other direction of the proof,
We show how to write the PSPACE-complete Quantified Boolean Formula (QBF) problem~\cite{garey-johnson} in \lang. Since \lang is closed under first-order reductions and QBF is PSPACE-complete under first-order reductions, we have that $\text{PSPACE} \subseteq \lang$.  Details are in the appendix.
\end{proof}

\subsection{\large \bf \slang}
\label{sec:plus}

Distributed programs that produce non-deterministic outputs or have runtimes
exponential in their inputs are often undesirable in practice. Since checking for
confluence in \lang is undecidable in general, we may instead ask whether a more
constrained language will exclude such undesirable programs. %while retaining the
%convenience of \lang.
We will present a restriction of \lang that allows only
confluent programs and prove that it captures exactly PTIME.

\begin{definition}
A \lang program is {\em semipositive} if the \dedalus{$\lnot$} symbol only appears on EDB relations in the program.
\end{definition}

\begin{definition}
A \lang program $P$ has {\em guarded asynchrony} if for every relation \dedalus{p} appearing in the head of an asynchronous rule, the program $P$ has a rule \dedalus{p(\(\overline{\dedalus{X}}\))@next \(\leftarrow\) p(\(\overline{\dedalus{X}}\)).}
\end{definition}

We will refer to the language of semipositive \lang programs with guarded
asynchrony as \slang.

\subsubsection{Confluence}

To show that all \slang programs are confluent, we begin by showing that \slang
programs are {\em temporally inflationary}: if a stable model of a \slang
instance contains a spatio-temporal fact \dedalus{f@t}, then it also contains
\dedalus{f@t+1} (and thus the ultimate model contains \dedalus{f}).

\begin{lemma}
\label{lem:inflationary}
\slang programs are temporally inflationary.
\end{lemma}
\begin{proof}
Consider a {\em derivation tree} for \dedalus{f@t}: a finite tree of instantiated (variable-free) rules, where negation only occurs at the leaves.  Note that the instantiated head atom, as well as every instantiated body relation, is a spatio-temporal fact. 
%We assume that the derivation tree does not include nodes for \dedalus{time}, \dedalus{timeSucc}, \dedalus{node}, or \dedalus{<}, or any relation introduced in the causality or \dedalus{choice} rewrites.
The tree's root is some instantiated rule with \dedalus{f@t} in its head.  A node has one child node for each body fact: the child node contains an instantiated rule with the fact in its head---if the body fact's relation does not appear in the head of any rule, then the corresponding node contains just the fact, and is a leaf node.  The leaves of the tree are instantiated EDB facts.

For the moment, we assume that every fact has a unique derivation tree.  Multiple derivation trees are easy to handle---simply repeat the following process for each tree.

If the relation of \dedalus{f} is EDB, or appears in the head of an asynchronous rule, then the lemma holds by definition of \slang.  Assume some stable model contains \dedalus{f@t} and not \dedalus{f@t+1}.  Thus, if the rule is inductive (resp.\ deductive), then for some child of \dedalus{f@t}, call it \dedalus{g@t-1} (resp.\ \dedalus{g@t}), the fact \dedalus{g@t} (resp.\ \dedalus{g@t+1}) is not in the stable model.  Inductively proceed down the tree, at each step going to a node whose relation does not appear in the head of an asynchronous rule.  However, the path will eventually terminate at a leaf node providing a contradiction, because facts at leaf nodes are either EDB or negated EDB, meaning that they exist at all timestamps, or they are one of \dedalus{time}, \dedalus{timeSucc}, or \dedalus{<}, which also exist at all timestamps.
\end{proof}

A consequence of temporal inflation is that all \slang programs are confluent.

\begin{theorem}
\label{thm:confluence}
\slang programs are confluent.
\end{theorem}
\begin{proof}

Towards a proof by contradiction, consider a \slang program that 
induces two ultimate models $\mathcal{U}_1, \mathcal{U}_2$ for some EDB.  Without loss of generality, there must be a spatial fact \dedalus{f}, such that 
$\dedalus{f} \in \mathcal{U}_1$ and $\dedalus{f} \not\in \mathcal{U}_2$.

Recall that if spatial fact \dedalus{f} is in some ultimate model, then for some $\dedalus{t\sub{0}} \in \mathbb{N}$, there is some stable model that contains \dedalus{f@t} for all \dedalus{t} > \dedalus{t\sub{0}}.

Consider a derivation tree for \dedalus{f@t\sub{0}} in any stable model that yields $\mathcal{U}_1$.  Again, for simplicity, we assume uniqueness of this derivation tree.  For some child of \dedalus{f@t\sub{0}}, call it \dedalus{g@s}, for all stable models that yield $\mathcal{U}_2$ there is no \dedalus{r} such that \dedalus{g@r} is in the stable model by Lemma~\ref{lem:inflationary}.  Continue traversing the tree, at each step picking such a \dedalus{g}.  Eventually, the traversal terminates at an EDB node, leading to a contradiction.
%If $a$ is derived directly from 
%$r$ via a series of derivation steps without any joins, then every stable
%model $m$ will have a tuple $a_m$ in $p$ that differs from $a$ only in its timestamp, 
%and hence correspond to the same ultimate model.
%Therefore, $a$ must have at least one join step (i.e., a rule with at least two subgoals)
%in its derivation following $r$,
%which succeeded in this stable model (producing $a$ or an antecedent of $a$), but did not succeed in another.  
%Guarded joins always
%eventually succeed, \jmh{don't you need to define ``join success'' and prove that guarded asynchrony does what you say?} what it and 
%Consider such  a join rule.  One of its subgoals $s$ corresponds to a derivation that depends
%on the async-derived atom $r$.  
%Regardless of the non-deterministic choice of timestamp for $r$, there
%is some timestamp $V_m$ in every stable model $m$ of the program such that $s$ is true
%for all $W > V$.  Hence in all stable models, $s$ is ``eventually'' true.  The same argument holds
%for all subgoals of the rule under consideration.
%Hence $a$ must exist in all ultimate models.
\end{proof}

Since a \slang program has a unique ultimate model, the specific \dedalus{choice} of values for timestamps does not affect the ultimate model.
% as long as the choice respects the causality constraint, as described in Section~\ref{sec:st}.
In particular, we can assume that the \dedalus{timeSucc} of the body timestamp is always chosen:

\begin{corollary}
\label{cor:no-async}
Define the program transformation $\mathcal{A}(P)$ to be the transformation that, converts every asynchronous rule $\varphi$ of \slang program $P$ into an inductive rule by undoing the causality and \dedalus{choice} rewrites, dropping the \dedalus{choice} operator, and adding \dedalus{timeSucc(T,S)} to $pos(\varphi)$.  Then, the ultimate model of $\mathcal{A}(P)$ is the same as the ultimate model of $P$.
\end{corollary}

Of course, there are confluent \lang programs not in \slang.  For example:

\begin{example}
A confluent \lang program that is not a \slang program.

\begin{Drules}
\drule{b(#N, I)@async}
      {b_edb(#L, I)}
\drule{b(I)@next}
      {b(I), $\lnot$dequeued(I)}
\drule{b_lt(I, J)}
      {b(I), b(J), I < J}
\drule{dequeued(I)@next}
      {b(I), $\lnot$b_lt(_, I), \linebreak b_lt(_, _)}
\end{Drules}
\end{example}

Any instance of this program has a single ultimate model in which \dedalus{b()}
(at all nodes) contains the highest element in \dedalus{b_edb()} according to the order
\dedalus{<}.  Thus it is confluent, but the program uses IDB negation and does
not have guarded asynchrony.

\subsubsection{Computational Complexity}
Not only are \slang programs confluent, but they also capture exactly PTIME.  We
will prove this by showing an equivalence to semipositive Datalog programs, which are known
to capture exactly PTIME over ordered structures~\cite{immerman-book}.

First, we note that inductive rules in \slang can be ``converted'' into deductive rules without
affecting the ultimate model. 
%\jmh{The below strikes me as being rather sloppier than the rest of the discussion.  You talk about program transformations in a pretty offhanded way (as compared to the development of spatiotemporal rules, for example).  The special treatment of simple persistence rules makes this feel even sloppier.  Might be worth specifying the transformation in the style you use in Section 2, and then proving the equivalence of pre- and post-transformed programs.}

\begin{lemma}
\label{lem:no-inductive}
Define the program transformation $\mathcal{I}(P)$ in the following way: in every inductive rule of \slang program 
$P$---except any basic persistence rule for a relation that appears in the head of an asynchronous rule---remove 
the \dedalus{timeSucc(T,S)} body atom, and replace all instances of the variable \dedalus{S} with the variable \dedalus{T}.  
The ultimate model of $\mathcal{I}(P)$ is the same as the ultimate model of $P$.
\end{lemma}
\begin{proof}
Note that by Lemma~\ref{lem:inflationary}, $\mathcal{I}(P)$ is inflationary.  The proof proceeds similarly to the proof of Lemma~\ref{lem:inflationary}---there is some fact in $\mathcal{U}_1$ but not $\mathcal{U}_2$; we consider a derivation tree for this fact in any stable model; it must be the case that some child fact of the parent does not appear in any stable model for $\mathcal{U}_2$ (by Lemma~\ref{lem:inflationary}).  We inductively repeat the procedure, and discover that in order for the fact to be absent from $\mathcal{U}_1$, the EDB must be different, which is a contradiction.
\end{proof}

%If either qualification is false, problems can result: Example~\ref{ex:diffluent1} shows a diffluent program with guarded asynchrony and IDB negation, and Example~\ref{ex:diffluent2} shows a diffluent program that is IDB-negation free but does not have guarded asynchrony.

\begin{theorem}
\label{thm:ptime}
\slang captures exactly PTIME.
\end{theorem}
\begin{proof}
First we apply Corollary~\ref{cor:no-async} to rewrite asynchronous rules as inductive rules.  Then, we convert all inductive rules into deductive rules using Lemma~\ref{lem:no-inductive}.  Since all rules are deductive, there is a unique stable model, which is also the same for every timestamp.

Consider removing the timestamp attributes from all relations, and thus the \dedalus{time} relations from the bodies of all rules.  The result is a Datalog program with EDB negation.  Its minimal model is exactly the ultimate model of the single-timestep \slang program.

In the other direction, it is clear that we can encode any Datalog program with EDB negation in \slang using deductive rules; the ultimate model coincides with the minimal model of the Datalog program.
\end{proof}

% \subsection{Monotonic Properties}
% XXX: Can we relax ``IDB negation free'' to be ``IDB positive''?


%This discussion formalizes the CALM Conjecture~\cite{declarative-imperative} with respect to confluence, and proves it in one direction. \todo{Tie this in with the CALM conjectu%re.}
%Clearly, there are confluent programs not in \slang.  For example:
