%%\section{\large \bf \slang}
\section{Refining \large \bf \lang}
\label{sec:confluence}

\todo{Brag that \slang has a well-defined termination condition, whereas \lang does not}

%Although \lang is a natural language for distributed systems, and it is easy to compactly specify complex distributed systems \wrm{cite something?}, \lang has several problems.
\lang can express a broad class of distributed systems but this flexibility comes at a cost.
As we have shown, it is easy to write programs that have multiple ultimate models, which intuitively means that the program has non-deterministic output.
%\wrm{Also say something about non-trivial programs with an empty ultimate model.}
%as well as nontrivial programs with an empty ultimate model.
Such programs are rarely desired and may indicate a bug.
%\nrc{Dubious:
%  long-running services might well have no ultimate model according to this
%  formulation. Somewhere, we should probably concede that confluence, as formulated, is not
%  a general correctness criteria.}
% Commented out for now, because Dedalus_C doesn't model long-running services, as the entire EDB is assumed to be given at time 0.
%%First, the problem of multiple ultimate models, or no ultimate model, is a problem.  In practice, such programs are rarely desired and indeed often indicate a bug.  
We typically would like our distributed program to have a single output, regardless of any non-deterministic behavior within an execution.

Having defined the \lang language, we will refer to two running examples for the remainder of the paper.  

\begin{example}
\label{ex:marriage}
An asynchronous marriage ceremony:

\begin{Drules}
  \drule{groom_i_do()@async}
        {groom_i_do_edb()}
  \drule{bride_i_do()@async}
        {bride_i_do_edb()}
  \drule{runaway()}        {groom_i_do(), !bride_i_do()}  
  \drule{runaway()}        {!groom_i_do(), bride_i_do()}  
  \drule{runaway()@next}
        {runaway()}
  \drule{groom_i_do()@next}
        {groom_i_do()}
  \drule{bride_i_do()@next}
        {bride_i_do()}
\end{Drules}
\end{example}
Example~\ref{ex:marriage} presents a simple distributed voting program with a
fixed set of members: a bride and a groom.  The marriage is off
(\dedalus{runaway()} is true) if either party does not say ``I do.''

However, the \lang program as given does not correctly implement such a vote.
Any stable model where \dedalus{groom_i_do()} and \dedalus{bride_i_do()}
disagree in their first assignments of timestamps yields an ultimate model
containing \dedalus{runaway()}.  If the votes are assigned the same timestamp,
the ultimate model does not contain \dedalus{runaway()}. In operational terms,
this program exhibits a race condition: when the EDB contains ``I do'' votes
from both parties, the truth value of \dedalus{runaway()} depends on the times
at which the votes are delivered. Note that all predicates are inflationary.

\begin{example}
\label{ex:gc}
Distributed garbage collection:

\begin{Drules}
  \drule{points_to(#M,Src,Dst)@async}
        {local_ptr_edb(#N, Src,Dst), master(#M)}
  \drule{points_to(Src,Dst)@next}{points_to(Src,Dst)}
  \drule{reach(Src,Dst)}
        {points_to(Src,Dst)}
  \drule{reach(Src,Next)}
        {reach(Src,Dst), points_to(Dst,Next)}
  \drule{unreach(Addr)}
        {addr_edb(Addr), root_edb(Root), !reach(Root, Addr)}
  \drule{unreach(Addr)@next} {unreach(Addr)}
\end{Drules}
\end{example}
Example~\ref{ex:gc} presents a simple garbage collection program for a
distributed memory system. Each node manages a set of pointers and forwards this
information to a central coordinator node. The coordinator computes the set of
transitively reachable addresses; if an address is not reachable from the root
address, it is considered an orphan and can be garbage collected. Note that we
would like the semantics of \dedalus{unreach} to be inflationary: once an
address becomes eligible to be garbage collected, it should not later
``disappear'' from \dedalus{unreach}. For simplicity, we assume that each node
owns a fixed set of pointers, stored in the EDB relation
\dedalus{local_ptr_edb}. \nrc{Problem with this example: \dedalus{unreach()}
  will always be true at the first timestep, because no async facts will be
  delivered yet.}

This more complicated example suffers from the same ambiguity as the marriage
ceremony presented previously.  While the program has an ultimate model
corresponding to executions in which \dedalus{unreach} is not computed until the
transitive closure of \dedalus{points\_to} is fully determined (i.e., after all
messages have been delivered), it also has models corresponding to executions in
which it is ``prematurely'' computed.  These models all result in correctness
violations, in which reachable memory is reclaimed.

Note that for both examples, there is a single ultimate model corresponding to
the execution in which negation is not applied to a set until the content of the
set has been fully determined.  This ``preferred'' model is akin to the perfect
model computed by a centralized Datalog evaluator that computes rules in stratum
order~\cite{ullman}, applying the closed-world assumption to predicates only
when it is certain that they will no longer change.

In the remainder of this section, we explore the features of \lang that allow
such ambiguities and propose a restricted language \slang that rules them out
(but prohibits or complicates our implementations).  In
Section~\ref{sec:perfect}, we consider a relaxation of \slang that forces a
single, ``preferred'' model.

\subsection{Problems with \large \bf \lang}

\begin{definition}
  A \lang program is {\em confluent} if, for every EDB instance, it has a single ultimate model.  A program that is not confluent is {\em diffluent}.
\end{definition}

%Confluence corresponds to the intuition that a program has a
%deterministic output set. Examples~\ref{ex:diffluent1} and \ref{ex:diffluent2}
%are two examples of diffluent programs.

Confluence is a desirable, albeit conservative, correctness property for a distributed program.  A program that is
confluent produces a deterministic output in spite of nondeterministic orders in its execution.  For example, if
we could show that a data replication protocol was confluent, we could prove that all replicas were ``eventually consistent''
after all messages were delivered, in spite of delay and reordering.
Unfortunately, confluence is an undecidable property of \lang programs:

\begin{lemma}
\label{lem:confluence-undecidable}
Confluence of \lang programs is undecidable.
\end{lemma}
This is perhaps not a surprising result, as confluence is defined over all EDB instances.  We present a proof in the appendix.

%\wrm{Given undecidability, it would be great to have a restricted language that only allows us to write confluent stuff.}

Another problem is that \lang is too expressive -- it captures PSPACE.  

\begin{lemma}
\label{lem:lang-pspace}
\lang captures exactly PSPACE.
\end{lemma}
\begin{proof}
If we define the output of a \lang program to be the union of all ultimate models, then it is easy to see that there is an NPSPACE Turing Machine that can execute any \lang program: the maximum amount of space that a \lang program may use at any timestamp is bounded by $O(n^k)$, where $n$ is the size of the universe, and $k$ is the maximum arity of any relation.  Thus $\lang \subset \text{PSPACE}$.

We show how to write the PSPACE-complete QBF problem in \lang. Since \lang is closed under first-order reductions, and QBF is PSPACE complete under first-order reductions, we have that $\text{PSPACE} \subset \lang$.

Assume that the QBF formula is in prenex normal form: \linebreak$Q_1 x_1 Q_2 x_2 \ldots Q_n x_n(x_1, \ldots, x_n)$.  The textbook recursive algorithm for QBF involves removing $Q_1$, and recursively calling the algorithm twice, once for $F_1 = Q_2 x_2 \ldots Q_n x_n(0, x_2, \ldots x_n)$ and once for $F_2 = Q_2 x_2 \ldots Q_n x_n(1, x_2, \ldots, x_n)$ for $x_1$.  If $Q_1 = \exists$, then the algorithm returns $F_1 \lor F_2$; if $Q_1 = \forall$, then $F_1 \land F_2$.

The leaves of the tree of recursive calls can each be represented as an $n$-bit binary number, where bit $i$ holds the value of $x_i$.  Assume the left child of a node at depth $i$ of the recursive call tree represents binding $x_{i}$ to $0$, and the right child $1$.

Our algorithm is intuitively similar to a postorder traversal of this recursive call tree.  Recursively, first visit the left node, then visit the right node, then visit the root.  If we are visiting a leaf node, we evaluate the formula for the given variable binding, and store a $0$ or $1$ at the node depending on whether the formula is false or true for that particular binding.  If we are visiting a non-root node at level $i$, we apply the quantifier $Q_i$ to the values stored in the child nodes.  Even though the recursive call tree is exponential in size, we only require $O(n)$ space due to the sequentiality of the traversal.

First, we iterate through all of the $n$-bit binary numbers, one per timestamp.  We assume that the order over the variables is such that the leftmost variable in the formula (the high-order bit) is the $x_1$ (the first), and the rightmost is $x_n$ (the last).  Thus, our addition is ``backwards'' in that it propagates carries from $x_i$ to $x_{i-1}$:

\begin{Drules}
  \drule{carry(V)}
        {var_last(V)}
  \drule{one(V)@next}
        {carry(V), !one(V)}
  \drule{one(V)@next}
        {one(V), !carry(V)}
  \drule{carry(U)}
        {carry(V), one(V), var_succ(U, V)}
\end{Drules}

At each timestep, we check whether the current assignment of values to the variables makes the formula true.  We omit these rules for brevity.  If the formula is true, then \dedalus{formula_true()} is true at that timestep.

The following rules handle how nodes set their values to either $0$ or $1$.  Note that we only require $2n$ bits of space for this step: each depth $1,\ldots,n$ in the recursive call tree has two one-bit registers (labelled by constant symbols \dedalus{a} and \dedalus{b}) representing the current values of the children in the traversal.

\dedalus{var_sat_in} associates a depth with a given truth value ($0$ or $1$).  This value is placed into \dedalus{var_sat} at depth \dedalus{V} in register \dedalus{a} if \dedalus{a} is empty, or \dedalus{b} otherwise.  Once a value is placed in register \dedalus{b}, it is deleted in the immediate next timestamp.  As we will see later, before with this deletion, the parent node applies its quantifier to the values in the two registers.

The truth value at depth $n$ (denoted by \dedalus{var_last}) is the truth value of the formula (\dedalus{formula_true()}) for the assignment of variables at the current timestep.

\begin{Drules}
  \drule{var_sat_in(V, 1)}
        {formula_true(), var_last(V)}
  \drule{var_sat(a, V, B)@next}
        {var_sat_in(V, B), !var_sat(_, V, _)}
  \drule{var_sat(b, V, B)@next}
        {var_sat_in(V, B), var_sat(a, V, _).}
  \drule{var_sat(N, V, B)@next}
        {var_sat(N, V, B), !var_sat(b, V, _)}
\end{Drules}

\dedalus{var_sat_left_in} associates a value with the parent of a given depth.  This is used for propagating the result of the quantifier application to the parent.  The cases for existential (\dedalus{exists}) and universal (\dedalus{forall}) quantifiers are clear.

\begin{Drules}
  \drule{var_sat_in(N, U, B)}
        {var_sat_left_in(V, B), var_succ(U, V)}
  \drule{var_sat_left_in(vn, 1)}
        {exists(vn), var_sat(_, vn, 1)}
  \drule{var_sat_left_in(vn, 0)}
        {exists(vn), var_sat(a, vn, 0), var_sat(b, vn, 0)}
  \drule{var_sat_left_in(vn_succ, 1)}
        {forall(vn), var_sat(a, vn, 1), var_sat(b, vn, 1)}
  \drule{var_sat_left_in(vn_succ, 0)}
        {forall(vn), var_sat(_, vn, false)}
\end{Drules}

Finally, the entire formula is \dedalus{satisfiable(1)} (satisfiable) if the output of the first quantifier is $1$, and \dedalus{satisfiable(0)} (unsatisfiable) if the output of the first quantifier is $0$.

\begin{Drules}
  \drule{satisfiable(B)}
        {var_sat_left_in(V, B), var_first(V)}
\end{Drules}
\end{proof}

\subsection{\large \bf \slang}

Distributed programs that produce nondeterministic outputs or have
runtimes exponential in their inputs are undesirable in practice.  Since testing
\lang programs to rule out these undesirable properties is undecidable in
general, we may instead ask whether a more constrained language will exclude
such programs while retaining the convenience of \lang.  We will present a
natural restriction of \lang that allows only confluent programs, and prove that
it captures exactly PTIME.

\begin{definition}
A \lang program is {\em IDB negation-free} if the \dedalus{!} symbol only appears on EDB relations in the program.
\end{definition}

\begin{definition}
A relation \dedalus{p} in a program $P$ is {\em simply persisted} if $P$ has the rule: \dedalus{p(\(\overline{\dedalus{X}}\))@next <- p(\(\overline{\dedalus{X}}\)).}
\end{definition}

\begin{definition}
A \lang program has {\em guarded asynchrony} if all relations appearing in the heads of asynchronous rules are simply persisted.
\end{definition}

We will refer to the language of IDB negation-free \lang programs with guarded asynchrony as \slang.  Define the notation \dedalus{f@t} to mean the spatio-temporal fact obtained from the spatial fact \dedalus{f} by substituting the constant \dedalus{t} for the timestamp. 

First we sill see that \slang programs are {\em inflationary} -- i.e., if a stable model of a \slang instance contains a spatio-temporal fact \dedalus{f@t}, then it also contains \dedalus{f@t+1} (and thus the ultimate model contains \dedalus{f}).

\begin{lemma}
\label{lem:inflationary}
\slang programs are {\em inflationary}, i.e. if a stable model of a \slang instance contains a spatio-temporal fact \dedalus{f@t}, then it also contains \dedalus{f@t+1} (and thus the ultimate model contains \dedalus{f}).
\end{lemma}
\begin{proof}
Consider a {\em derivation tree} for \dedalus{f@t}: a finite tree of instantiated (variable-free) rules.  Note that the instantiated head atom, as well as every instantiated body relation is a spatio-temporal fact (we assume that the derivation tree does not include nodes for \dedalus{time}, \dedalus{succ}, \dedalus{node}, \dedalus{<}, or \dedalus{choice}).  The tree's root is some instantiated rule with \dedalus{f@t} in its head.  A node has one child node for each body fact: the child node contains an instantiated rule with the fact in its head -- if the body fact is EDB, the corresponding node contains just only the fact, and is a leaf node.  The leaves of the tree are instantiated EDB facts.

For the moment, we assume that every fact has a unique derivation tree.  Multiple derivation trees are easy to handle -- simply repeat the following process for each tree.

If the relation of \dedalus{f} is EDB, or appears in the head of an asynchronous rule, then the lemma holds by definition of \slang.  Assume some stable model contains \dedalus{f@t} and not \dedalus{f@t+1}.  Thus, if the rule is inductive (resp. atemporal), then for some child of \dedalus{f@t}, call it \dedalus{g@t-1} (resp. \dedalus{g@t}), the fact \dedalus{g@t} (resp. \dedalus{g@t+1}) is not in the stable model.  Inductively proceed down the tree, at each step going to a node whose relation does not appear in the head of an asynchronous rule and which is not EDB.  However, the path will eventually terminate at a leaf (an EDB node) providing a contradiction, because EDB facts exist at all timesteps.
\end{proof}

A consequence of inflation is that all \slang programs are confluent.

\begin{theorem}
\label{thm:confluence}
\slang programs are confluent.
\end{theorem}
\begin{proof}

Towards a proof by contradiction, consider a \slang program that 
induces two ultimate models $\mathcal{U}_1, \mathcal{U}_2$ for some EDB.  There must be a spatial fact \dedalus{f}, such that 
$\dedalus{f} \in \mathcal{U}_1$ and $\dedalus{f} \not\in \mathcal{U}_2$.

Recall that if spatial fact \dedalus{f} is in some ultimate model, then for some $\dedalus{t\sub{0}} \in \mathbb{N}$, there is some stable model that contains \dedalus{f@t} for all \dedalus{t} > \dedalus{t\sub{0}}.

Consider a derivation tree for \dedalus{f@t\sub{0}} in any stable model that yields $\mathcal{U}_1$.  Again, for simplicity, we assume uniqueness of this derivation tree.  For some child of \dedalus{f@t\sub{0}}, call it \dedalus{g@s}, for all stable models that yield $\mathcal{U}_2$ there is no \dedalus{r} such that \dedalus{g@r} is in the stable model by Lemma~\ref{lem:inflationary}.  Continue traversing the tree, at each step picking such a \dedalus{g}.  Eventually, the traversal terminates at an EDB node, leading to a contradiction.
%If $a$ is derived directly from 
%$r$ via a series of derivation steps without any joins, then every stable
%model $m$ will have a tuple $a_m$ in $p$ that differs from $a$ only in its timestamp, 
%and hence correspond to the same ultimate model.
%Therefore, $a$ must have at least one join step (i.e., a rule with at least two subgoals)
%in its derivation following $r$,
%which succeeded in this stable model (producing $a$ or an antecedent of $a$), but did not succeed in another.  
%Guarded joins always
%eventually succeed, \jmh{don't you need to define ``join success'' and prove that guarded asynchrony does what you say?} what it and 
%Consider such  a join rule.  One of its subgoals $s$ corresponds to a derivation that depends
%on the async-derived atom $r$.  
%Regardless of the nondeterministic choice of timestamp for $r$, there
%is some timestamp $V_m$ in every stable model $m$ of the program such that $s$ is true
%for all $W > V$.  Hence in all stable models, $s$ is ``eventually'' true.  The same argument holds
%for all subgoals of the rule under consideration.
%Hence $a$ must exist in all ultimate models.
\end{proof}

An easy corollary is that we can fix some deterministic choice function, since all choice functions yield the same ultimate model.  In particular, we have:

\begin{corollary}
\label{cor:no-async}
Converting an asynchronous rule to an inductive rule in any \slang program preserves the ultimate model.
\end{corollary}

Of course, there are confluent \lang programs not in \slang.  For example:

\begin{example}
A confluent \lang program that is not a \slang program.

\begin{Drules}
\drule{b(#n1, I)@async}
      {b_edb(#L,I)}
\drule{b(I)@next}
      {b(I), !dequeued(I)}
\drule{b_lt(I, J)}
      {b(I), b(J), I < J}
\drule{dequeued(I)@next}
      {b(I), !b_lt(_, I)}
\drule{mem(I)}
      {dequeued(I), !bt_lt(_, _)}
\dfact{node(n1)}
\end{Drules}
\end{example}

Any instance of this program has a single ultimate model in which \dedalus{mem()} contains the highest element in \dedalus{b_edb()} according to the order \dedalus{<}.  Thus it is confluent, but the program uses IDB negation, and does not have guarded asynchrony.

Not only are \slang programs confluent, but they also capture exactly PTIME.  We will prove this by showing an equivalence to Datalog programs, which are known to capture exactly PTIME over ordered structures.

First, we note that it is clear that inductive rules can be converted into atemporal rules without effect to the ultimate model.

\begin{lemma}
\label{lem:no-inductive}
Any inductive rule can be converted into an atemporal rule -- except for the basic persistence rules for the head predicate of any asynchronous rule -- with no effect to the ultimate model.
\end{lemma}
\begin{proof}
Note that by Lemma~\ref{lem:inflationary}, converting inductive rules into atemporal rules -- except the basic persistence rules for asynchrony -- preserves inflation.  The proof proceeds similarly to the proof of Lemma~\ref{lem:inflationary} -- there is some fact in $\mathcal{U}_1$ but not $\mathcal{U}_2$; we consider a derivation tree for this fact in any stable model; it must be the case that some child fact of the parent does not appear in any stable model for $\mathcal{U}_2$ (by Lemma~\ref{lem:inflationary}).  We inductively repeat the proceduere, and discover that in order for a fact to have disappeared, the EDB must be different, which is a contradiction.
\end{proof}

%If either qualification is false, problems can result: Example~\ref{ex:diffluent1} shows a diffluent program with guarded asynchrony and IDB negation, and Example~\ref{ex:diffluent2} shows a diffluent program that is IDB-negation free but does not have guarded asynchrony.

\begin{theorem}
\slang programs capture exactly PTIME.
\end{theorem}
\begin{proof}
First we apply Corollary~\ref{cor:no-async} to rewrite asynchronous rules as inductive rules.  Then, we convert all inductive rules into atemporal rules using Lemma~\ref{lem:no-inductive}.  Note that this technically violates the causality constraint, but in practice, the ultimate model remains unchanged.  Since all rules are atemporal, there is a unique stable model, which is also the same for every timestamp.

Consider removing the timestamp attributes from all relations, and thus the \dedalus{time} relations from the bodies of all rules.  The result is a Datalog program with EDB negation.  The minimal model is exactly the ultimate model.

In the other direction, it is clear that we can encode any Datalog program with EDB negation in \slang using atemporal rules; the ultimate model coincides with the minimal model of the Datalog program.
\end{proof}

% \subsection{Monotonic Properties}
% XXX: Can we relax ``IDB negation free'' to be ``IDB positive''?


%This discussion formalizes the CALM Conjecture~\cite{declarative-imperative} with respect to confluence, and proves it in one direction. \todo{Tie this in with the CALM conjectu%re.}
%Clearly, there are confluent programs not in \slang.  For example:
