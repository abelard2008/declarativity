%%\section{\large \bf \slang}
\section{Refining \large \bf \lang}
\label{sec:confluence}

%Although \lang is a natural language for distributed systems, and it is easy to compactly specify complex distributed systems \wrm{cite something?}, \lang has several problems.
\lang can express a broad class of distributed systems but this flexibility comes at a cost.
As we have shown, it is easy to write programs that have multiple ultimate models, which intuitively means that the program has non-deterministic output.  \wrm{Also say something about non-trivial programs with an empty ultimate model.}
%as well as nontrivial programs with an empty ultimate model.
Such programs are rarely desired and may indicate a bug.
%\nrc{Dubious:
%  long-running services might well have no ultimate model according to this
%  formulation. Somewhere, we should probably concede that confluence, as formulated, is not
%  a general correctness criteria.}
% Commented out for now, because Dedalus_C doesn't model long-running services, as the entire EDB is assumed to be given at time 0.
%%First, the problem of multiple ultimate models, or no ultimate model, is a problem.  In practice, such programs are rarely desired and indeed often indicate a bug.  
We typically would like our distributed program to have a single output, regardless of any non-deterministic behavior within an execution.

Having defined the \lang language, we will refer to two running examples for the remainder of the paper.  

\begin{example}
\label{ex:marriage}
An asynchronous marriage ceremony:

\begin{Drules}
  \drule{groom_i_do()@async}
        {groom_i_do_edb()}
  \drule{bride_i_do()@async}
        {bride_i_do_edb()}
  \drule{runaway()}        {groom_i_do(), !bride_i_do()}  
  \drule{runaway()}        {!groom_i_do(), bride_i_do()}  
  \drule{runaway()@next}
        {runaway()}
  \drule{groom_i_do()@next}
        {groom_i_do()}
  \drule{bride_i_do()@next}
        {bride_i_do()}
\end{Drules}
\end{example}
Example~\ref{ex:marriage} presents a simple distributed voting program with a
fixed membership group: a bride and a groom.  The marriage is off
(\dedalus{runaway()} is true) if either party does not say ``I do.''

However, the \lang program as given does not correctly implement such a vote.
Any stable model where \dedalus{groom_i_do()} and \dedalus{bride_i_do()}
disagree in their first assignments of timestamps yields an ultimate model
containing \dedalus{runaway()}.  If the votes are assigned the same timestamp,
the ultimate model does not contain \dedalus{runaway()}. In operational terms,
this program exhibits a race condition: when the EDB contains ``I do'' votes
from both parties, the truth value of \dedalus{runaway()} depends on the times
at which the votes are delivered. Note that all predicates are
inflationary.

\begin{example}
\label{ex:gc}
Distributed garbage collection:

\begin{Drules}
  \drule{points_to_global(Master, Src, Dst)@async}
        {points_to(_, Src, Dst), master(Master)}
  \drule{reach(Src, Dst)}
        {points_to_global(Src, Dst)}
  \drule{reach(Src, Dst)}
        {points_to_global(Src, Nxt), reach(Src, Dst)}
  \drule{unreach(Ref)} 
        {ref(Ref), roots(Root), not reach(Root, Dst)}
  \drule{unreach(Ref)@next} {unreach(Ref)}
\end{Drules}
\end{example}
The program in Example~\ref{ex:gc} represents the control logic of a distributed garbage collection system for a separately managed
shared memory.  The \dedalus{points\_to} relation is partitioned across a set of nodes, each of which owns its own root pointer into
a reference tree.  Nodes forward the contents of their local \dedalus{points\_to} relation to a coordinator, who computes reachability
by taking the transitive closure of this relation.  Any memory reference not in the closure of \dedalus{points\_to\_global} is 
considered orphaned and may be garbage collected: we model this side-effecting computation by inserting into the immutably persistent
relation \dedalus{orphan}.

This more complicated example suffers from the same ambiguity as the marriage ceremony presented previously.  While the program has 
an ultimate model corresponding to executions in which \dedalus{unreach} is not computed until the transitive closure of 
\dedalus{points\_to\_global} is fully determined (i.e., after all messages have been delivered), it also has models corresponding to 
executions in which it is ``prematurely'' computed.  These models all result in correctness violations, in which active memory is reclaimed.

Note that in both examples, there is a single ultimate model corresponding to the execution in which the nonmonotonic negation
operator is not applied to a set until the set is fully determined.  This ``preferred'' model is akin to the perfect model computed
by a centralized Datalog evaluator that computes rules in stratum order~\cite{ullman}, applying the closed-world assumption to
predicates only when it is certain that they will no longer change.

In the remainder of this section, we explore the features of \lang that allow such ambiguities, and consider a restricted language \slang that
rules them out (but prohibits or complicates our implementations).  In Section~\ref{sec:perfect}, we consider a relaxation of \slang
that forces a single, ``preferred'' model.

\subsection{Problems with \large \bf \lang}

\begin{definition}
  A \lang program is {\em confluent} if, for every EDB instance, it has a single ultimate model.  A program that is not confluent is {\em diffluent}.
\end{definition}

%Confluence corresponds to the intuition that a program has a
%deterministic output set. Examples~\ref{ex:diffluent1} and \ref{ex:diffluent2}
%are two examples of diffluent programs.

Unfortunately, confluence is an undecidable property of \lang programs:

\begin{lemma}
\label{lem:confluence-undecidable}
Confluence of a \lang program is undecidable.
\end{lemma}
This is perhaps not a surprising result, as confluence is defined over all EDB instances.  We present a proof in the appendix.

%\wrm{Given undecidability, it would be great to have a restricted language that only allows us to write confluent stuff.}

Another problem is that \lang is too expressive -- it captures PSPACE.

\todo{Add some more intuition to this proof, and possibly move to appendix.}
\begin{lemma}
\label{lem:lang-pspace}
\lang captures PSPACE.
\end{lemma}
\begin{proof}
We show how to write the PSPACE-complete QBF problem in \lang.

Assuming the formula is in prenex normal form, the textbook recursive algorithm for QBF \paa{please cite} involves removing the first quantifier, and checking both $0$ and $1$ for the first variable.  If the first quantifier was existential, then we return true if QBF of one of the subformulas is true.  If the first quantifier was universal, then we return true if QBF of both of the subformulas is true.

If the quantifier depth is $n$, then it is clear that each leaf in the recursive call tree can be represented as an $n$-bit binary number.  If we assume that the left child is always $0$ and the right child $1$, then we can view the algorithm as a postorder traversal of the recursive call tree.

First, we iterate through all of the $n$-bit binary numbers, one per timestamp.  We assume that the order over the variables is such that the leftmost variable in the formula (the high-order bit) is the first, and the rightmost is the last.  Thus, our addition is ``backwards'' in that it propagates carries to the predecessors:

\begin{Drules}
  \drule{carry(V)}
        {var_last(V)}
  \drule{one(V)@next}
        {carry(V), !one(V)}
  \drule{one(V)@next}
        {one(V), !carry(V)}
  \drule{carry(U)}
        {carry(V), one(V), var_succ(U, V)}
\end{Drules}

At each timestep, we check whether the current variable assignment is true.  If it is true, then \dedalus{formula_true()} is true at that timestep.  We omit these rules, because it is clear that a suitable encoding for the first-order formula can be devised, and first-order satisfiability can be checked.

We propagate truth information up the recursive call tree.  A node sets its value to $1$ (representing ``true'') if the quantifier associated with that node is existential and at least one of its children is has value $1$, or the quantifier is universal and both of its children have value $1$.  A node sets its value as $0$ otherwise.  If the root is set to $1$, the formula is satisfiable, otherwise it is not.

\begin{Drules}
  \drule{var_sat_in(V, 1)}
        {formula_true(), var_last(V)}
  \drule{var_sat(0, V, B)@next}
        {var_sat_in(V, B), !var_sat(_, V, _)}
  \drule{var_sat(1, V, B)@next}
        {var_sat_in(V, B), var_sat(0, V, _).}
\end{Drules}

\begin{Drules}
  \drule{var_sat_left_in(vn, 1)}
        {exists(vn), var_sat(_, vn, 1)}
  \drule{var_sat_left_in(vn, 0)}
        {exists(vn), var_sat(0, vn, 0), var_sat(1, vn, 0)}
\end{Drules}

\begin{Drules}
  \drule{var_sat_left_in(vn_succ, 1)}
        {forall(vn), var_sat(0, vn, 1), var_sat(1, vn, 1)}
  \drule{var_sat_left_in(vn_succ, 0)}
        {forall(vn), var_sat(_, vn, false)}
\end{Drules}

\begin{Drules}
  \drule{var_sat_in(N, U, B)}
        {var_sat_left_in(V, B), var_succ(U, V)}
\end{Drules}

\begin{Drules}
  \drule{var_sat(N, V, B)@next}
        {var_sat(N, V, B), !var_sat(1, V, _)}
\end{Drules}

\begin{Drules}
  \drule{satisfiable(B)}
        {var_sat_left_in(V, B), var_last(V)}
\end{Drules}
\end{proof}

Distributed programs that produce nondeterministic outputs or have
runtimes exponential in their inputs are undesirable in practice.  Since testing
\lang programs to rule out these undesirable properties is undecidable in
general, we may instead ask whether a more constrained language will exclude
such programs while retaining the convenience of \lang.  We will present a
natural restriction of \lang that allows only confluent programs, and prove that
it captures exactly PTIME.

\begin{definition}
A \lang program is {\em IDB negation-free} if the \dedalus{!} symbol only appears on EDB relations in the program.
\end{definition}

\begin{definition}
A relation \dedalus{p} in a program $P$ is {\em simply persisted} if $P$ has the rule: \dedalus{p(\(\overline{\dedalus{X}}\))@next <- p(\(\overline{\dedalus{X}}\)).}
\end{definition}

\begin{definition}
A \lang program has {\em guarded asynchrony} if all relations appearing in the heads of asynchronous rules are simply persisted.
\end{definition}

We will refer to the language of IDB negation-free \lang programs with guarded asynchrony as \slang.

Define the notation \dedalus{f@t} to mean the spatio-temporal fact obtained from the spatial fact \dedalus{f} by substituting the constant \dedalus{t} for the timestamp.

\begin{lemma}
\label{lem:inflationary}
\slang programs are {\em inflationary}, i.e. if a stable model of a \slang instance contains a spatio-temporal fact \dedalus{f@t}, then it also contains \dedalus{f@t+1} (and thus the ultimate model contains \dedalus{f}).
\end{lemma}
\begin{proof}
Consider a {\em derivation tree} for \dedalus{f@t}: a finite tree of instantiated (variable-free) rules.  Note that the instantiated head atom, as well as every instantiated body relation is a spatio-temporal fact (we assume that the derivation tree does not include nodes for \dedalus{time}, \dedalus{succ}, \dedalus{node}, \dedalus{<}, or \dedalus{choice}).  The tree's root is some instantiated rule with \dedalus{f@t} in its head.  A node has one child node for each body fact: the child node contains an instantiated rule with the fact in its head -- if the body fact is EDB, the corresponding node contains just only the fact, and is a leaf node.  The leaves of the tree are instantiated EDB facts.

For the moment, we assume that every fact has a unique derivation tree.  Multiple derivation trees are easy to handle -- simply repeat the following process for each tree.

If the relation of \dedalus{f} is EDB, or appears in the head of an asynchronous rule, then the lemma holds by definition of \slang.  Assume some stable model contains \dedalus{f@t} and not \dedalus{f@t+1}.  Thus, if the rule is inductive (resp. atemporal), then for some child of \dedalus{f@t}, call it \dedalus{g@t-1} (resp. \dedalus{g@t}), the fact \dedalus{g@t} (resp. \dedalus{g@t+1}) is not in the stable model.  Inductively proceed down the tree, at each step going to a node whose relation does not appear in the head of an asynchronous rule and which is not EDB.  However, the path will eventually terminate at a leaf (an EDB node) providing a contradiction, because EDB facts exist at all timesteps.
\end{proof}


\begin{theorem}
\label{thm:confluence}
\slang programs are confluent.
\end{theorem}
\begin{proof}

Towards a proof by contradiction, consider a \slang program that 
induces two ultimate models $\mathcal{U}_1, \mathcal{U}_2$ for some EDB.  There must be a spatial fact \dedalus{f}, such that 
$\dedalus{f} \in \mathcal{U}_1$ and $\dedalus{f} \not\in \mathcal{U}_2$.

Recall that if spatial fact \dedalus{f} is in some ultimate model, then for some $\dedalus{t\sub{0}} \in \mathbb{N}$, there is some stable model that contains \dedalus{f@t} for all \dedalus{t} > \dedalus{t\sub{0}}.

Consider a derivation tree for \dedalus{f@t\sub{0}} in any stable model that yields $\mathcal{U}_1$.  Again, for simplicity, we assume uniqueness of this derivation tree.  For some child of \dedalus{f@t\sub{0}}, call it \dedalus{g@s}, for all stable models that yield $\mathcal{U}_2$ there is no \dedalus{r} such that \dedalus{g@r} is in the stable model by Lemma~\ref{lem:inflationary}.  Continue traversing the tree, at each step picking such a \dedalus{g}.  Eventually, the traversal terminates at an EDB node, leading to a contradiction.
%If $a$ is derived directly from 
%$r$ via a series of derivation steps without any joins, then every stable
%model $m$ will have a tuple $a_m$ in $p$ that differs from $a$ only in its timestamp, 
%and hence correspond to the same ultimate model.
%Therefore, $a$ must have at least one join step (i.e., a rule with at least two subgoals)
%in its derivation following $r$,
%which succeeded in this stable model (producing $a$ or an antecedent of $a$), but did not succeed in another.  
%Guarded joins always
%eventually succeed, \jmh{don't you need to define ``join success'' and prove that guarded asynchrony does what you say?} what it and 
%Consider such  a join rule.  One of its subgoals $s$ corresponds to a derivation that depends
%on the async-derived atom $r$.  
%Regardless of the nondeterministic choice of timestamp for $r$, there
%is some timestamp $V_m$ in every stable model $m$ of the program such that $s$ is true
%for all $W > V$.  Hence in all stable models, $s$ is ``eventually'' true.  The same argument holds
%for all subgoals of the rule under consideration.
%Hence $a$ must exist in all ultimate models.
\end{proof}


If either qualification is false, problems can result: Example~\ref{ex:diffluent1} shows a diffluent program with guarded asynchrony and IDB negation, and Example~\ref{ex:diffluent2} shows a diffluent program that is IDB-negation free but does not have guarded asynchrony.

\todo{Bill to improve this proof.}
\begin{theorem}
\slang programs capture exactly PTIME.
\end{theorem}
\begin{proof}
We will show how to convert any \slang program to an FO[IFP] formula, and how to convert any FO[IFP] formula to a \slang program.  It is known that FO[IFP] captures exactly PTIME over ordered structures~\cite{immerman-ptime}.

First, it is obvious that the non-determinism of \dedalus{choice} does not increase the expressive power of \slang, because all \slang programs are confluent by Theorem~\ref{thm:confluence}.  Thus, the temporal annotations on all asynchronous rules may be changed to \dedalus{@next}; the rewritten program computes the same ultimate model.  \wrm{But, technically this violates the condition that only async rules can have different location specifiers in the head than the body.}

It is is clear that \slang is inflationary.  We would like the timestamps of a \slang program to correspond with the iterations of an FO[IFP] formula.  However, \slang timestamps may contain recursion.  We can rewrite a \slang program so that the timestamps are first order.  \todo{Figure out how exactly I want to show this.  Think hard about recursion through universal quantification, as well as stratified negation.}

\slang admits a least fixpoint in each iteration; we need to show we can rewrite this formula to an inflationary fixpoint formula.  \wrm{But we can rewrite the least fixpoint as an FO[IFP] formula, and nesting of inflationary fixpoints does not increase expressive power -- citation?}

Thus, we can convert a \slang program into an FO[IFP] formula.

We can convert any FO[IFP] formula into a \slang program by pushing negation down to the EDB by applying negation pushdown results for FO[LFP] from~\cite{immerman-ptime}.  \todo{Clafiry w/ Neil I. about whether this pushdown uses universal quantification.  This isn't essential though, we can just convert any FO[IFP] formula into a turing machine, and re-express the turing machine in \slang.}

\wrm{Also, we probably should explain how to convert between FO[IFP] and ``rule form''?}
\end{proof}

% \subsection{Monotonic Properties}
% XXX: Can we relax ``IDB negation free'' to be ``IDB positive''?


This discussion formalizes the CALM Conjecture mentioned above with respect to confluence, and proves it in one direction. \todo{Tie this in with the CALM conjecture.}
Clearly, there are confluent programs not in \slang.  For example:

\begin{example}
A confluent \lang program that is not a \slang program.

\todo{check example with rule sugaring guidelines in foundation}

\begin{Drules}
\drule{b(#n1, I)@async}
      {b_edb(#L,I)}
\drule{b(I)@next}
      {b(I), !dequeued(I)}
\drule{b_lt(I, J)}
      {b(I), b(J), I < J}
\drule{dequeued(I)@next}
      {b(I), !b_lt(_, I)}
\drule{mem(I)}
      {dequeued(I), !bt_lt(_, _)}
\dfact{node(n1)}
\end{Drules}
\end{example}

Any instance of this program has a single ultimate model in which \dedalus{mem()} contains the highest element in \dedalus{b_edb()} according to the order \dedalus{<}.
Thus it is confluent, but the program uses IDB negation, and does not have guarded asynchrony.



