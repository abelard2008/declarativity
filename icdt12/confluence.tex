\section{\slang}
\label{sec:confluence}

Although \lang is a natural language for distributed systems, and it is easy to compactly specify complex distributed systems \wrm{cite something?}, \lang has several problems.

First, it is easy to write programs with non-deterministic output (multiple ultimate models), \paa{though in practice such programs are rarely desired and indeed often indicate a bug (or something like that)}.

%Recall that nondeterminism in \lang only arises due to \dedalus{choice} in asynchronous rules, 
%which only occurs in asynchronous rules to model network nondeterminism.  
%which model temporal nondeterminism in unreliable networks.
%Model-theoretically, a nondeterministic result is manifest in multiple ultimate models.

\begin{definition}
A \lang program is {\em confluent} (has a deterministic output) if, for every instance of the program, it has a unique ultimate model.  A program that is not confluent is {\em diffluent}.
\end{definition}

Two examples of diffluent programs:

\begin{Dedalus}
output p.
q()@async <- q_edb();
r()@async <- r_edb();
p() <- q(), !r();
q()@next <- q();
r()@next <- r();
\end{Dedalus}

Assume an EDB of \dedalus{q\_edb(), r\_edb()}.  Any stable model where \dedalus{q()} has a lower timestamp than \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.  \wrm{The problem here is negation}.

\begin{Dedalus}
output p.
q()@async <- q_edb();
r()@async <- r_edb();
p() <- q(), r();
q()@next <- q();
\end{Dedalus}

As before, assume an EDB of \dedalus{q\_edb(), r\_edb()}.  Any stable model where the timestamp of \dedalus{q()} is less than or equal to the timestamp of \dedalus{r()} yields an ultimate model containing \dedalus{p()}.  Otherwise, the ultimate model does not contain \dedalus{p()}.
%However, this example becomes confluent if we admit the last rule of Example~\ref{ex:nonconfluent2}: \dedalus{r()@next <- r();}.

\wrm{these examples show the only things that can cause non-confluence}

Unfortunately, confluence is an undecidable property of \lang programs:

\begin{lemma}
\label{lem:confluence-undecidable}
Confluence of a \lang program is undecidable.
\end{lemma}
\begin{proof}
Using the construction in~\cite{undecidable-datalog}, it is possible to write a Datalog program that encodes any two-counter machine's transition relation and an arbitrarily long finite successor relation in the EDB, and define a 0-ary output predicate \dedalus{accept} that is true if and only if the two-counter machine accepts and the transition and successor relations are valid.  As the construction is possible in Datalog, it is also possible in Dedalus.

We add the following rules to the construction, to nondeterministically decide whether to run the machine or not:

\begin{Dedalus}
message(0)@async.
message(1)@async.

run_machine() <- message(0), message(1).
accept() <- message(0), !message(1), input_valid().
accept() <- !message(0), message(1), input_valid().
\end{Dedalus}

Note that the first two lines are actually rules.  The unsugared form of the first rule is \dedalus{message(L,S,0) <- node(L), time(T), time(S), T < S, choice((L, T, 0), (S)).}

For valid inputs, the ultimate model is ${\dedalus{accept()}}$ if and only if either \dedalus{message(0)} and \dedalus{message(1)} are assigned the same timestamp and the machine accepts, or if the timestamps are different.  For invalid inputs, all ultimate models are empty.

If we could decide confluence for this program, we could decide whether there is any valid input for which an arbitrary two-counter machine halts in an accepting state.
\end{proof}

\wrm{Given undecidability, it would be great to have a restricted language that only allows us to write confluent stuff.}

Another problem is that \lang is too expressive -- it captures PSPACE as shown by the following Lemma.

\begin{lemma}
\label{lem:lang-pspace}
\lang captures PSPACE.
\end{lemma}
\begin{proof}
We show how to write QBF in Dedalus.

Assuming the formula is in prenex normal form, the textbook recursive algorithm for QBF \paa{please cite} involves removing the first quantifier, and checking both $0$ and $1$ for the first variable.  If the first quantifier was existential, then we return true if QBF of one of the subformulas is true.  If the first quantifier was universal, then we return true if QBF of both of the subformulas is true.

If the quantifier depth is $n$, then it is clear that each leaf in the recursive call tree can be represented as an $n$-bit binary number.  If we assume that the left child is always $0$ and the right child $1$, then we can view our algorithm as a postorder traversal of the recursive call tree.

First, we iterate through all of the $n$-bit binary numbers, one per timestamp.  We assume that the order over the variables is such that the leftmost variable in the formula (the high-order bit) is the first, and the rightmost is the last.  Thus, our addition is ``backwards'' in that it propagates carries to the predecessors:

\begin{Dedalus}
carry(V) <- var_last(V).
one(V)@next <- carry(V), !one(V).
one(V)@next <- one(V), !carry(V).
carry(U) <- carry(V), one(V), var_succ(U, V).
\end{Dedalus}

At each timestep, we check whether the current variable assignment is true.  If it is true, then \dedalus{formula\_true()} is true at that timestep.  We omit these rules.

We propagate truth information up the recursive call tree.  A node propagates a $1$ to its parent if the quantifier associated with that node is existential and at least one of its children is true, or the quantifier is universal and both of its children are true.  A node propagates a $0$ to its parent otherwise.  If the output of the root is $1$, the formula is satisfiable, otherwise it is not: \wrm{more explanation here}

\begin{Dedalus}
var_sat_in(V, 1) <- formula_true(), var_last(V).

var_sat(0, V, B)@next <- var_sat_in(V, B),
!var_sat(_, V, _).
var_sat(1, V, B)@next <- var_sat_in(V, B),
var_sat(0, V, _).

// existential quantifier
var_sat_left_in(vn, 1) <- exists(vn),
var_sat(_, vn, 1).
var_sat_left_in(vn, 0) <- exists(vn),
var_sat(0, vn, 0), var_sat(1, vn, 0).

// universal quantifier
var_sat_left_in(vn_succ, 1) <- forall(vn),
var_sat(0, vn, 1), var_sat(1, vn, 1).
var_sat_left_in(vn_succ, 0) <- forall(vn),
var_sat(_, vn, false).

var_sat_in(N, U, B) <- var_sat_left_in(V, B),
var_succ(U, V).

// persist var_sat until we get 2 of them
var_sat(N, V, B)@next <- var_sat(N, V, B),
!var_sat(1, V, _);

// the output of the last 
satisfiable(B) <- var_sat_left_in(V, B), var_last(V).
\end{Dedalus}
\end{proof}


\wrm{We will present a natural restriction of \lang that is confluent, and prove that it captures exactly PTIME.  Negation free, and guarded asynchrony.}
\wrm{DON'T FORGET UNIVERSAL QUANTIFIERS -- easy, use order, what about recursion thru universal quantification?}


\begin{definition}
A \lang program is {\em IDB negation-free} if the \dedalus{!} symbol only appears on EDB relations in the program.
\end{definition}

\begin{definition}
A relation \dedalus{r} in a program $P$ is {\em simply persisted} if $P$ has the rule: \dedalus{p(\(\overline{\dedalus{X}}\))@next <- p(\(\overline{\dedalus{X}}\)).}
\end{definition}

\begin{definition}
A \lang program has {\em guarded asynchrony} if all relations appearing in the heads of asynchronous rules are simply persisted.
\end{definition}

We will refer to the language of IDB negation-free \lang programs with guarded asynchrony as \slang.

\wrm{Peter to improve}
\begin{theorem}
\label{thm:confluence}
\slang programs are confluent.
\end{theorem}
\begin{proof}

Towards a proof by contradiction, consider a negation-free \lang program that 
induces more than one ultimate model.  There must be a ground atom $a$ for a predicate $p$
that is true in one but
not in another model, and $a$ must be persistent, or it would not be
in the ultimate model.  Consider a derivation of $a$: a finite tree of applications of
implication whose leaves are EDB atoms.  If none of the implications involve a nondeterministic
choice of timestamp via an {\em async} rule, then certainly 
$a$ occurs in all stable models of the program,
%there is only one stable model of the program
%\jmh{I don't buy this; we're scoped down to atom $a$ here and the rules that feed into it}, 
so there must be at least one {\em async} rule in $a$'s derivation, contributing an atom
$r$.  
If $p$ is derived directly from 
$r$ via a series of derivation steps without any joins, then every stable
model $m$ will have a tuple $a_m$ in $p$ that differs from $a$ only in its timestamp, 
and hence correspond to the same ultimate model.
Therefore, $a$ must have at least one join step (i.e., a rule with at least two subgoals)
in its derivation following $r$,
which succeeded in this stable model (producing $a$), but did not succeed in another.  
%Guarded joins always
%eventually succeed, \jmh{don't you need to define ``join success'' and prove that guarded asynchrony does what you say?} what it and 

Consider such  a join rule.  One of its subgoals $s$ corresponds to a derivation that depends
on the async-derived atom $r$.  If any predicate between $s$ and $r$ is simply persisted and 
the program is negation-free,
then $s$ is persistent.  Regardless of the nondeterministic choice of timestamp for $r$, there
is some timestamp $V_m$ in every stable model $m$ of the program such that $s$ is true
for all $W > V$.  Hence in all stable models, $s$ is ``eventually'' true.  The same argument holds
for all subgoals of the rule under consideration, and hence guarded asynchrony implies that
all joins will eventually succeed.
Hence $a$ must exist in all ultimate models.
\end{proof}


If either qualification is false, problems can result, as we have previously illustrated.

\wrm{improve the diction here}
\begin{theorem}
\slang programs capture exactly PTIME.
\end{theorem}
\begin{proof}
We will show how to convert any \slang program to an FO[IFP] formula, and how to convert any FO[IFP] formula to a \slang program.  It is known that FO[IFP] captures exactly PTIME over ordered structures \wrm{cite}.

Since \slang has only EDB negation, we first show that in any FO[IFP] formula, negation can be pushed down to the EDB.  This is not hard to show.  Since FO[IFP] has a negation normal form where negation only applies to atoms \wrm{cite}, we can always push negation down through quantifiers and boolean operators using the usual DeMorgan dualities.  \wrm{Universal quantifiers are expressed like...}

Since \slang admits a least fixpoint in each iteration, we need to show we can rewrite this formula to an inflationary fixpoint formula.  \wrm{But we can rewrite the least fixpoint as an FO[IFP] formula, and nesting of inflationary fixpoints does not increase expressive power -- citation?}

We need to show that non-determinism does not increase expressive power.  Clearly it does not because all ultimate models are equivalent in \slang, so in particular, we could correctly compute the unique ultimate model of any \slang program deterministically by replacing \dedalus{@async} with \dedalus{@next}.

Thus, we can convert a \slang program into an FO[IFP] formula. \wrm{need to say something about simultaneous inductions, blah blah?}.

We can convert any FO[IFP] formula with only EDB negation into a \slang program by converting it into rule form \wrm{i.e. splitting up each disjunct into a rule, rewrite universal quantification using order, etc.}.
\end{proof}

% \subsection{Monotonic Properties}
% XXX: Can we relax ``IDB negation free'' to be ``IDB positive''?


This discussion formalizes the CALM Conjecture mentioned above with respect to confluence, and proves it in one direction.
Clearly, there are confluent programs not in \slang.  For example:

\begin{example}
A confluent \lang program that is not a \slang program.

\todo{check example with rule sugaring guidelines in foundation}

\begin{Dedalus}
//client
b(#S, I)@async :- b_edb(I), server(S);

//server
b(I)@next <- b(I), !dequeued(I);
b_lt(I, J) <- b(I), b(J), I < J;
dequeued(I)@next <- b(I), !b_lt(_, I);
mem(I) <- dequeued(I), !bt_lt(_, _);

\end{Dedalus}
\end{example}

This program has a single ultimate model in which \dedalus{mem()} contains the highest
element in \dedalus{b\_edb()} according to the order \dedalus{<}.
Thus it is confluent, but the program uses negation, and \dedalus{b} is not simply persisted.


\subsection{Perfect Ultimate Model}

Thus, we should allow negation back into logic programs.  

\subsection{Connection with Practice}

\wrm{Connect stratification with coordination protocols used in practice in distributed systems.}


