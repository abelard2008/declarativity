\section{\large \bf \slang}
\label{sec:confluence}

%Although \lang is a natural language for distributed systems, and it is easy to compactly specify complex distributed systems \wrm{cite something?}, \lang has several problems.
\lang can express a broad class of distributed systems but this flexibility comes at a cost.
As we have shown, it is easy to write programs that have multiple ultimate models, which intuitively means that the program has non-deterministic output.  \wrm{Also say something about non-trivial programs with an empty ultimate model.}
%as well as nontrivial programs with an empty ultimate model.
Such programs are rarely desired and may indicate a bug.
%\nrc{Dubious:
%  long-running services might well have no ultimate model according to this
%  formulation. Somewhere, we should probably concede that confluence, as formulated, is not
%  a general correctness criteria.}
% Commented out for now, because Dedalus_C doesn't model long-running services, as the entire EDB is assumed to be given at time 0.
%%First, the problem of multiple ultimate models, or no ultimate model, is a problem.  In practice, such programs are rarely desired and indeed often indicate a bug.  
We typically would like our distributed program to have a single output, regardless of any non-deterministic behavior within an execution.

\begin{definition}
  A \lang program is {\em confluent} if, for every EDB instance, it has a single ultimate model.  A program that is not confluent is {\em diffluent}.
\end{definition}

%Confluence corresponds to the intuition that a program has a
%deterministic output set. Examples~\ref{ex:diffluent1} and \ref{ex:diffluent2}
%are two examples of diffluent programs.

Unfortunately, confluence is an undecidable property of \lang programs:

\begin{lemma}
\label{lem:confluence-undecidable}
Confluence of a \lang program is undecidable.
\end{lemma}
This is perhaps not a surprising result, as confluence is defined over all EDB instances.  We present a proof in the appendix.

%\wrm{Given undecidability, it would be great to have a restricted language that only allows us to write confluent stuff.}

Another problem is that \lang is too expressive -- it captures PSPACE.

\todo{Add some more intuition to this proof, and possibly move to appendix.}
\begin{lemma}
\label{lem:lang-pspace}
\lang captures PSPACE.
\end{lemma}
\begin{proof}
We show how to write the PSPACE-complete QBF problem in \lang.

Assuming the formula is in prenex normal form, the textbook recursive algorithm for QBF \paa{please cite} involves removing the first quantifier, and checking both $0$ and $1$ for the first variable.  If the first quantifier was existential, then we return true if QBF of one of the subformulas is true.  If the first quantifier was universal, then we return true if QBF of both of the subformulas is true.

If the quantifier depth is $n$, then it is clear that each leaf in the recursive call tree can be represented as an $n$-bit binary number.  If we assume that the left child is always $0$ and the right child $1$, then we can view the algorithm as a postorder traversal of the recursive call tree.

First, we iterate through all of the $n$-bit binary numbers, one per timestamp.  We assume that the order over the variables is such that the leftmost variable in the formula (the high-order bit) is the first, and the rightmost is the last.  Thus, our addition is ``backwards'' in that it propagates carries to the predecessors:

\begin{Drules}
  \drule{carry(V)}
        {var_last(V)}
  \drule{one(V)@next}
        {carry(V), !one(V)}
  \drule{one(V)@next}
        {one(V), !carry(V)}
  \drule{carry(U)}
        {carry(V), one(V), var_succ(U, V)}
\end{Drules}

At each timestep, we check whether the current variable assignment is true.  If it is true, then \dedalus{formula_true()} is true at that timestep.  We omit these rules, because it is clear that a suitable encoding for the first-order formula can be devised, and first-order satisfiability can be checked.

We propagate truth information up the recursive call tree.  A node sets its value to $1$ (representing ``true'') if the quantifier associated with that node is existential and at least one of its children is has value $1$, or the quantifier is universal and both of its children have value $1$.  A node sets its value as $0$ otherwise.  If the root is set to $1$, the formula is satisfiable, otherwise it is not.

\begin{Drules}
  \drule{var_sat_in(V, 1)}
        {formula_true(), var_last(V)}
  \drule{var_sat(0, V, B)@next}
        {var_sat_in(V, B), !var_sat(_, V, _)}
  \drule{var_sat(1, V, B)@next}
        {var_sat_in(V, B), var_sat(0, V, _).}
\end{Drules}

\begin{Drules}
  \drule{var_sat_left_in(vn, 1)}
        {exists(vn), var_sat(_, vn, 1)}
  \drule{var_sat_left_in(vn, 0)}
        {exists(vn), var_sat(0, vn, 0), var_sat(1, vn, 0)}
\end{Drules}

\begin{Drules}
  \drule{var_sat_left_in(vn_succ, 1)}
        {forall(vn), var_sat(0, vn, 1), var_sat(1, vn, 1)}
  \drule{var_sat_left_in(vn_succ, 0)}
        {forall(vn), var_sat(_, vn, false)}
\end{Drules}

\begin{Drules}
  \drule{var_sat_in(N, U, B)}
        {var_sat_left_in(V, B), var_succ(U, V)}
\end{Drules}

\begin{Drules}
  \drule{var_sat(N, V, B)@next}
        {var_sat(N, V, B), !var_sat(1, V, _)}
\end{Drules}

\begin{Drules}
  \drule{satisfiable(B)}
        {var_sat_left_in(V, B), var_last(V)}
\end{Drules}
\end{proof}

Distributed programs that produce nondeterministic outputs or have
runtimes exponential in their inputs are undesirable in practice.  Since testing
\lang programs to rule out these undesirable properties is undecidable in
general, we may instead ask whether a more constrained language will exclude
such programs while retaining the convenience of \lang.  We will present a
natural restriction of \lang that allows only confluent programs, and prove that
it captures exactly PTIME.

\begin{definition}
A \lang program is {\em IDB negation-free} if the \dedalus{!} symbol only appears on EDB relations in the program.
\end{definition}

\begin{definition}
A relation \dedalus{p} in a program $P$ is {\em simply persisted} if $P$ has the rule: \dedalus{p(\(\overline{\dedalus{X}}\))@next <- p(\(\overline{\dedalus{X}}\)).}
\end{definition}

\begin{definition}
A \lang program has {\em guarded asynchrony} if all relations appearing in the heads of asynchronous rules are simply persisted.
\end{definition}

We will refer to the language of IDB negation-free \lang programs with guarded asynchrony as \slang.

\todo{Peter to improve this proof.}
\begin{theorem}
\label{thm:confluence}
\slang programs are confluent.
\end{theorem}
\begin{proof}

Towards a proof by contradiction, consider a \slang program that 
induces more than one ultimate model.  There must be a ground atom $a$ for a predicate $p$
that is true in one but
not in another model, and $p$ must be persistent, or $a$ it would not be
in the ultimate model.  Consider a derivation of $a$: a finite tree of applications of
implication whose leaves are EDB atoms.  If none of the implications involve a nondeterministic
choice of timestamp via an {\em async} rule, then certainly 
$a$ occurs in all stable models of the program,
%there is only one stable model of the program
%\jmh{I don't buy this; we're scoped down to atom $a$ here and the rules that feed into it}, 
so there must be at least one {\em async} rule in $a$'s derivation, contributing an atom
$r$.  
If $p$ is derived directly from 
$r$ via a series of derivation steps without any joins, then every stable
model $m$ will have a tuple $a_m$ in $p$ that differs from $a$ only in its timestamp, 
and hence correspond to the same ultimate model.
Therefore, $a$ must have at least one join step (i.e., a rule with at least two subgoals)
in its derivation following $r$,
which succeeded in this stable model (producing $a$), but did not succeed in another.  
%Guarded joins always
%eventually succeed, \jmh{don't you need to define ``join success'' and prove that guarded asynchrony does what you say?} what it and 

Consider such  a join rule.  One of its subgoals $s$ corresponds to a derivation that depends
on the async-derived atom $r$.  If any predicate between $s$ and $r$ is simply persisted and 
the program is negation-free,
then $s$ is persistent.  Regardless of the nondeterministic choice of timestamp for $r$, there
is some timestamp $V_m$ in every stable model $m$ of the program such that $s$ is true
for all $W > V$.  Hence in all stable models, $s$ is ``eventually'' true.  The same argument holds
for all subgoals of the rule under consideration, and hence guarded asynchrony implies that
all joins will eventually succeed.
Hence $a$ must exist in all ultimate models.
\end{proof}


If either qualification is false, problems can result: Example~\ref{ex:diffluent1} shows a diffluent program with guarded asynchrony and IDB negation, and Example~\ref{ex:diffluent2} shows a diffluent program that is IDB-negation free but does not have guarded asynchrony.

\todo{Bill to improve this proof.}
\begin{theorem}
\slang programs capture exactly PTIME.
\end{theorem}
\begin{proof}
We will show how to convert any \slang program to an FO[IFP] formula, and how to convert any FO[IFP] formula to a \slang program.  It is known that FO[IFP] captures exactly PTIME over ordered structures~\cite{immerman-ptime}.

First, it is obvious that the non-determinism of \dedalus{choice} does not increase the expressive power of \slang, because all \slang programs are confluent by Theorem~\ref{thm:confluence}.  Thus, the temporal annotations on all asynchronous rules may be changed to \dedalus{@next}; the rewritten program computes the same ultimate model.  \wrm{But, technically this violates the condition that only async rules can have different location specifiers in the head than the body.}

It is is clear that \slang is inflationary.  We would like the timestamps of a \slang program to correspond with the iterations of an FO[IFP] formula.  However, \slang timestamps may contain recursion.  We can rewrite a \slang program so that the timestamps are first order.  \todo{Figure out how exactly I want to show this.  Think hard about recursion through universal quantification, as well as stratified negation.}

\slang admits a least fixpoint in each iteration; we need to show we can rewrite this formula to an inflationary fixpoint formula.  \wrm{But we can rewrite the least fixpoint as an FO[IFP] formula, and nesting of inflationary fixpoints does not increase expressive power -- citation?}

Thus, we can convert a \slang program into an FO[IFP] formula.

We can convert any FO[IFP] formula into a \slang program by pushing negation down to the EDB by applying negation pushdown results for FO[LFP] from~\cite{immerman-ptime}.  \todo{Clafiry w/ Neil I. about whether this pushdown uses universal quantification.  This isn't essential though, we can just convert any FO[IFP] formula into a turing machine, and re-express the turing machine in \slang.}

\wrm{Also, we probably should explain how to convert between FO[IFP] and ``rule form''?}
\end{proof}

% \subsection{Monotonic Properties}
% XXX: Can we relax ``IDB negation free'' to be ``IDB positive''?


This discussion formalizes the CALM Conjecture mentioned above with respect to confluence, and proves it in one direction. \todo{Tie this in with the CALM conjecture.}
Clearly, there are confluent programs not in \slang.  For example:

\begin{example}
A confluent \lang program that is not a \slang program.

\todo{check example with rule sugaring guidelines in foundation}

\begin{Drules}
\drule{b(#n1, I)@async}
      {b_edb(#L,I)}
\drule{b(I)@next}
      {b(I), !dequeued(I)}
\drule{b_lt(I, J)}
      {b(I), b(J), I < J}
\drule{dequeued(I)@next}
      {b(I), !b_lt(_, I)}
\drule{mem(I)}
      {dequeued(I), !bt_lt(_, _)}
\dfact{node(n1)}
\end{Drules}
\end{example}

Any instance of this program has a single ultimate model in which \dedalus{mem()} contains the highest element in \dedalus{b_edb()} according to the order \dedalus{<}.
Thus it is confluent, but the program uses IDB negation, and does not have guarded asynchrony.

\subsection{Perfect Ultimate Model}

\todo{Put in running example here.}

\paa{we need some transition text here.  dedalus-c is nice, but as we remember from datalog ;) IDB negation makes it easier to write programs (should be easy to give an example).  can we get some IDB negation back
without sacrificing what's we've gained going to dedalus-c?}

There is a usage of negation that is both intuitive and corresponds to distributed systems practices.  Negation is not applied until the negated relation is ``done'' being computed.  Formally, if a rule body in program $P$ contains a negated atom \dedalus{!p()}, the rule body must also contain an atom \dedalus{p_done()}.  The relation \dedalus{p_done()} has the property that in any stable model $\mathcal{S}$ if $\dedalus{done_p(l,t)} \in \mathcal{S}$,  then $\dedalus{done_p(l,s)} \in \mathcal{S}$ for all timestamps $\dedalus{s} > \dedalus{t}$.  Furthermore, if $\dedalus{done_p(l,t)} \in \mathcal{S}$, then $\dedalus{p(l,t,c\sub{1},\ldots,c\sub{n})} \in \mathcal{S}$ implies that $\dedalus{p(l,s,c\sub{1},\ldots,c\sub{n})} \in \mathcal{S}$ for all timestamps $\dedalus{s} > \dedalus{t}$.  Intuitively, \dedalus{p_done()} is true when the contents of \dedalus{p} is {\em sealed} (henceforth unchanging).

We will explain how to define \dedalus{p_done()} after introducing some preliminary definitions.

A {\em collapsed PDG} of $P$ is the graph obtained by replacing each strongly
connected component of the PDG of $P$ with a single node whose label comprises
the set of all relation names from the component.  If a strongly connected
component has any asynchronous edges, we call the resulting collapsed node {\em
  async recursive}.  If a strongly connected component has inductive edges but
no asynchronous edges, we call the resulting collapsed node {\em inductive
  recursive}.  These two types of nodes are collectively referred to as {\em
  temporally recursive}.  Each node in the collapsed PDG whose label contains a
relation name in $\oschema$ is called an {\em output} node.  Note that a
collapsed PDG is acyclic.

For EDB relations \dedalus{p}, $P$ must contain the rule \dedalus{p_done()}.  For
IDB relations, defining \dedalus{p_done()} takes some work.  A rule defining
\dedalus{p_done()} for IDB relation \dedalus{p} may use \dedalus{q_done()} in
its body only if there is an edge in the collapsed PDG from a node $i$ with
$\dedalus{p} \in L(i)$ to a node $j$ with $\dedalus{q} \in L(j)$.

For ease of exposition, we will first present the computation of \dedalus{p_done()} for \dedalus{p} in non-temporally-recursive nodes.  We will then explain how to support temporally recursive nodes.

\subsubsection{Non-Temporally-Recursive Nodes}

For each non-temporally-recursive node $i$, note that $L(i)$ is a set consisting
of a single relation \dedalus{p}.  Assume the rules in $P$ with head relation
\dedalus{p} are numbered $1, \ldots, i_p$.  The rule for \dedalus{p_done()}
is:
%\nrc{why p\_done()() on the LHS?}
%removed the extra parenthesis, is this what you were objecting to?

\begin{Drules}
  \drule{p_done()}
        {r\sub{1}_done(), \ldots, r\sub{i\sb{p}}_done()}
\end{Drules}

Let the nodes in the collapsed PDG connected via incoming edges to node $i$ be denoted by $E(i)$.  Let the relations $\bigcup_{k \in E(i)} L(k)$ be named $\dedalus{p}_1, \ldots, \dedalus{p}_{i_q}$.

For each rule $1 \leq j \leq i_p$ in $P$ with head relation \dedalus{p}, if $j$ is:

\noindent
\textbf{Atemporal:}
Add the rule:

\begin{Drules}
  \drule{r\sub{j}_done()}
        {p\sub{1}_done(), \ldots, p\sub{i\sb{q}}_done()}
\end{Drules}

\noindent
\textbf{Inductive:}
Add the rule:

\begin{Drules}
  \drule{r\sub{j}_done()@next}
        {p\sub{1}_done(), \ldots, p\sub{i\sb{q}}_done()}
\end{Drules}

\noindent
\textbf{Asynchronous:}
Replace the original rule:

\begin{Drules}
  \drule{p(#N,\od{W})@async}
        {b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{X\sub{n}}), !c\sub{1}(#L,\od{Y\sub{1}}), \ldots, !c\sub{m}(#L,\od{Y\sub{m}})}
\end{Drules}

with the following set of rules:

%uq\sub{\phi}(\od{W}, \od{X}, 1) <- min(\od{X}), $\phi(\od{W}, \od{X})$.
%uq\sub{\phi}(\od{W}, \od{X}, 0) <- min(\od{X}), $!\phi(\od{W}, \od{X})$.
%uq\sub{\phi}(\od{W}, \od{Y}, 0) <- uq\sub{\phi}(\od{W}, \od{X}, 0), succ(\od{X}, \od{Y}).
%uq\sub{\phi}(\od{W}, \od{Y}, 1) <- uq\sub{\phi}(\od{W}, \od{X}, 1), succ(\od{X}, \od{Y}), $\phi(\od{W}, \od{X})$.
\begin{Drules}
\drule{p\sub{j}_to_send(N,\od{W})}
      {b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{X\sub{n}}), !c\sub{1}(#L,\od{Y\sub{1}}), \ldots, !c\sub{m}(#L,\od{Y\sub{m}})}
\drule{p\sub{j}_send(#N,L,\od{X})@async}
      {p\sub{j}_to_send(#L,N,\od{X})}
\drule{p\sub{j}_ack(#N,L,\od{X})@async}
      {p\sub{j}_send(#L,N,\od{X})}

\drule{r\sub{j}_done_node(#L,N)@async}
      {p\sub{1}_done(#N), \ldots, p\sub{i\sb{q}}_done(#N), \(\left(\forall \od{X} . \dedalus{p\sub{j}_to_send(#N,L,\od{X})} \Rightarrow \dedalus{p\sub{j}_ack(#N,L,\od{X})}\right)\)}

\drule{r\sub{j}_done()}
      {\(\left(\forall \dedalus{N} . \dedalus{node(N)} \Rightarrow \dedalus{r\sub{j}_done_node(N)}\right)\)}
\end{Drules}

The formula \dedalus{\(\forall \od{X} . \phi(\od{W},\od{X})\)} where $\phi(\od{W},\od{X})$ is of the form $\dedalus{p(\od{W},\od{X})} \Rightarrow \dedalus{q(\od{W},\od{X})}$ translates to \dedalus{forall\sub{\phi}(\od{W})}, and the following rules are added:

\begin{Drules}
\drule{p\sub{\phi}_min(\od{W},\od{X})}
      {p(\od{W},\od{X}), !p\sub{\phi}_succ(\od{W},\od{_},\od{X}), p\sub{\phi}_succ_done()}
\drule{p\sub{\phi}_max(\od{W},\od{X})}
      {p(\od{W},\od{X}), !p\sub{\phi}_succ(\od{W},\od{X},\od{_}), p\sub{\phi}_succ_done()}
\drule{p\sub{\phi}_succ(\od{W},\od{X},\od{Y})}
      {p(\od{W},\od{X}), p(\od{W},\od{Y}), !p\sub{\phi}_not_succ(\od{W},\od{X},\od{Y}), p\sub{\phi}_not_succ_done()}
\drule{p\sub{\phi}_not_succ(\od{W},\od{X},\od{Y})}
      {p(\od{W},\od{X}), p(\od{W},\od{Y}), p(\od{W},\od{Z}), \od{X} < \od{Z}, \od{Z} < \od{Y}}
\drule{p\sub{\phi}_not_succ_done()}
      {p_done()}
\drule{p\sub{\phi}_succ_done()}
      {p\sub{\phi}_not_succ_done()}
\drule{forall\sub{\phi}_ind(\od{W},\od{X})}
      {p\sub{\phi}_min(\od{W},\od{X}), q(\od{W},\od{X}).}
\drule{forall\sub{\phi}_ind(\od{W},\od{X})}
      {forall\sub{\phi}_ind(\od{W},\od{Y}), p\sub{\phi}_succ(\od{W},\od{Y},\od{X}), q(\od{W},\od{X}).}
\drule{forall\sub{\phi}(\od{W})}
      {forall\sub{\phi}_ind(\od{W},\od{X}), p\sub{\phi}_max(\od{W},\od{X})}
\drule{forall\sub{\phi}(\od{W})}
      {!p(\od{W},\od{_}), p_done()}
\end{Drules}

Note that we are abusing notation for the \dedalus{<} relation.  We previously defined \dedalus{<} as a binary relation, but it is easy to define a $2n$-ary version of \dedalus{<} that encodes a lexicographic ordering over $n$-ary relations.  Here, we use \dedalus{<} to refer to the latter.

\subsubsection{Inductive Recursive Nodes}

\todo{Figure out how this can be done in \slang; the below rules are broken.}

For each inductive recursive node $i$, assume that the relations in $L(i)$ are numbered $1,\ldots,i_p$.  For each $1 \leq j \leq i_p$, add the rules:

\begin{Drules}
\drule{p\sub{j}_prev(\od{X})@next}
      {p\sub{j}(\od{X})}
\drule{n\sub{i}_done()}
      {\(\left(\forall \od{X} . p\sub{j}(\od{X}) \Rightarrow p\sub{j}_prev(\od{X})\right)\)}
\drule{p\sub{j}_done()}
      {n\sub{i}_done()}
\end{Drules}

\subsubsection{Async Recursive Nodes}

\todo{Figure out if/how this can be done in \slang.}

\subsection{Connection with Practice}

\todo{Connect stratification with coordination protocols used in practice in distributed systems.}


