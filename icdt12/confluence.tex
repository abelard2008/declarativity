\section{\slang}
\label{sec:confluence}

%Although \lang is a natural language for distributed systems, and it is easy to compactly specify complex distributed systems \wrm{cite something?}, \lang has several problems.
\lang can express a broad class of distributed systems as compact, declarative specifications, but this flexibility comes at a cost.
As we have shown, it is easy to write programs that have nondeterministic outputs (multiple ultimate models) or diverge (no ultimate model).  In practice, such programs are rarely 
desired and indeed often indicate a bug in the specification.
%%First, the problem of multiple ultimate models, or no ultimate model, is a problem.  In practice, such programs are rarely desired and indeed often indicate a bug.  
We typically would always like our distributed program to have a single output, regardless of any non-deterministic behavior within an execution.

\begin{definition}
A \lang program is {\em confluent} (has a deterministic output) if, for every instance of the program, it has a unique ultimate model.  A program that is not confluent is {\em diffluent}.
\end{definition}

Examples~\ref{ex:diffluent1} and \ref{ex:diffluent2} are two examples of diffluent programs.

Unfortunately, confluence is an undecidable property of \lang programs:

\begin{lemma}
\label{lem:confluence-undecidable}
Confluence of a \lang program is undecidable.
\end{lemma}
\begin{proof}
Using the construction in~\cite{undecidable-datalog}, it is possible to write a Datalog program that encodes any two-counter machine's transition relation and an arbitrarily long finite successor relation in the EDB, and define a 0-ary output predicate \dedalus{accept} that is true if and only if the two-counter machine accepts and the transition and successor relations are valid.  As the construction is possible in Datalog, it is also possible in Dedalus.

We add the following rules to the construction, to nondeterministically decide whether to run the machine or not:

\begin{Drules}
  \dfact{message(0)@async} \\
  \dfact{message(1)@async}
  \drule{run\_machine()}
        {message(0), message(1)} \\
  \drule{accept()}
        {message(0), !message(1), input\_valid()} \\
  \drule{accept()}
        {!message(0), message(1), input\_valid()}
\end{Drules}

Note that the first two lines are actually rules.  The unsugared form of the first rule is \dedalus{message(L,S,0) <- node(L), time(T), time(S), T < S, choice((L, T, 0), (S)).}

For valid inputs, the ultimate model is ${\dedalus{accept()}}$ if and only if either \dedalus{message(0)} and \dedalus{message(1)} are assigned the same timestamp and the machine accepts, or if the timestamps are different.  For invalid inputs, all ultimate models are empty.

If we could decide confluence for this program, we could decide whether there is any valid input for which an arbitrary two-counter machine halts in an accepting state.
\end{proof}

\wrm{Given undecidability, it would be great to have a restricted language that only allows us to write confluent stuff.}

Another problem is that \lang is too expressive -- it captures PSPACE as shown by the following Lemma.

\begin{lemma}
\label{lem:lang-pspace}
\lang captures PSPACE.
\end{lemma}
\begin{proof}
We show how to write QBF in Dedalus.

Assuming the formula is in prenex normal form, the textbook recursive algorithm for QBF \paa{please cite} involves removing the first quantifier, and checking both $0$ and $1$ for the first variable.  If the first quantifier was existential, then we return true if QBF of one of the subformulas is true.  If the first quantifier was universal, then we return true if QBF of both of the subformulas is true.

If the quantifier depth is $n$, then it is clear that each leaf in the recursive call tree can be represented as an $n$-bit binary number.  If we assume that the left child is always $0$ and the right child $1$, then we can view our algorithm as a postorder traversal of the recursive call tree.

First, we iterate through all of the $n$-bit binary numbers, one per timestamp.  We assume that the order over the variables is such that the leftmost variable in the formula (the high-order bit) is the first, and the rightmost is the last.  Thus, our addition is ``backwards'' in that it propagates carries to the predecessors:

\begin{Drules}
  \drule{carry(V)}
        {var\_last(V)} \\
  \drule{one(V)@next}
        {carry(V), !one(V)} \\
  \drule{one(V)@next}
        {one(V), !carry(V)} \\
  \drule{carry(U)}
        {carry(V), one(V), var\_succ(U, V)}
\end{Drules}

At each timestep, we check whether the current variable assignment is true.  If it is true, then \dedalus{formula\_true()} is true at that timestep.  We omit these rules.

We propagate truth information up the recursive call tree.  A node propagates a $1$ to its parent if the quantifier associated with that node is existential and at least one of its children is true, or the quantifier is universal and both of its children are true.  A node propagates a $0$ to its parent otherwise.  If the output of the root is $1$, the formula is satisfiable, otherwise it is not: \wrm{more explanation here}

\begin{Drules}
  \drule{var\_sat\_in(V, 1)}
        {formula\_true(), var\_last(V)} \\
  \drule{var\_sat(0, V, B)@next}
        {var\_sat\_in(V, B), !var\_sat(\_, V, \_)} \\
  \drule{var\_sat(1, V, B)@next}
        {var\_sat\_in(V, B), var\_sat(0, V, \_).} \\
\end{Drules}

\begin{Drules}
  \drule{var\_sat\_left\_in(vn, 1)}
        {exists(vn), var\_sat(\_, vn, 1)} \\
  \drule{var\_sat\_left\_in(vn, 0)}
        {exists(vn), var\_sat(0, vn, 0), var\_sat(1, vn, 0)} \\
\end{Drules}

\begin{Drules}
  \drule{var\_sat\_left\_in(vn\_succ, 1)}
        {forall(vn), var\_sat(0, vn, 1), var\_sat(1, vn, 1)} \\
  \drule{var\_sat\_left\_in(vn\_succ, 0)}
        {forall(vn), var\_sat(\_, vn, false)} \\
\end{Drules}

\begin{Drules}
  \drule{var\_sat\_in(N, U, B)}
        {var\_sat\_left\_in(V, B), var\_succ(U, V)} \\
\end{Drules}

\begin{Drules}
  \drule{var\_sat(N, V, B)@next}
        {var\_sat(N, V, B), !var\_sat(1, V, \_)} \\
\end{Drules}

\begin{Drules}
  \drule{satisfiable(B)}
        {var\_sat\_left\_in(V, B), var\_last(V)}
\end{Drules}
\end{proof}


\wrm{We will present a natural restriction of \lang that is confluent, and prove that it captures exactly PTIME.  Negation free, and guarded asynchrony.}
\wrm{DON'T FORGET UNIVERSAL QUANTIFIERS -- easy, use order, what about recursion thru universal quantification?}

Distributed programs that diverge, produce nondeterministic outputs or have runtimes exponential in their inputs are undesirable in practice.
Since testing \lang programs to rule out these undesirable properties is undecidable in general, we may instead ask whether a more
constrained language will exclude such programs while retaining the convenience and power of \lang.
We will present a natural restriction of \lang that is confluent, and prove that it captures exactly PTIME.

\begin{definition}
A \lang program is {\em IDB negation-free} if the \dedalus{!} symbol only appears on EDB relations in the program.
\end{definition}

\begin{definition}
A relation \dedalus{p} in a program $P$ is {\em simply persisted} if $P$ has the rule: \dedalus{p(\(\overline{\dedalus{X}}\))@next <- p(\(\overline{\dedalus{X}}\)).}
\end{definition}

\begin{definition}
A \lang program has {\em guarded asynchrony} if all relations appearing in the heads of asynchronous rules are simply persisted.
\end{definition}

We will refer to the language of IDB negation-free \lang programs with guarded asynchrony as \slang.

\wrm{Peter to improve}
\begin{theorem}
\label{thm:confluence}
\slang programs are confluent.
\end{theorem}
\begin{proof}

Towards a proof by contradiction, consider a \slang program that 
induces more than one ultimate model.  There must be a ground atom $a$ for a predicate $p$
that is true in one but
not in another model, and $p$ must be persistent, or $a$ it would not be
in the ultimate model.  Consider a derivation of $a$: a finite tree of applications of
implication whose leaves are EDB atoms.  If none of the implications involve a nondeterministic
choice of timestamp via an {\em async} rule, then certainly 
$a$ occurs in all stable models of the program,
%there is only one stable model of the program
%\jmh{I don't buy this; we're scoped down to atom $a$ here and the rules that feed into it}, 
so there must be at least one {\em async} rule in $a$'s derivation, contributing an atom
$r$.  
If $p$ is derived directly from 
$r$ via a series of derivation steps without any joins, then every stable
model $m$ will have a tuple $a_m$ in $p$ that differs from $a$ only in its timestamp, 
and hence correspond to the same ultimate model.
Therefore, $a$ must have at least one join step (i.e., a rule with at least two subgoals)
in its derivation following $r$,
which succeeded in this stable model (producing $a$), but did not succeed in another.  
%Guarded joins always
%eventually succeed, \jmh{don't you need to define ``join success'' and prove that guarded asynchrony does what you say?} what it and 

Consider such  a join rule.  One of its subgoals $s$ corresponds to a derivation that depends
on the async-derived atom $r$.  If any predicate between $s$ and $r$ is simply persisted and 
the program is negation-free,
then $s$ is persistent.  Regardless of the nondeterministic choice of timestamp for $r$, there
is some timestamp $V_m$ in every stable model $m$ of the program such that $s$ is true
for all $W > V$.  Hence in all stable models, $s$ is ``eventually'' true.  The same argument holds
for all subgoals of the rule under consideration, and hence guarded asynchrony implies that
all joins will eventually succeed.
Hence $a$ must exist in all ultimate models.
\end{proof}


If either qualification is false, problems can result, as we have previously illustrated.

\wrm{improve the diction here}
\begin{theorem}
\slang programs capture exactly PTIME.
\end{theorem}
\begin{proof}
We will show how to convert any \slang program to an FO[IFP] formula, and how to convert any FO[IFP] formula to a \slang program.  It is known that FO[IFP] captures exactly PTIME over ordered structures \wrm{cite}.

Since \slang has only EDB negation, we first show that in any FO[IFP] formula, negation can be pushed down to the EDB.  This is not hard to show.  Since FO[IFP] has a negation normal form where negation only applies to atoms \wrm{cite}, we can always push negation down through quantifiers and boolean operators using the usual DeMorgan dualities.  \wrm{Universal quantifiers are expressed like...}

Since \slang admits a least fixpoint in each iteration, we need to show we can rewrite this formula to an inflationary fixpoint formula.  \wrm{But we can rewrite the least fixpoint as an FO[IFP] formula, and nesting of inflationary fixpoints does not increase expressive power -- citation?}

We need to show that non-determinism does not increase expressive power.  Clearly it does not because all ultimate models are equivalent in \slang, so in particular, we could correctly compute the unique ultimate model of any \slang program deterministically by replacing \dedalus{@async} with \dedalus{@next}.

Thus, we can convert a \slang program into an FO[IFP] formula. \wrm{need to say something about simultaneous inductions, blah blah?}.

We can convert any FO[IFP] formula with only EDB negation into a \slang program by converting it into rule form \wrm{i.e. splitting up each disjunct into a rule, rewrite universal quantification using order, etc.}.
\end{proof}

% \subsection{Monotonic Properties}
% XXX: Can we relax ``IDB negation free'' to be ``IDB positive''?


This discussion formalizes the CALM Conjecture mentioned above with respect to confluence, and proves it in one direction.
Clearly, there are confluent programs not in \slang.  For example:

\begin{example}
A confluent \lang program that is not a \slang program.

\todo{check example with rule sugaring guidelines in foundation}

\begin{Dedalus}
//client
b(#S, I)@async :- b_edb(I), server(S);

//server
b(I)@next <- b(I), !dequeued(I);
b_lt(I, J) <- b(I), b(J), I < J;
dequeued(I)@next <- b(I), !b_lt(_, I);
mem(I) <- dequeued(I), !bt_lt(_, _);

\end{Dedalus}
\end{example}

This program has a single ultimate model in which \dedalus{mem()} contains the highest
element in \dedalus{b\_edb()} according to the order \dedalus{<}.
Thus it is confluent, but the program uses negation, and \dedalus{b} is not simply persisted.


\subsection{Perfect Ultimate Model}

\paa{we need some transition text here.  dedalus-c is nice, but as we remember from datalog ;) IDB negation makes it easier to write programs (should be easy to give an example).  can we get some IDB negation back
without sacrificing what's we've gained going to dedalus-c?}

There is a usage of negation that is both intuitive and corresponds to distributed systems practices.  Negation is not applied until the negated relation is ``done'' being computed.  Formally, if a rule body in program $P$ contains a negated atom \dedalus{!p()}, the rule body must also contain an atom \dedalus{p\_done()}.  The relation \dedalus{p\_done()} has the property that if it is non-empty (true) at timestamp \dedalus{t}, then it is true for all timestamps \dedalus{s} > \dedalus{t}.  Furthermore, if \dedalus{p\_done()} is true at timestamp \dedalus{t}, then $\left(f \in \dedalus{p}@\dedalus{s} \land \dedalus{s} > \dedalus{t}\right) \Rightarrow \left(f \in \dedalus{p}@\dedalus{t}\right)$ \todo{introduce the former notation}.  Intuitively, \dedalus{p\_done()} is true when the contents of \dedalus{p} is {\em sealed} (henceforth unchanging).

We will explain how to define \dedalus{p\_done()} after introducing some preliminary definitions.

The {\em predicate dependency graph} (PDG)~\cite{ullmanbook} of a \slang program $P$ with spatio-temporal schema $\stschema$ is a directed graph with one node per relation -- each node $i$ has a label $L(i)$.  If node $i$ represents relation \dedalus{p}, then $L(i) = \{\dedalus{p}\}$.  There is an edge from the node with label $\{\dedalus{q}\}$ to the node with label $\{\dedalus{p}\}$ if relation \dedalus{p} appears in the head of a rule with \dedalus{q} in its body.  If some rule with \dedalus{p} in the head and \dedalus{q} in the body is asynchronous (resp. inductive), then the edge is said to be asynchronous (resp. inductive).  Collectively, these two types of edges are referred to as {\em temporal edges}.  The PDG does not contain nodes for the \dedalus{time} or \dedalus{successor} relations, or the \dedalus{choice} construct.

A {\em collapsed PDG} of $P$ is the graph obtained by replacing each strongly connected component of the PDG of $P$ with a single node whose label comprises the set of all relation names from the component.  If a strongly connected component has any asynchronous edges, we call the resulting collapsed node {\em async recursive}.  If a strongly connected component has no asynchronous edges, but has inductive edges, we call the resulting collapsed node {\em inductive recursive}.  These two types of nodes are collectively referred to as {\em temporally recursive}.  Each node in the collapsed PDG whose label contains a relation name in $\oschema$ is called an {\em output} node.  Note that a collapsed PDG is acyclic.

For EDB relations \dedalus{p}, $P$ must contain a \dedalus{p\_done()} fact.  For non-EDB relations, defining \dedalus{p\_done()} takes some work.  A rule defining \dedalus{p\_done()} for IDB relation \dedalus{p} may use \dedalus{q\_done()} in its body only if there is an edge in the collapsed PDG from a node $i$ with $\dedalus{p} \in L(i)$ to a node $j$ with $\dedalus{q} \in L(j)$.

For ease of exposition, we will first present the computation of \dedalus{p\_done()} for \dedalus{p} in non-temporally-recursive nodes.  We will then explain how to support temporally recursive nodes.

\subsubsection{Non-Temporally-Recursive Nodes}

For each non-temporally-recursive node $i$, note that $L(i)$ is a set consisting of a single relation \dedalus{p}.  Assume the rules in $P$ with head relation \dedalus{p} are numbered $1, \ldots, i_p$.  The rule for \dedalus{p\_done()} is:

\begin{Dedalus}
p\_done()() <- r\sub{1}_done(), \ldots, r\sub{i\sb{p}}_done().
\end{Dedalus}

Let the nodes in the collapsed PDG connected via incoming edges to node $i$ be denoted by $E(i)$.  Let the relations $\bigcup_{k \in E(i)} L(k)$ be named $\dedalus{p}_1, \ldots, \dedalus{p}_{i_q}$.

For each rule $1 \leq j \leq i_p$ in $P$ with head relation \dedalus{p}, if $j$ is:

\noindent
\textbf{Atemporal:}
Add the rule:

\begin{Dedalus}
r\sub{j}_done() <- p\sub{1}_done(), \ldots, p\sub{i\sb{q}}_done().
\end{Dedalus}

\noindent
\textbf{Inductive:}
Add the rule:

\begin{Dedalus}
r\sub{j}_done()@next <- p\sub{1}_done(), \ldots, p\sub{i\sb{q}}_done().
\end{Dedalus}

\noindent
\textbf{Asynchronous:}
Replace the original rule:

\begin{Dedalus}
p(#N,\od{X\sub{0}})@async <- b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{x\sub{n}}),
c\sub{1}(#L,\od{X\sub{1}}), \ldots, c\sub{m}(#L,\od{X\sub{m}}).
\end{Dedalus}

with the following set of rules:

%uq\sub{\phi}(\od{W}, \od{X}, 1) <- min(\od{X}), $\phi(\od{W}, \od{X})$.
%uq\sub{\phi}(\od{W}, \od{X}, 0) <- min(\od{X}), $!\phi(\od{W}, \od{X})$.
%uq\sub{\phi}(\od{W}, \od{Y}, 0) <- uq\sub{\phi}(\od{W}, \od{X}, 0), succ(\od{X}, \od{Y}).
%uq\sub{\phi}(\od{W}, \od{Y}, 1) <- uq\sub{\phi}(\od{W}, \od{X}, 1), succ(\od{X}, \od{Y}), $\phi(\od{W}, \od{X})$.

\begin{Dedalus}
p\sub{j}_to_send(N,\od{X\sub{0}}) <- b\sub{1}(#L,\od{X\sub{1}}), \ldots, b\sub{n}(#L,\od{X\sub{n}}).
c\sub{1}(#L,\od{X\sub{1}}), \ldots, c\sub{m}(#L,\od{X\sub{m}}).
p\sub{j}_send(#N,L,\od{X})@async <- p\sub{j}_to_send(#L,N,\od{X}).
p\sub{j}_ack(#N,L,\od{X})@async <- p\sub{j}_send(#L,N,\od{X}).

r\sub{j}_done_node(#L,N)@async <- p\sub{1}_done(#N), \ldots,
p\sub{i\sb{q}}_done(#N), \(\left(\forall \od{X} . \dedalus{p\sub{j}\_to\_send(#N,L,\od{X})} \Rightarrow \dedalus{p\sub{j}\_ack(#N,L,\od{X})}\right)\).

r\sub{j}_done() <- \(\left(\forall \dedalus{N} . \dedalus{node(N)} \Rightarrow \dedalus{r\sub{j}\_done\_node(N)}\right)\).
\end{Dedalus}

The formula \dedalus{\(\forall \od{X} . \phi(\od{W},\od{X})\)} where $\phi(\od{W},\od{X})$ is of the form $\dedalus{p(\od{W},\od{X})} \Rightarrow \dedalus{q(\od{W},\od{X})}$ translates to \dedalus{forall\sub{\phi}(\od{W})}, and the following rules are added:

\begin{Dedalus}
p\sub{\phi}_min(\od{W},\od{X}) <- p(\od{W},\od{X}), !p\sub{\phi}_succ(\od{W},\od{_},\od{X}), p\sub{\phi}_succ_done().
p\sub{\phi}_max(\od{W},\od{X}) <- p(\od{W},\od{X}), !p\sub{\phi}_succ(\od{W},\od{X},\od{_}), p\sub{\phi}_succ_done().
p\sub{\phi}_succ(\od{W},\od{X},\od{Y}) <- p(\od{W},\od{X}), p(\od{W},\od{Y}), !p\sub{\phi}_not_succ(\od{W},\od{X},\od{Y}),
p\sub{\phi}_not_succ_done().
p\sub{\phi}_not_succ(\od{W},\od{X},\od{Y}) <- p(\od{W},\od{X}), p(\od{W},\od{Y}), p(\od{W},\od{Z}), \od{X} < \od{Z},
\od{Z} < \od{Y}.

p\sub{\phi}_not_succ_done() <- p_done().
p\sub{\phi}_succ_done() <- p\sub{\phi}_not_succ_done().

forall\sub{\phi}_ind(\od{W},\od{X}) <- p\sub{\phi}_min(\od{W},\od{X}), q(\od{W},\od{X}).
forall\sub{\phi}_ind(\od{W},\od{X}) <- forall\sub{\phi}_ind(\od{W},\od{Y}), p\sub{\phi}_succ(\od{W},\od{Y},\od{X}),
q(\od{W},\od{X}).
forall\sub{\phi}(\od{W}) <- forall\sub{\phi}_ind(\od{W},\od{X}), p\sub{\phi}_max(\od{W},\od{X}).
forall\sub{\phi}(\od{W}) <- !p(\od{W},\od{_}), p_done().
\end{Dedalus}

Note that we are abusing notation for the \dedalus{<} relation.  We previously defined \dedalus{<} as a binary relation, but it is easy to define a $2n$-ary version of \dedalus{<} that encodes a lexicographic ordering over $n$-ary relations.  Here, we use \dedalus{<} to refer to the latter.

\subsubsection{Inductive Recursive Nodes}

For each inductive recursive node $i$, assume that the relations in $L(i)$ are numbered $1,\ldots,i_p$.  For each $1 \leq j \leq i_p$, add the rules:

\begin{Dedalus}
p\sub{j}_prev(\od{X})@next <- p\sub{j}(\od{X}).
n\sub{i}_done() <- \(\left(\forall \od{X} . p\sub{j}(\od{X}) \Rightarrow p\sub{j}_prev(\od{X})\right)\).
p\sub{j}_done() <- n\sub{i}_done().
\end{Dedalus}

\subsubsection{Async Recursive Nodes}

\todo{write this section}

\todo{Explain the temporal terms ``never'', ``henceforth'', ..., in foundation section}

\wrm{Formally, every usage of negation \dedalus{!p} must also have the following atom in the rule body \dedalus{n\sub{i}\_complete()}, where $\dedalus{p} \in L(i)$}

\subsection{Connection with Practice}

\wrm{Connect stratification with coordination protocols used in practice in distributed systems.}


