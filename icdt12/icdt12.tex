\documentclass{sig-alternate}

\usepackage[usenames, dvipsnames]{color}
%\usepackage{times}
\usepackage{xspace}
\usepackage{textcomp}
\usepackage{wrapfig}
\usepackage{url}
\usepackage{amsmath, amssymb}
\usepackage[protrusion=true,expansion=true]{microtype}
%\usepackage{float}
\usepackage{alltt}
\usepackage{appendix}
%\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
%\usepackage{texlive-science}
\usepackage{comment}
\usepackage{array,tabularx}

\usepackage{txfonts}
\newcommand{\Tau}{\mathcal{T}}
\newcommand{\SDedalus}{\mathcal{S}}
\newcommand{\Consts}{\mathcal{C}}
\newcommand{\Vars}{\mathcal{A}}
%\newcommand{\pos}{\protect{$_{pos}$}}
%\newcommand{\nega}{\protect{$_{neg}$}}
% RCS: Would like to use the above ones, but can't get them to work in Dedalus env.
\newcommand{\pos}{\_pos}
\newcommand{\nega}{\_neg}
\newcommand{\eat}[1]{}

\newcommand{\jmh}[1]{{\textcolor{ForestGreen}{[[#1 -- jmh]]}}}
\newcommand{\paa}[1]{{\textcolor{blue}{[[#1 -- paa]]}}}
\newcommand{\nrc}[1]{{\textcolor{magenta}{[[#1 -- nrc]]}}}
\newcommand{\wrm}[1]{{\color{BurntOrange}{[[#1 -- wrm]]}}}
\newcommand{\todo}[1]{{\color{Red}{\textbf{[[TODO: #1]]}}}}
\newcommand{\smallurl}[1]{{\small \url{#1}}}
%\newcommand{\od}[1]{{\ensuremath{\overline{\dedalus{#1}}}}}
\newcommand{\od}[1]{\ensuremath{\overline{\texttt{\fontsize{9pt}{9pt}\selectfont \escapeus{#1}}}}}
\newcommand{\schema}{\mathcal{S}}
\newcommand{\sschema}{\schema^+}
\newcommand{\stschema}{\schema^*}
\newcommand{\oschema}{\schema^O}
\newcommand{\ischema}{\schema^I}
\newcommand{\univ}{\mathcal{U}}
\newcommand{\sub}[1]{{\ensuremath{\sb{#1}}}}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
%\theoremstyle{definition}
\newdef{example}{Example}
\newdef{definition}{Definition}

\def\slang{\textsc{Dedalus}$^+$\xspace}
\def\lang{\textsc{Dedalus}\xspace}
\def\plang{\textsc{Dedalus}$^P$\xspace}
\newcommand{\etal}       {{\em et al.\/}}
\newcommand{\naive}      {na\"{\i}ve\xspace}
\newcommand{\Naive}      {Na\"{\i}ve\xspace}
%dedalus environment for code

\newenvironment{Dedalus}{
\vspace{0.5em}\begin{minipage}{0.95\textwidth}%\linespread{1.3}
\begin{alltt}\fontsize{9pt}{9pt}\selectfont}
{\end{alltt}\end{minipage}\vspace{0.5em}}

% XXX: old way of doing things -- aligns all rule bodies in a ``Drules'' block -- this is a problem if some heads are much longer than others
%\newenvironment{Drules}{
%\vspace{0.5em}\tabularx{0.45\textwidth}{l@{\hspace{0.5em}}l@{\hspace{0.5em}}X}}
%{\endtabularx\vspace{0.5em}}
%\newcommand{\drule}[2]{\dedalus{#1}&$\leftarrow$&\dedalus{#2.}}
%\newcommand{\dfact}[1]{\dedalus{#1.}}

\newenvironment{Drules}{\vspace{0.5em}\begin{minipage}{0.45\textwidth}}
{\end{minipage}\vspace{0.5em}}

% XXX: commented out for escaping # and _ in \dedalus blocks.  See below comment.
%\newcommand{\drule}[2]{\begin{tabularx}{\textwidth}{l@{\hspace{0.5em}}l@{\hspace{0.5em}}X}\dedalus{#1}&$\leftarrow$&\dedalus{#2.}\end{tabularx}}
%\newcommand{\dfact}[1]{\begin{tabularx}{\textwidth}{l}\dedalus{#1}\end{tabularx}}

% define drule and dfact and without reference to \dedalus -- this is annoying! but I can't figure out how to make the pound escaping work in the style of the underscore escaping without duplicating pounds

% XXX: Commented out due to extra long head relation names
%\makeatletter
%\DeclareRobustCommand*{\dfact}{\begingroup\@makeother\#\@escapehashfact}
%\DeclareRobustCommand*{\@escapehashfact}[1]{\begin{tabularx}{\textwidth}{l}\texttt{\fontsize{9pt}{9pt}\selectfont \escapeus{#1}}.\end{tabularx}\endgroup}
%\makeatother

\makeatletter
\DeclareRobustCommand*{\dfact}{\begingroup\@makeother\#\@escapehashfact}
\DeclareRobustCommand*{\@escapehashfact}[1]{
\raggedright
\texttt{\fontsize{9pt}{9pt}\selectfont \escapeus{#1}.}\\ \endgroup}
\makeatother

% XXX: Commented out due to extra-long head relation names
%\makeatletter           
%\DeclareRobustCommand*{\drule}{\begingroup\@makeother\#\@escapehashtwo}
%\DeclareRobustCommand*{\@escapehashtwo}[2]{\begin{tabularx}{\textwidth}{l@{\hspace{0.5em}}l@{\hspace{0.5em}}X}\texttt{\fontsize{9pt}{9pt}\selectfont \escapeus{#1}}&$\leftarrow$&\texttt{\fontsize{9pt}{9pt}\selectfont \escapeus{#2}.}\end{tabularx}\endgroup}
%\makeatother

\makeatletter
\DeclareRobustCommand*{\drule}{\begingroup\@makeother\#\@escapehashtwo}
\DeclareRobustCommand*{\@escapehashtwo}[2]{\texttt{\fontsize{9pt}{9pt}\selectfont \escapeus{#1}} $\leftarrow$ 
%\vspace{-3mm}
%\begin{list}{}{}
%\item[]
\hangindent=4em
\hangafter=1
\raggedright
\texttt{\fontsize{9pt}{9pt}\selectfont \escapeus{#2}.} \\
%\end{list}
\endgroup}
\makeatother

%\makeatletter
%\DeclareRobustCommand*{\od}{\begingroup\@makeother\#\@escapehashod}
%\DeclareRobustCommand*{\@escapehashod}[1]{\ensuremath{\overline{\texttt{\fontsize{9pt}{9pt}\selectfont \escapeus{#1}}}}\endgroup}
%\makeatother

% Dedalus escapes pounds
\makeatletter
\DeclareRobustCommand*{\dedalus}{\begingroup\@makeother\#\@escapehash}
\DeclareRobustCommand*{\@escapehash}[1]{\texttt{\fontsize{9pt}{9pt}\selectfont \escapeus{#1}}\endgroup}
\makeatother

% Escape underscores
\makeatletter
\DeclareRobustCommand*{\escapeus}[1]{%
  \begingroup\@activeus\scantokens{#1\endinput}\endgroup}
\begingroup\lccode`\~=`\_\relax
   \lowercase{\endgroup\def\@activeus{\catcode`\_=\active \let~\_}}
\makeatother


%\newcommand{\dedalus}[1]{\texttt{\fontsize{9pt}{9pt}\selectfont \escapeus{#1}}}

\begin{document}

%\conferenceinfo{ACM PODS}{'10 Indianapolis, IN, USA}
\title{Confluence Analysis for Distributed Programs:\\A Model-Theoretic Approach}

\pdfinfo{/Title (Confluence Analysis for Distributed Programs: A Model-Theoretic Approach)}

%%Format\titlenote{(Produces the permission block, copyright information and page numbering). For use with ACM\_PROC\_ARTICLE-SP.CLS V2.6SP. Supported by ACM.}}
%
% You need the command \numberofauthors to handle the "boxing"
% and alignment of the authors under the title, and to add
% a section for authors number 4 through n.

\numberofauthors{5}

\author{
\alignauthor William R.\ Marczak\\
\affaddr{UC Berkeley}\\
\email{wrm@cs.berkeley.edu}
%
\alignauthor Peter Alvaro\\
\affaddr{UC Berkeley}\\
\email{palvaro@cs.berkeley.edu}
%
\alignauthor Neil Conway\\
\affaddr{UC Berkeley}\\
\email{nrc@cs.berkeley.edu}
\and
%
\alignauthor Joseph M.\ Hellerstein\\
\affaddr{UC Berkeley}\\
\email{hellerstein@cs.berkeley.edu}
%
\alignauthor David Maier\\
\affaddr{Portland State University}\\
\email{maier@cs.pdx.edu}
}

\toappear{}

\maketitle

\begin{abstract}
  Building on recent interest in distributed logic programming, we
  take a model-theoretic approach to the correctness of asynchronous
  distributed programs. We begin by providing a model-theoretic
  semantics for \lang, a previously proposed extension to Datalog for
  modeling distributed programs.  We show that \lang
  captures too broad a complexity class of programs and
  admits programs that have non-deterministic results. We prove that
  checking whether a \lang program is confluent (has deterministic
  results) is undecidable, and hence we present \slang, a restriction
  of \lang that captures exactly PTIME and admits only confluent
  programs. \slang restricts the use of negation to EDB relations,
  which makes some natural distributed programs inconvenient to
  express.  To remedy this, we introduce \plang, a restriction of
  \lang that allows a more liberal use of negation, but retains the
  confluence of \slang and similarly captures PTIME.

%  Building on recent interest in distributed logic programming, we take a
%  model-theoretic approach to the correctness of asynchronous distributed
%  programs. We begin by reviewing \lang, a previously proposed extension to
%  Datalog for modeling distributed programs. We show that \lang captures PSPACE
%  and allows programs that have non-deterministic results. We prove that
%  checking whether a \lang program has non-deterministic results is undecidable,
%  and hence we present \slang, a restriction of \lang that admits only PTIME
%  programs with deterministic results. \slang requires that programs be
%  inflationary and restricts the use of negation. Finally, we introduce \plang,
%  a restriction of \lang that captures PTIME and only admits deterministic
%  results but allows a more liberal use of negation.

  % We show that this restricted use of negation corresponds to popular
  % coordination protocols from the distributed systems literature.

%
%We present a formal definition of the \lang language and prove conjectures.

% An increasing amount of interest surrounds the use of logic languages such as
% Datalog to ease the design and verification of asynchronous distributed
% systems.  An oft-cited reason is the model-theoretic semantics of logic
% programming, which underpin a robust literature on analysis techniques to
% ensure, among other things, termination and the existince and uniqueness of a
% program result.  While prior work on logic programming for distributed systems
% has demonstrated compactness of representation and efficiency of execution, the
% tantalizing possibility of leveraging model theory to realize analysis
% techniques for distributed systems correctness criteria has gone largely
% unrealized.  In this paper, we define model-theoretic notions for two such
% criteria popular in the distributed systems domain: {\em determinism} and {\em
% eventual consistency}.  Unfortunately, we show that these are undecidable
% properties in the general case.  However, we prove the conjectured result that
% {\em monotonicity} of logic can be a powerful conservative test for these
% criteria, and we leverage existing static {\em stratification} checks from
% logic programming to enforce monotonicity in a large class of programs by
% instrumenting them with {\em coordination logic}.

%However, using analyses from logic programming, including {\em stratification} analyses, 

%Recent distributed systems research has used variants of Datalog to specify and implement large-scale practical systems, showing orders of magnitude reduction in code size~\cite{boon}, and in some cases applying or reinterpreting 

%Programs written in declarative logic languages such as Datalog have a model-theoretic semantics that
%is independent of how the program is executed.  As a result, they are amenable to simple and powerful
%static analysis techniques to ensure, among other things, termination and the existence and uniqueness
%of a program result.  Recent distributed systems research has experimented with using variants of 
%Datalog to specify and implement large-scale practical systems, in some cases applying or reinterpreting
%existing analyses with respect to the new domain~\cite{dedalus}.  

%Continuing in this vein, it is only natural 
%to ask to what extent we can characterize notions of correctness and ``good behavior'' that are unique to distributed 
%systems, like determinism of distributed computations and eventual consistency of replicated state,
% in a model theoretic framework, and whether we may add or adapt program analyses for these properties.

%In this paper, we define a model-theoretic notions of {\em confluence, consistency} and {\em eventual
%consistency}, which are based on the existence of an {\em ultimate models}, or equivalence classes among 
%distributed traces \paa{ummmm}.  We show that for programs that do not have a unique ultimate model, 
%there often exists a single ultimate model that corresponds to the intuitive semantics of the program,
%and which can be enforced via a program rewrite that adds additional {\em coordination} logic to the given
%program to suppress the other models.  We also show that in general, the problem of deciding whether a program
%is consistent or confluent for all EDBs is undecidable, and as a correlary that it is impossible in general to
%soundly and completely verify that a program is correctly ``coordinated.''  
%Nevertheless, we propose a set of conservative tests that suffice for a wide variety of practical systems.
%
\end{abstract}

\input{new_intro}
\input{foundation}
\input{confluence}
\input{perfect}

\input{bloom}
\input{relwork}
\input{conclusion}
\bibliographystyle{abbrv}
\bibliography{pods,declarativity}

\appendix
\input{appendix}

%%\input{attic}

\end{document}
