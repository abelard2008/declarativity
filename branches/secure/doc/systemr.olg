namespace systemr {

  materialize(plan, 10000, infinity, keys(4)).
  materialize(bestPlan, infinity, infinity, keys(4)).
  materialize(complete, infinity, infinity, keys(2)).
  materialize(rules, 10000, infinity, keys(2)).
  materialize(completeBestPlans, 10000, infinity, keys(2)).
  materialize(assigns, 10000, infinity, keys(2, 3)).
  materialize(thetaPredicates, 10000, infinity, keys(2, 3, 4)).

  i0 counter(@A, Pid, Rid) :-
       programEvent(@A, Pid, Name, Rewrite, Status, Text, Msg, P2DL),
       ::sys::rule(@A, Rid, Pid, R_Name, R_HeadFid, R_P2DL, R_Delete, R_Term_Count).

  i1 assigns(@A, Pid, Rid, a_count<*>) :-
       counter(@A, Pid, Rid),
       ::sys::assign(@A, Aid, Rid, Var, Value, Pos).

  i2 rules(@A, Pid, a_count<Rid>) :-
       programEvent(@A, Pid, Name, Rewrite, Status, Text, Msg, P2DL),
       ::sys::rule(@A, Rid, Pid, R_Name, R_HeadFid, R_P2DL, R_Delete, R_Term_Count).

  i3 complete(@A, Pid, Val) :- 
       programEvent(@A, Pid, Name, Rewrite, Status, Text, Msg, P2DL),
       Val := true.
 
  i4 checkComplete(@A, Pid, Val) :- 
       periodic(@A, E, 2), complete(@A, Pid, Val).

  i5 complete(@A, Pid, true) :- 
       checkComplete(@A, Pid, Val), Val == false.

  i6 delete complete(@A, Pid, Val) :- 
       checkComplete(@A, Pid, Val), Val == true.

  /***********************************************************************/
  f0 finalize(@A, Pid) :-
      checkComplete(@A, Pid, Val), Val == true,
      rules(@A, Pid, Count),       
      completeBestPlans(@A, Pid, Count).       

  f1 ::sys::program(@A, Pid, Name, Rewrite, "systemr", Text, Msg, P2DL) :-
         finalize(@A, Pid),
         ::sys::program(@A, Pid, Name, Rewrite, Status, Text, Msg, P2DL).

  f2 selectPlan(@A, Pid, Rid, Size) :-
        finalize(@A, Pid),
        ::sys::rule(@A, Rid, Pid, _, _, _, _, Terms),
        Size := Terms - 1U.

  f3 bestPlanSelect(@A, Pid, Rid, Size, Cost) :-
       selectPlan(@A, Pid, Rid, Size),
       bestPlan(@A, Pid, Rid, PlanID, Size, Cost).

  f4 commitPlan(@A, Pid, Rid, PlanID) :-
       bestPlanSelect(@A, Pid, Rid, Size, Cost),
       bestPlan(@A, Pid, Rid, PlanID, Size, Cost).



  /***********************************************************************/
  /* Start the optimization process */
  t1 thetaPredicates(@A, Pid, Rid, Sid, Bool) :-
        programEvent(@A, Pid, _, _, _, _, _, _),
        ::sys::rule(@A, Rid, Pid, _, _, _, _, _),
        ::sys::select(@A, Sid, Rid, Bool, _, _),
        f_istheta(Bool) == true.

  
  /* Get the program event and seed the optimization with the event functor. */
  o1a plan(@A, Pid, Rid, PlanID, SubPlanID, Type, TypeID, Plan, Schema, Card, Cost, Pos, AM, null) :-
            programEvent(@A, Pid, P_Name, P_Rewrite, P_Status, P_Text, P_Msg, P_P2DL),
            ::sys::rule(@A, Rid, Pid, R_Name, R_HeadFid, R_P2DL, R_Delete, R_Term_Count),
            ::sys::functor(@A, Fid, Rid, F_Notin, F_Name, F_TID, F_ECA, F_Schema, F_Pos, F_AM, F_New),
            F_Pos == 1,
            PlanID    := f_idgen(),
            SubPlanID := null,
            Type      := "Functor",
            TypeID    := Fid,
            Plan      := f_cons(Fid, null),
            Schema    := F_Schema,
            Card      := 1,
            Cost      := 1,
            Pos       := 1U,
            AM        := "EVENT".

  o1b complete(@A, Pid, false) :-
                   planUpdate(@A, Pid, Rid, PlanID, Plan).

  o1c addAssigns(@A, Pid, Rid, PlanID) :-
              planUpdate(@A, Pid, Rid, PlanID, Size, Sort),
              assigns(@A, Pid, Rid, Count),
              ::sys::rule(@A, Rid, Pid, Name, HeadFid, P2DL, Delete, Terms),
              Size + 1 >= Terms - Count.

  /***********************************************************************/
  /* Detect an update to the local plan table */
  o2 planUpdate(@A, Pid, Rid, PlanID, Size, Sort) :- 
        plan(@A, Pid, Rid, PlanID, _, _, _, Plan, _, _, _, _, _, Sort),
        Size := f_size(Plan) + 0U.

  /***********************************************************************/
  /* A new best plan write. */
  o3a bestPlanUpdate(@A, Pid, Rid, PlanID) :-
       bestPlan(@A, Pid, Rid, PlanID, Size, Cost).

  /* Pick the minimum cost over the plans with the max size. */
  o3b bestCostPlan(@A, Pid, Rid, Size, Sort, a_min<Cost>) :-
        planUpdate(@A, Pid, Rid, _, Size, Sort),
        plan(@A, Pid, Rid, _, _, _, _, Plan, _, _, Cost, _, _, Sort),
        f_size(Plan) == Size.

  o3c bestPlan(@A, Pid, Rid, PlanID, Size, Cost) :-
       bestCostPlan(@A, Pid, Rid, Size, Sort, Cost),
       plan(@A, Pid, Rid, PlanID, _, _, _, Plan, _, _, Cost, _, _, Sort),
       f_size(Plan) == Size.

  /* Keep a count of the number of rules with best plans. */
  o3d completeBestPlans(@A, Pid, a_countdistinct<Rid>) :-
              bestPlanUpdate(@A, Pid, _, _),
              bestPlan(@A, Pid, Rid, _, Size, Cost),
              ::sys::rule(@A, Rid, Pid, _, _, _, _, Terms),
              Terms == Size + 1.
  
  /***********************************************************************/
  /* Search for the an index join */
  o4 plan(@A, Pid, Rid, f_idgen(), PlanID, "Functor", Fid, NewPlan, Schema, Card, Cost, OuterPos+1U, AM, null) :-
        bestPlanUpdate(@A, Pid, Rid, PlanID),
        plan(@A, Pid, Rid, PlanID, _, _, _, OuterPlan, OuterSchema, OuterCard, OuterCost, OuterPos, _, _),
        ::sys::functor(@A, Fid, Rid, _, _, Tid, _, F_Schema, F_Pos, _, _),
        ::sys::table(@A, Tid, Tablename, _, _, _, T_Card, _),
        ::sys::index(@A, I_ID, Tablename, I_Key, I_Type, I_Selectivity),
        F_Pos > 1,
        f_contains(Fid, OuterPlan) == false,
        f_indexMatch(OuterSchema, F_Schema, I_Key) == true,
        Card   := OuterCard * (I_Selectivity * T_Card),
        Cost   := OuterCost + (OuterCard * (I_Selectivity * T_Card)),
        NewPlan:= f_cons(Fid, OuterPlan),
        Schema := f_merge(OuterSchema, F_Schema),
        AM     := f_cons(I_Type, I_ID). 

  /***********************************************************************/
  /* Check for a theta join. */
  o5a checkThetaJoin(@A, Pid, Rid, PlanID, Fid, Tid, Iid) :-
        bestPlanUpdate(@A, Pid, Rid, PlanID),
        plan(@A, Pid, Rid, PlanID, _, _, _, Plan, _, _, _, _, _, _),
        ::sys::functor(@A, Fid, Rid, _, _, Tid, _, _, Pos, _, _),
        ::sys::table(@A, Tid, Tablename, _, _, _, _, _),
        ::sys::index(@A, Iid, Tablename, _, Type, _),
        Pos > 1,
        Type == "Range",
        f_contains(Fid, Plan) == false.

  o5b thetaJoin(@A, Pid, Rid, PlanID, Fid, Tid, Iid, a_mklist<Sid>) :-
        checkThetaJoin(@A, Pid, Rid, PlanID, Fid, Tid, Iid),
        ::sys::functor(@A, Fid, Rid, _, _, Tid, _, Schema, Pos, _, _),
        ::sys::table(@A, Tid, Tablename, _, _, _, _, _),
        ::sys::index(@A, Iid, Tablename, Key, Type, _),
        thetaPredicates(@A, Pid, Rid, Sid, Bool),
        f_project(Key, Schema) == f_variables(Bool).

  o5c plan(@A, Pid, Rid, f_idgen(), PlanID, "ThetaJoin", Fid, NewPlan, Schema, Card, Cost, OuterPos+1U, AM, Sort) :-
        thetaJoin(@A, Pid, Rid, PlanID, Fid, Tid, Iid, PredIDs),
        plan(@A, Pid, Rid, PlanID, _, _, _, OuterPlan, OuterSchema, OuterCard, OuterCost, OuterPos, _, _),
        ::sys::functor(@A, Fid, Rid, _, _, Tid, _, FSchema, _, _, _),
        ::sys::table(@A, Tid, Tablename, _, _, _, T_Card, _),
        ::sys::index(@A, Iid, Tablename, Key, Type, _),
        f_size(PredIDs) > 0,
        Card   := OuterCard * (T_Card / (3*f_size(PredIDs))),
        Cost   := OuterCost + (OuterCard * (T_Card / (3*f_size(PredIDs)))),
        NewPlan:= f_cons(PredIDs, f_cons(Fid, OuterPlan)),
        Schema := f_merge(OuterSchema, FSchema),
        AM     := f_cons(f_cons(Type, Iid), PredIDs),
        Sort   := f_project(Key, FSchema). 

  /***********************************************************************/
  /* Make a scan for this table predicate. */
  o6 plan(@A, Pid, Rid, f_idgen(), PlanID, "Functor", Fid, NewPlan, Schema, Card, Cost, OuterPos+1U, AM, null) :-
        bestPlanUpdate(@A, Pid, Rid, PlanID),
        plan(@A, Pid, Rid, PlanID, _, _, _, OuterPlan, OuterSchema, OuterCard, OuterCost, OuterPos, _, _),
        ::sys::functor(@A, Fid, Rid, _, _, Tid, _, F_Schema, F_Pos, _, _),
        ::sys::table(@A, Tid, _, _, _, _, T_Card, _),
        F_Pos > 1,
        f_contains(Fid, OuterPlan) == false,
        Cost   := OuterCost + (OuterCard * T_Card),
        Card   := OuterCard * T_Card / 10,
        NewPlan:= f_cons(Fid, OuterPlan), 
        Schema := f_merge(OuterSchema, F_Schema),
        AM     := f_cons("SCAN", null). 

  /***********************************************************************/
  /* Merge join access method for this table predicate. */

  o7 plan(@A, Pid, Rid, f_idgen(), PlanID, "Functor", Fid, NewPlan, Schema, Card, Cost, OuterPos+1U, AM, Sort) :-
        bestPlanUpdate(@A, Pid, Rid, PlanID),
        plan(@A, Pid, Rid, PlanID, _, _, _, OuterPlan, OuterSchema, OuterCard, OuterCost, OuterPos, _, OuterSort),
        ::sys::functor(@A, Fid, Rid, _, _, Tid, _, FSchema, FPos, _, _),
        ::sys::table(@A, Tid, _, _, _, _, TCard, TSort),
        FPos > 1,
        f_contains(Fid, OuterPlan) == false,
        f_sortattr(OuterSchema, OuterSort, FSchema, f_project(TSort, FSchema)) != null,
        Sort   := f_sortattr(OuterSchema, OuterSort, FSchema, f_project(TSort, FSchema)),
        Cost   := OuterCost + (OuterSort != Sort ? 3*OuterCard : 0) + 
                              (f_project(TSort, FSchema) != Sort ? 3*TCard : 0),
        Card   := OuterCard * TCard / 10,
        NewPlan:= f_cons(Fid, OuterPlan), 
        Schema := f_merge(OuterSchema, FSchema),
        AM     := f_cons("MERGE", null).

  /***********************************************************************/
  /* Perform next selection? */
  o8 plan(@A, Pid, Rid, f_idgen(), PlanID, "Select", Sid, NewPlan, Schema, Card, Cost, OuterPos+1U, AM, Sort) :-
      bestPlanUpdate(@A, Pid, Rid, PlanID),
      plan(@A, Pid, Rid, PlanID, _, _, _, OuterPlan, OuterSchema, OuterCard, OuterCost, OuterPos, _, Sort),
      ::sys::select(@A, Sid, Rid, S_Bool, _, _),
      f_contains(Sid, OuterPlan) == false,
      f_filter(OuterSchema, S_Bool) == true,
      Cost      := OuterCost,
      Card      := OuterCard / 3,
      NewPlan   := f_cons(Sid, OuterPlan), 
      Schema    := OuterSchema,
      AM        := f_cons("FILTER", null). 

  /***********************************************************************/
  /* Add assignment? */
  o9 plan(@A, Pid, Rid, f_idgen(), PlanID, "Assign", Aid, Plan, Schema, OuterCard, OuterCost, OuterPos+1U, AM, Sort) :-
        addAssigns(@A, Pid, Rid, PlanID),
        plan(@A, Pid, Rid, PlanID, _, _, _, OuterPlan, OuterSchema, OuterCard, OuterCost, OuterPos, _, Sort),
        ::sys::assign(@A, Aid, Rid, Var, _, _),
        f_contains(Aid, OuterPlan) == false,
        Plan      := f_cons(Aid, OuterPlan), 
        Schema    := f_assignschema(OuterSchema, Var),
        AM        := f_cons("ASSIGN", null). 

  /***********************************************************************/
  /* Create assignment out of selection in order to allow more index attributes. */
  o10 plan(@A, Pid, Rid, f_idgen(), PlanID, "castassign", Sid, Plan, Schema, OuterCard, OuterCost, OuterPos+1U, AM, Sort) :-
        bestPlanUpdate(@A, Pid, Rid, PlanID),
        plan(@A, Pid, Rid, PlanID, _, _, _, OuterPlan, OuterSchema, OuterCard, OuterCost, OuterPos, _, Sort),
        ::sys::functor(@A, Fid, Rid, _, _, _, _, F_Schema, F_Pos, _, _),
        ::sys::select(@A, Sid, Rid, S_Bool, _, _),
        F_Pos > 1,
        f_contains(Fid, OuterPlan) == false,
        f_contains(Sid, OuterPlan) == false,
        f_castassign(OuterSchema, F_Schema, S_Bool) != null,
        Schema := f_assignschema(OuterSchema, f_car(f_castassign(OuterSchema, F_Schema, S_Bool))),
        AM     := f_castassign(OuterSchema, F_Schema, S_Bool),
        Plan   := f_cons(Sid, OuterPlan).

  
  /***********************************************************************/
  /* TODO: DO THIS AT TERMINATION. */
  /* Update the functor and selection tables with the new position and access method. */
  u0 commitPlan(@A, Pid, Rid, SubPlanID) :-
       commitPlan(@A, Pid, Rid, PlanID),
       plan(@A, Pid, Rid, PlanID, SubPlanID, _, _, _, _, _, _, _, _, _),
       SubPlanID != null.
  
  /* Update the functor and selection tables with the new position and access method. */
  u1a ::sys::functor(@A, Fid, Rid, Notin, Name, TID, ECA, Schema, Pos, AM, New) :-
        commitPlan(@A, Pid, Rid, PlanID),
        plan(@A, Pid, Rid, PlanID, _, Type, TypeID, _, _, _, _, Pos, AM, _),
        ::sys::functor(@A, Fid, Rid, Notin, Name, TID, ECA, Schema, _, _, New),
        Type == "Functor", TypeID == Fid.

  u1b ::sys::functor(@A, Fid, Rid, Notin, Name, TID, ECA, Schema, Pos, AM, New) :-
        commitPlan(@A, Pid, Rid, PlanID),
        plan(@A, Pid, Rid, PlanID, _, Type, TypeID, _, _, _, _, Pos, AM, _),
        ::sys::functor(@A, Fid, Rid, Notin, Name, TID, ECA, Schema, _, _, New),
        Type == "ThetaJoin", TypeID == Fid.

  u2a ::sys::select(@A, Sid, Rid, Bool, Pos, AM) :-
        commitPlan(@A, Pid, Rid, PlanID),
        plan(@A, Pid, Rid, PlanID, _, "Select", Sid, _, _, _, _, Pos, AM, _),
        ::sys::select(@A, Sid, Rid, Bool, _, _).

  /* In validate the selection by assigning it a negative valued position. */
  u2b ::sys::select(@A, Sid, Rid, Bool, -1, null) :-
        commitPlan(@A, Pid, Rid, PlanID),
        plan(@A, Pid, Rid, PlanID, _, "castassign", Sid, _, _, _, _, _, _, _),
        ::sys::select(@A, Sid, Rid, Bool, _, _).

  /* In validate the selection by assigning it a negative valued position. */
  u2c ::sys::select(@A, Sid, Rid, Bool, -1, null) :-
        commitPlan(@A, Pid, Rid, PlanID),
        plan(@A, Pid, Rid, PlanID, _, "ThetaJoin", Fid, _, _, _, _, _, AM, _),
        ::sys::select(@A, Sid, Rid, Bool, _, _),
        f_contains(Sid, AM) == true.

  u3 ::sys::assign(@A, Aid, Rid, Var, Value, Pos) :-
        commitPlan(@A, Pid, Rid, PlanID),
        plan(@A, Pid, Rid, PlanID, _, "Assign", Aid, _, _, _, _, Pos, _, _),
        ::sys::assign(@A, Aid, Rid, Var, Value, _).

  u4 ::sys::assign(@A, f_idgen(), Rid, Var, Value, Pos) :-
        commitPlan(@A, Pid, Rid, PlanID),
        plan(@A, Pid, Rid, PlanID, _, "castassign", Sid, _, _, _, _, Pos, AM, _),
        Var := f_car(AM), Value := f_car(f_cdr(AM)).

}
