1> Semantics of compound tuple: The versioning approach offers the slightly non-intutive behavior where a given locspec can contain multiple tuples of a given type with same key as the version (which is included in the implicit key) will be different for all such tuples.
Possible Sol: Include the table key in the locSpec table making the locSpecTable table specific. Thus the key for locSpec table will comprise of Node containing the version tuple(to avoid DOS attacks by attacker), node referencing the locSpec, locSpec, and the key for the referenced table (note that the version is now excluded from the key)1> The eca code needs to be changed to preserve the term ordering in the original rule.
2> Need to add the functions used in the compound tuple rewrite
3> Does the key in the materialized tables start from 0 if the location is to be included?
4> It is assumed that there are no distributed views in the program. This assumption is used in the rewrite1 stage where in rules where no event exists, any non-locSpec location is used as the event locspec for the rule to generate the locSpecTable functors.
5> currently, as an implementation artifact (due to insufficient checks in rewrite1 stage), only locSpecs appearing in direct locSpec positions are considered locSpecs and others are considered normal location fields. Thus if l is a locSpec, then m == l and child(@m,...) will not be correctly interpreted.