program runtime;

import java.lang.String;
import java.lang.Integer;
import java.lang.Long;
import p2.types.basic.TupleSet;
import p2.types.basic.Tuple;
import p2.types.table.TableName;

/* Define runtime events. */
define(runnable, {Long, String, TableName, TupleSet, TupleSet});
define(strata, keys(0,1), {String, Long, Integer});
define(priority, keys(0,1), {String, TableName, Integer});
define(delta, {Long, String, TableName, TupleSet, TupleSet});

reschedule
schedule(Time, Program, Name, Insertions, Deletions) :-
	delta(Time, Program, Name, Insertions, Deletions);
	
schedulePublic
schedule(Time, Program2, Name, Insertions, Deletions) :-
	delta(Time, Program1, Name, Insertions, Deletions),
	query(Program2, Rule, Public, Delete, Event, Input, Output, Object),
	Public == true && Input == Name, Program1 != Program2;

evaluate 
delta(Time, Program, Name, Insertions, Deletions) :-
	evaluate(runnable(Time, Program, Name, Insertions, Deletions));

/* Delete what has been evaluated in the current clock. */
cleanup 
delete schedule(Time, Program, Name, Insertions, Deletions) :-
	runnable(Time, Program, Name, Insertions, Deletions);

/* Identify the runnable tuples. */
runnable 
runnable(Time, Program, Name, Insertions, Deletions) :-
	strata#insert(Program, Time, Priority),
	schedule(Time, Program, Name, Insertions, Deletions),
	priority(Program, Name, Priority);
	
/* Determine the current strata in the current time for all 
   programs that have something scheduled. */
strata 
strata(Program, Time, min<Priority>) :-
	clock(Location, Time),
	schedule(Time, Program, Name, Insertions, Deletions),
	priority(Program, Name, Priority);

/* This case handles those programs that do not have a query
    (and hence no priority) for the tuple 'Name'. */
runnable(Time, Program, Name, Insertions, Deletions) :-
	clock(Location, Time),
	schedule(Time, Program, Name, Insertions, Deletions),
	notin priority(Program, Name, Priority);
	
/*******************************************************************/
/*** Network scheduler                                           **/
import p2.net.Message;
import p2.net.Application;

define(networkSend, {String, String, String});

delete network::buffer(Protocol, Address, Program, Insertions, Deletions) :-
	networkSend(Protocol, Address, Program),
	network::buffer(Protocol, Address, Program, Insertions, Deletions),
	network::connection(Protocol, Address, Channel),
	Channel.send((Message) new Application(Program, Insertions, Deletions));

networkSend(Protocol, Address, Program) :-
	clock(Location, Time),
	network::buffer(Protocol, Address, Program, Insertions, Deletions),
	network::connection(Protocol, Address, Channel);
	
network::connection(Protocol, Address, null) :-
	clock(Location, Time),
	network::buffer(Protocol, Address, _, _, _),
	notin network::connection(Protocol, Address, _);

	
/*******************************************************************/
/*** Periodic scheduler                                           **/

define(schedulePeriodic, {String, Long, Long, Long, Long, String});

/* Schedule next periodic. */
renewPeriodic
schedulePeriodic(Id, Period, TTL, Time+Period, Count+1, Program) :-
	clock#insert(Location, Time),
	global::periodic(Id, Period, TTL, Time, Count, Program),
	Count < TTL;
			
initPeriodic 
schedulePeriodic(Id, Period, TTL, Time+1+Offset, Count+1, Program) :-
	config(Time, Program, Object),
	global::periodic(Id, Period, TTL, Offset, Count, Program);
	
/* Schedule the periodic and update its execution count. */
schedulePeriodic 
global::periodic(Id, Period, TTL, Time, Count, Program) :-
	periodicScheduler(schedulePeriodic(Id, Period, TTL, Time, Count, Program));


/*******************************************************************/
/*** Fact scheduler */

define(facts, {String, TableName, TupleSet});

collectFacts 
facts(Program, Name, tupleset<Tuple>) :-
	config(Time, Program, Object),
	fact(Program, Name, Tuple);
	
installFacts1 
runnable(Time, Program, Name, Facts, null) :-
	facts(Program, Name, Facts), Program == "compile",
	clock(Location, Time);
	
installFacts2 
schedule(Time+1, Program, Name, Facts, null) :-
	facts(Program, Name, Facts), Program != "compile",
	clock(Location, Time);
	
/*******************************************************************/
/*** Schedule compile */

define(config, {Long, String, p2.lang.plan.Program});

configProgram 
config(Time, Program, Object) :-
	compiler#insert(Program, Owner, File, Object),
	clock(Location, Time),
	Object.plan();
		
compileConfig 
runnable(Time, "compile", Tuples.name(), Tuples, null) :-
	config(Time, Program, Object),
	Tuples := new TupleSet(new TableName("compile", "config"), Object.tuple());
	
	