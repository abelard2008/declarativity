program runtime;

import java.lang.String;
import java.lang.Integer;
import java.lang.Long;
import p2.types.basic.TupleSet;
import p2.types.basic.Tuple;
import p2.types.table.TableName;

/* Define runtime events. */
define(runnable, {Long, String, TableName, TupleSet, TupleSet});
define(strata, infinity, infinity, keys(0,1), {String, Long, Integer});
define(priority, infinity, infinity, keys(0,1), {String, TableName, Integer});

next schedule(Time, Program, Name, Insertions, Deletions) :-
	evaluate(runnable(Time, Program, Name, Insertions, Deletions));

/* Delete what has been evaluated in the current clock. */
cleanup delete schedule(Time, Program, Name, Insertions, Deletions) :-
					runnable(Time, Program, Name, Insertions, Deletions);

/* Identify the runnable tuples. */
runnable runnable(Time, Program, Name, Insertions, Deletions) :-
	strata(Program, Time, Priority),
	schedule(Time, Program, Name, Insertions, Deletions),
	schedule(Time, Program, Name, Insertions, Deletions),
	priority(Program, Name, Priority);
	
/* Determine the current strata in the current time for all 
   programs that have something scheduled. */
strata strata(Program, Time, min<Priority>) :-
	clock(Location, Time),
	schedule(Time, Program, Name, Insertions, Deletions),
	priority(Program, Name, Priority);
	
/*******************************************************************/
/*** Periodic scheduler                                           **/

define(schedulePeriodic, {String, Long, Long, Long, Long, String});

/* Schedule next periodic. */
renewPeriodic
schedulePeriodic(Id, Period, TTL, Count+1, Time+Period, Program) :-
	clock#insert(Location, Time),
	global::periodic(Id, Period, TTL, Count, Time, Program),
	Count <= TTL;
			
initPeriodic 
schedulePeriodic(Id, Period, TTL, Count+1, Time+1+Offset, Program) :-
	config(Time, Program, Object),
	global::periodic(Id, Period, TTL, Count, Offset, Program);
	
/* Schedule the periodic and update its execution count. */
schedulePeriodic 
global::periodic(Id, Period, TTL, Count, Time, Program) :-
	periodicScheduler(schedulePeriodic(Id, Period, TTL, Count, Time, Program));


/*******************************************************************/
/*** Fact scheduler */

define(facts, {String, TableName, TupleSet});

collectFacts 
facts(Program, Name, tupleset<Tuple>) :-
	compiler#insert(Program, Owner, File, Object),
	fact(Program, Name, Tuple);
	
installFacts1 
runnable(Time, Program, Name, Facts, null) :-
	facts(Program, Name, Facts), Program == "compile",
	clock(Location, Time);
	
installFacts2 
schedule(Time+1, Program, Name, Facts, null) :-
	facts(Program, Name, Facts), Program != "compile",
	clock(Location, Time);
	
/*******************************************************************/
/*** Schedule compile */

define(config, {Long, String, p2.lang.plan.Program});

configProgram 
config(Time, Program, Object) :-
	compiler#insert(Program, Owner, File, Object),
	clock(Location, Time),
	Object.plan();
		
compileConfig 
runnable(Time, "compile", Tuples.name(), Tuples, null) :-
	config(Time, Program, Object),
	Tuples := new TupleSet(new TableName("compile", "config"), Object.tuple());
	
	