import java.lang.String;
import java.lang.Integer;
import java.lang.Long;
import p2.types.basic.TupleSet;

/* Define runtime events. */
define(runnable, {String, String, TupleSet, TupleSet});
define(strata, {String, Long, Integer});

next schedule(Time, Program, TupleName, Insertions, Deletions) :-
	evaluate(runnable(Program, TupleName, Insertions, Deletions)),
	clock(Location, Time);

/* Delete what has been evaluated in the curent clock. */
cleanup delete schedule(Time, Program, TupleName, Insertions, Deletions) :-
					runnable(Program, TupleName, Insertions, Deletions),
					clock(Location, Time);

/* Identify the runnable tuples. */
runnable runnable(Program, TupleName, Insertions, Deletions) :-
	strata(Program, Time, Priority),
	priority(Program, TupleName, Priority),
	schedule(Time, Program, TupleName, Insertions, Deletions);

/* Determine the current strata in the current time for all 
   programs that have something scheduled. */
strata strata(Program, Time, min<Priority>) :-
	clock(Location, Time),
	schedule(Time, Program, TupleName, Insertions, Deletions),
	priority(Program, TupleName, Priority);

/*******************************************************************/
/*** Periodic scheduler                                           **/

/* Run next periodic. */
schedule periodic(Id, Period, TTL, Count+1, Time+Period, Program) :-
			clock#insert(Location, Time),
			periodic(Id, Period, TTL, Count, Time, Program),
			Count <= TTL;
			
initperiodic periodic(Id, Period, TTL, Count, Time + Offset, Program) :-
				planned(Program, Time),
				periodic(Id, Period, TTL, Count, Offset, Program);
	
/* Delete the previous period. */
periodic delete periodic(Id, Period, TTL, Count-1, Time-Period, Program) :-
   			       periodicScheduler(periodic(Id, Period, TTL, Count, Time, Program));

/*******************************************************************/
/*** Compiler configuration                                      **/
/*** TODO: Add general stage installation table */

define(priority, infinity, infinity, keys(0,1), {String, String, Integer});
define(dependency, infinity, infinity, keys(0,1,2), {String, String, String});
define(planned, {String, Long});
define(scheduleFact, {Long, String, String, TupleSet});

planned("runtime", 0L);

planned(Program, Time) :-
	compiler(Program, Owner, File, Time, Object),
	Object.plan();
	
scheduleFact(Time, Program, TupleName, tupleset<Tuple>) :-
	planned(Program, Time), Program != "runtime",
	fact(Program, TupleName, Tuple);
	
schedule(Time, Program, TupleName, Facts, null) :-
	scheduleFact(Time, Program, TupleName, Facts);

/* Rule part tables have been filled in by compiler. */
/* Determine R/G graph dependencies. */
dependency(Program, Head.name(), Body.name()) :-
	planned(Program, Time),
	rule(Program, Rule, _),
	predicate(Program, Rule, 0, Event, Head), /* Position == 0 */
	predicate(Program, Rule, Pos, Event, Body), 
	Head.name() != Body.name(), Pos > 0;
	
/* Initialize all predicates to stratum 0. */
init priority(Program, Pred.name(), 0) :-
		planned(Program, Time),
		rule(Program, Rule, _),
		predicate(Program, Rule, Pos, Event, Pred),
		notin priority(Program, Pred.name(), _);

/* Bubble up predicates in the stratum chain. */
bubble priority(Program, Head, Priority) :-
		priority(Program, Head, HPriority),
		priority(Program, Body, BPriority),
		dependency(Program, Head, Body),
		notin dependency(Program, Body, Head),
		HPriority <= BPriority,
		Priority := BPriority + 1;




