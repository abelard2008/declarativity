program runtime;

import p2.core.System;
import java.lang.String;
import java.lang.Integer;
import java.lang.Long;
import p2.types.basic.TupleSet;
import p2.types.basic.Tuple;
import p2.types.table.TableName;

/* Schedules things from the schedule queue (attaches strata to each tuple). */
define(queue, {Long, Integer, String, TableName, TupleSet, TupleSet});

/* Insertion queue: (Time, ID, Strata, ProgramName, TableName, Tuples) */
define(insertionQueue, keys(1), {Long, Long, Integer, String, TableName, TupleSet});

/* Deletion queue: (Time, ID, ProgramName, TableName, Tuples) */
define(deletionQueue,  keys(1), {Long, Long, String, TableName, TupleSet});

/* Evaluator output: evaluation(Time, ID, ProgramName, TableName, Insertions, Deletions) */
define(evaluation, {Long, Long, String, TableName, TupleSet, TupleSet});

/* Evaluator input: execute(Time, ID, ProgramName, TableName, Insertions, Deletions) */
define(execute,    {Long, Long, String, TableName, TupleSet, TupleSet});

/* Committer output: delta(Time, ID, ProgramName, TableName, Insertions, Deletions) */ 
define(delta, {Long, Long, String, TableName, TupleSet, TupleSet});

/* Committer input: runnable(Time, ID, ProgramName, TableName, Insertions, Deletions) */ 
define(runnable,   {Long, Long, String, TableName, TupleSet, TupleSet});

/* Current strata: strata(Program, Time, Strata) */
define(strata,  keys(0,1), {String, Long, Integer});

/* Predicate/TableName priority/strata: priority(Program, TableName, Strata) */
define(priority, keys(0,1), {String, TableName, Integer});

/* Remove insertion post evaluation. */
delete
insertionQueue(Time, Id, Strata, Program, Name, Insertions) :-
	evaluation(_, Id, _, _, _, _),
	insertionQueue(Time, Id, Strata, Program, Name, Insertions);

/* Remove deletion post evaluation. */
delete
deletionQueue(Time, Id, Program, Name, Insertions) :-
	evaluation(_, Id, _, _, _, _),
	deletionQueue(Time, Id, Program, Name, Insertions);

/* Reschedule delta. */
schedule(Time, Program, Name, Insertions, Deletions) :-
	evaluation(Time, Id, Program, Name, Insertions, Deletions),
	Insertions.size() > 0 || Deletions.size() > 0;
	
/* Evaluate the program with the given insertions OR deletions. */
evaluator
evaluation(Time, Id, Program, Name, Insertions, Deletions) :-
	evaluator(execute(Time, Id, Program, Name, Insertions, Deletions));
	
/* NOTE: We do not schedule public deletions!! */
publicEval
execute(Time, Id, Program2, Name, Insertions, null) :-
	delta(Time, Id, Program1, Name, Insertions, Deletions),
	query(Program2, Rule, Public, Delete, Event, Input, Output, Object),
	Public == true && Input == Name, Program1 != Program2;

/* Execute on the intended program. */
localEval
execute(Time, Id, Program, Name, Insertions, Deletions) :-
	delta(Time, Id, Program, Name, Insertions, Deletions);

/* Commit the insertions OR deletions, pass deltas to evaluator. */
commit 
delta(Time, Id, Program, Name, Insertions, Deletions) :-
	committer(runnable(Time, Id, Program, Name, Insertions, Deletions));

/* Identify the runnable tuples. */
insertion_runnable 
runnable(Time, Id, Program, Name, Insertions, null) :-
	strata(Program, Time, Strata),
	insertionQueue(Time, Id, Strata, Program, Name, Insertions);

/* Execute all deletions when insertion count goes to 0. 
   Deletions executed and deletions deltas scheduled for 
   next clock. */
deletion_runnable 
runnable(Time+1, Id, Program, Name, null, Deletions) :-
	deletionQueue(Time, Id, Program, Name, Deletions);


/* Determine the current strata in the current time for all 
   programs that have something scheduled. */
strata 
strata(Program, Time, min<Strata>) :-
	insertionQueue(Time, Id, Strata, Program, Name, Insertions);

init_insertion_queue
insertionQueue(Time, Id, Strata, Program, Name, Insertions) :-
	queue(Time, Strata, Program, Name, Insertions, Deletions),
	Id := System.idgen();
	
init_deletion_queue
deletionQueue(Time, Id, Program, Name, Deletions) :-
	queue(Time, Strata, Program, Name, Insertions, Deletions),
	Deletions != null && Deletions.size() > 0,
	Id := System.idgen();
	
/* Queue up scheduled items in current clock. */
queue(Time, Strata, Program, Name, Insertions, Deletions) :-
	clock(Location, Time),
	schedule(Time, Program, Name, Insertions, Deletions),
	priority(Program, Name, Strata);
	
queue(Time, 0, Program, Name, Insertions, Deletions) :-
	clock(Location, Time),
	schedule(Time, Program, Name, Insertions, Deletions),
	notin priority(Program, Name, _);

/* Clean up queued programs. */
delete
schedule(Time, Program, Name, Insertions, Deletions) :-
	clock#delete(Location, Time),
	schedule(Time, Program, Name, Insertions, Deletions);

/*******************************************************************/
/*** Periodic scheduler                                           **/

define(schedulePeriodic, {String, Long, Long, Long, Long, String});

/* Schedule next periodic. */
renewPeriodic
schedulePeriodic(Id, Period, TTL, Time+Period, Count+1, Program) :-
	clock#insert(Location, Time),
	global::periodic(Id, Period, TTL, Time, Count, Program),
	Count < TTL;
			
initPeriodic 
schedulePeriodic(Id, Period, TTL, Time+1+Offset, Count+1, Program) :-
	config(Time, Program, Object),
	global::periodic(Id, Period, TTL, Offset, Count, Program);
	
/* Schedule the periodic and update its execution count. */
schedulePeriodic 
global::periodic(Id, Period, TTL, Time, Count, Program) :-
	periodicScheduler(schedulePeriodic(Id, Period, TTL, Time, Count, Program));


/*******************************************************************/
/*** Fact scheduler */

define(facts, {String, TableName, TupleSet});

collectFacts 
facts(Program, Name, tupleset<Tuple>) :-
	config(Time, Program, Object),
	fact(Program, Name, Tuple);
	
installFacts 
queue(Time, 0, Program, Name, Facts, null) :-
	facts(Program, Name, Facts), Program == "compiler",
	Facts.name(Name),
	clock(Location, Time);
	
installFacts2 
schedule(Time+1, Program, Name, Facts, null) :-
	facts(Program, Name, Facts), Program != "compile",
	Facts.name(Name),
	clock(Location, Time);
	
/*******************************************************************/
/*** Schedule compile */

define(config, {Long, String, p2.lang.plan.Program});

configProgram 
config(Time, Program, Object) :-
	compiler#insert(Program, Owner, File, Object),
	clock(Location, Time),
	Object.plan();
		
compileConfig 
schedule(Time, "compile", Tuples.name(), Tuples, null) :-
	config(Time, Program, Object),
	Tuples := new TupleSet(new TableName("compile", "config"), Object.tuple());
	
	