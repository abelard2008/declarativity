\section{Evaluation models}

Consider the \emph{successor} relation described above.  According to our intuitive interpretation, this relation models
the passage of time, in order to establish a temporal order among ground atoms.  More formally, we expect of a successor
relation $S$ that

$\forall A,B (successor(A, B) \rightarrow B > A) \land \forall A \exists B (successor(A, B))$

This implies that successor is infinite (as we'd expect time to be).  This is problematic because it leads to unsafe programs.

\newtheorem{example}{Example}
\begin{example}
Consider the program and EDB below.

\begin{Dedalus}
r1
p_pos(A, B)@next \(\leftarrow\)
  p_pos(A, B),
  \(\lnot\)p_neg(A, B);
  
p_pos(A, B)  \(\leftarrow\)
  p(A, B);
  
p(1, 2)@123;
  
\end{Dedalus}

The single ground fact will, due to \emph{r1}, cause as many deductions as there are tuples in the successor relation.

\end{example}

But if \emph{successor} is infinite, many of these are in some sense \emph{void deductions}, functionally determined based on the EDB.
The EDB determines a window over successor that is relevant to any computation that must be performed.  It is easy
to see that in this example, we need only consider a successor relation that contains a single tuple \{123, 124\}.

Consider the given EDB extended with two more facts:

\begin{Dedalus}
delete p(1, 2)@456;
p(?, ?)@789;
\end{Dedalus}

Evaluating this program and EDB will require a \emph{successor} relation with values that range from 123 - 789.

\begin{definition}
A \emph{post-hoc} evaluation is an evaluation of a Dedalus program in which an EDB prefix is given, \emph{successor} is derived from it
as part of a fixpoint computation.
\end{definition}

In a post-hoc evaluation, we may use the given EDB to populate the successor relation in the following way:

Define first a second order predicate called \emph{event\_time} 
that contains the union of the time attributes from the EDB prefix. Let \emph{Trace} be the set of $n$ EDB predicates.  
Then \emph{event\_time} is defined as

$event\_time(\Tau) \leftarrow \displaystyle\bigcup_{i}^n \pi_{\Tau}Trace_{i}$

\begin{Dedalus}
smax(max<N>) \(\leftarrow\) event\_time(N);
smin(min<N>) \(\leftarrow\) event\_time(N);

successor(N, N + 1) \(\leftarrow\) smin(N);

successor(S, S + 1) \(\leftarrow\) 
    successor(N, S),
    smax(M),
    N <= M;
\end{Dedalus}

In a post-hoc evaluation, time is in some sense ``instantaneous" in that all values of the successor relation are considered in a single
fixpoint computation.  

\subsection{EDB Prefixes}
\paa{notes follow}

In general, an EDB can itself be infinite. 

\begin{definition}
A \emph{prefix} $\alpha_{n}$ of an EDB $\Gamma$ is the set of events whose timestamp is greater than or equal to $n$.
\end{definition}

If the EDB is finite, $\alpha_{n}$ = $\Gamma$.  We also have:

$\forall \alpha_{i}, \alpha_{j} \in \Gamma ((i < j) \to (\alpha_{i} \subset \alpha_{j}))$.

Consider a function $FP$ from $Program, EDB \mapsto IDB$ that represents the \emph{fixpoint} computation carried out by a datalog interpreter.
We would like to show that 

$FP(P, \alpha_{k}) =  \displaystyle \bigcup_{i=0}^{k} FP(P, \alpha_{i})$ for any $k$.  

this could (with some work) lead to an inductive proof
that an infinite model is minimal.  we could prove the (weaker?) property that
the infinite series of models of increasing finite prefixes of an EDB are all 
minimal if one of them is.

below is just a sketch of a proof:

\begin{proof}

Inductive step:

if we assume that some program P and finite prefix $\alpha_n$ of a trace $\Gamma$ produce a minimal model, 
then it follows that a prefix $\alpha_{n+1}$ and the IDB produced by the previous model produce a minimal model.

Assume the contrary: there is some program P, prefix $\alpha_i$ and prefix $\alpha_j$  s.t. $\alpha_j$ follows $\alpha_i$, $I_1$ = FP($\alpha_i$) is a minimal model 
and $I_2$ = FP($\alpha_j \cup I_1$) is not.  

then in $I_2$ there exists a ground atom that is not in $\alpha_j$ (and hence not in $\alpha_i$), and is not entailed by P given $\alpha_j$.  
such a ground atom must then either be:

\begin{enumerate}
\item contained in $I_1$, hence entailed by P given $\alpha_i$.
\item entailed by P given some IDB atom in $I_1$.
\end{enumerate}

In the first case, in principle is it possible for an atom X to exist in $I_1$ and not in $I_2$, if for example it depended negatively via a 
rule r on a predicate q, and a q fact (Y) exists in  $\alpha_j$ that didn't exist in  $\alpha_i$.  However, for this to occur, because a ground atom 
in I1 cannot depend upon a ground atom from the "future", that event q would need to have occurred at some time less than 
or equal to the to timestamp of atom X.  but this is not possible, because our trace is ordered in timestamp order.  hence the 
first case leads to contradiction.

in the second case, there is some ground atom Y in I1 upon which X depends.  Y is not in FP( $\alpha_j$), because if it were, X would 
be part of the single minimal model.  if Y is not in FP( $\alpha_j$), it too is not part of a minimal model for P given  $\alpha_j$!  if it is in the minimal 
model for FP($\alpha_i$) but not FP( $\alpha_j$), there must be a fact in  $\alpha_j$ upon which an atom in FP($\alpha_i$) depended negatively.  by the same 
argument as above, such a fact could not be in  $\alpha_j$, because new facts in  $\alpha_j$ have timestamps strictly higher than those in  $\alpha_i$.
\end{proof}

Even without providing a basis, we may say