\section{Evaluation models}

Consider the \emph{successor} relation described above.  According to our intuitive interpretation, this relation models
the passage of time, in order to establish a temporal order among ground atoms.  \wrm{we're ignoring entanglement here}

Recall that {\em successor} is the standard strict total order on $\mathbb{N}$,
and is thus an infinite relation.  Clearly, a naive interpretation of time can
lead to unsafe programs:

%%No reason to re-define a strict total order here...
%\begin{itemize}

%\item $\forall A,B \in \mathbb{Z} : successor(A, B) \Rightarrow B > A$ (i.e. whenever $successor(A,B)$ is true, then $B > A$)

%\item $\forall A \in \mathbb{Z} : \exists! B \in \mathbb{Z} : successor(A,B)$ (i.e. every integer has a successor)

%\end{itemize}

%\wrm{we'd expect a lot more properties of successor than the ones you mentioned.  so instead of trying to think of them all, i just narrowed down what you wrote.}

%This implies that successor is infinite (as we'd expect time to be), and is problematic because it leads to unsafe programs.

\newtheorem{example}{Example}
\begin{example}
Consider the Dedalus instance below.

\begin{Dedalus}
r1
p_pos(A, B)@next \(\leftarrow\)
  p_pos(A, B),
  \(\lnot\)p_neg(A, B);
  
p_pos(A, B)  \(\leftarrow\)
  p(A, B);
  
p(1, 2)@123;
  
\end{Dedalus}

The single ground fact will, due to \emph{r1}, cause one deduction for each
tuple in {\em successor}.  Since {\em successor} is infinite, the program is
unsafe.

\end{example}

However, we observe that all of these deductions are uninteresting, as they are
deterministically related to the EDB.  To avoid performing such deductions, we
restrict {\em successor} to range over the subset of $\mathbb{N}$ consisting of
the consecutive natural numbers between the minimum and maximum timestamp
specified in the (finite) EDB ($\{123, 124\}$ in this example) \wrm{this is without NDB right?}.  If we extended the EDB with the additional facts:

%But if \emph{successor} is infinite, many of these deductions may be \emph{void}in some sense, i.e. functionally determined based on the EDB. \wrm{is functionally determined a real term?}
%In effect, an EDB that is given in its totality determines a window over successor that is relevant to any computation that must be performed.  \wrm{what about NDB?}
%It is easy to see that in this example, we need only consider a successor relation that contains a single tuple \{123, 124\}.

\begin{Dedalus}
delete p(1, 2)@456;
p(?, ?)@789; \wrm{we're still doing queries?}
\end{Dedalus}

Evaluating the Dedalus instance would require \emph{successor} to range over the
subset of consecutive natural numbers $[123, 790]$.

\begin{definition}
A \emph{post-hoc} evaluation is an evaluation of a Dedalus instance where
{\em successor} ranges over the finite subset of $\mathbb{N}$ described above.
\end{definition}

In a post-hoc evaluation, we can derive {\em successor} from the EDB as part of
the fixpoint computation.  We first define a predicate \emph{event\_time} that
contains the union of the time attributes from the EDB:

$event\_time(\Tau) \leftarrow \displaystyle\bigvee_{p \in EDB} p([...], \Tau)$

\wrm{I wasn't a fan of expressing a query plan in a Datalog rule...  But we can
talk about this}

We then populate \emph{successor} with Dedalus program shown below:
%with arithmetic and aggregate functions, as shown below.

\begin{Dedalus}
smax(max<N>) \(\leftarrow\) event\_time(N);
smin(min<N>) \(\leftarrow\) event\_time(N);

successor(N, N + 1) \(\leftarrow\) smin(N);

successor(S, S + 1) \(\leftarrow\) 
    successor(N, S),
    smax(M),
    N <= M;
\end{Dedalus}

\wrm{Not sure what the point of this is...}
Since {\em successor} is finite in a post-hoc evaluation, we may evaluate the
entire Dedalus instance in a single fixpoint.

%In a post-hoc evaluation, time is in some sense ``instantaneous" in that all values of the successor relation are considered in a single
%fixpoint computation.  The complete program is safe if the EDB is finite.

\subsection{EDB Prefixes}
\paa{notes follow}

In general, however, an EDB can itself be infinite, and will lead to unsafe evaluations even when \emph{successor} is derived from it
as in a post-hoc evaluation.
\wrm{huh?  it can't be infinite.  an infinite EDB makes the program unsafe,
regardless of this time thing.}

\begin{definition}
A \emph{prefix} $\alpha_{n}$ of an EDB $\Gamma$ is the set of facts in $\Gamma$ whose timestamp is less than or equal to $n$.
\end{definition}

If the EDB is finite, then it has a maximum timestamp $\top$, and $\alpha_{\top}$ = $\Gamma$.  Because each prefix is a superset of all 
prefixes with lower indices, we also have the monotonicity property

\begin{equation}
\forall \alpha_{i}, \alpha_{j} \in \Gamma : (i < j) \to (\alpha_{i} \subseteq \alpha_{j})
\end{equation}

\paa{to your point, bill, I switched the lemma and proof below to one of IDB equivalence in the posthoc vs. continual interpretation
rather than an inductive proof that every model in the series is minimal.  there is probably a very similar proof of the latter
that we could include in the next section after introducing minimal models, stratification etc}


\newtheorem{lemma}{Lemma} 

\begin{lemma}
%
Let $F$ be the set of all finite subsets of possible facts. \wrm{need to be
more precise.}  Let $P$ be the set of all finite subsets of possible rules.
Let $FP : P \times F \mapsto F$ be the function representing the
\emph{fixpoint} computation carried out by a datalog interpreter.  Consider
a program $p$ with EDB $\gamma$, and a set $\lambda \subset \mathbb{N}$.  Then,

\begin{equation}
\forall k \in \lambda : FP(p, \alpha_{k}) =  \displaystyle \bigcup_{i=0}^{k} FP(p, \alpha_{i})
\end{equation}

\wrm{what's the deal with lambda??  i'm just ignoring it in the proof below}

\end{lemma}
%%for any $k$. 

%%this could (with some work) lead to an inductive proof
%%that an infinite model is minimal.  we could prove the (weaker?) property that
%%the infinite series of models of increasing finite prefixes of an EDB are all 
%%minimal if one of them is.

\begin{proof}

%%Inductive step:

%%if we assume that some program P and finite prefix $\alpha_n$ of a trace $\Gamma$ produce a minimal model, 
%%then it follows that a prefix $\alpha_{n+1}$ and the IDB produced by the previous model produce a minimal model.

Assume the contrary, that is for some prefixes $\alpha_i$ and $\alpha_{i+1}$:

$FP_p(\alpha_{i+1} \cup FP_p(\alpha_i)) \neq FP_p(\alpha_{i+1})$

This means that there exists at least one intensional ground atom $A$ that is
only in one of the sets.

{\bf Case 1:} $\exists A \in FP_p(\alpha_{i+1} \cup FP_p(\alpha_i)) : A \not\in FP_p(\alpha_{i+1}).$

\wrm{I started working on this proof and then I stopped, because I don't see how
it matches the above lemma... we can discuss tomorrow}

%If $I_2 \neq I_3$, it must be the case that either there exists a ground atom in $I_2$ that is not in $I_3$, or that is in
%$I_3$ and not in $I_2$.  

Take the former case first.  This means there is an atom $A$ that is entailed by P given $FP(\alpha_{j} \cup FP(\alpha_{i}))$
but not entailed by P given $\alpha_{j}$, so it must be in $I_1$.   The only circumstances under which an atom in
$I_1$ would not occur in the IDB $FP(\alpha_{j})$ is if there is a fact $B$ in $\alpha_{j}$ 
corresponding to a negated subgoal in a rule $r$ in P upon which $A$ depends.  However, for this to occur, because a ground atom 
in $I_1$ cannot depend upon a ground atom from the ``future", that fact $B$ would need to have occurred at some time less than 
or equal to the to timestamp of atom $A$.  But this is not possible, because all timestamps in $\alpha_{j}$ that are not in any $\alpha_{k} | k<j$
are strictly higher than any timestamps in $\alpha_{k}$.  Hence the first case leads to contradiction.

As for the second case...

\end{proof}

\textbf{Old proof} (to be removed):
\begin{proof}
then in $I_2$ there exists a ground atom that is not in $\alpha_j$ 
\wrm{don't get this.  do you think we should define minimal model and fixpoint before this?}  
(and hence not in $\alpha_i$), and is not entailed by P given $\alpha_j$.  
such a ground atom must then either be:

\begin{enumerate}
\item contained in $I_1$, hence entailed by P given $\alpha_i$.
\item entailed by P given some IDB atom in $I_1$.
\end{enumerate}

In the first case, in principle is it possible for an atom X to exist in $I_1$ and not in $I_2$, if for example it depended negatively via a 
rule r on a predicate q, and a q fact (Y) exists in  $\alpha_j$ that didn't exist in  $\alpha_i$.  However, for this to occur, because a ground atom 
in I1 cannot depend upon a ground atom from the "future", that event q would need to have occurred at some time less than 
or equal to the to timestamp of atom X.  but this is not possible, because our trace is ordered in timestamp order.  hence the 
first case leads to contradiction.

in the second case, there is some ground atom Y in I1 upon which X depends.  Y is not in FP( $\alpha_j$), because if it were, X would 
be part of the single minimal model.  if Y is not in FP( $\alpha_j$), it too is not part of a minimal model for P given  $\alpha_j$!  if it is in the minimal 
model for FP($\alpha_i$) but not FP( $\alpha_j$), there must be a fact in  $\alpha_j$ upon which an atom in FP($\alpha_i$) depended negatively.  by the same 
argument as above, such a fact could not be in  $\alpha_j$, because new facts in  $\alpha_j$ have timestamps strictly higher than those in  $\alpha_i$.
\end{proof}


