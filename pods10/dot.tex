\documentclass{acm_proc_article-sp-sigmod09}

%%\usepackage{amsthm}


\usepackage[usenames, dvipsnames]{color}
\usepackage{times}
%%\usepackage{url}
%%\usepackage{graphicx}
%%\usepackage{boxedminipage}
\usepackage{xspace}
\usepackage{textcomp}
\usepackage{wrapfig}
\usepackage{url}
%%\usepackage{verbatim}
%%\usepackage{latexsym}
\usepackage{amsmath, amssymb}
%%\usepackage{amsthm}

\usepackage{alltt}
\usepackage{appendix}


\newcommand{\jmh}[1]{{\textcolor{red}{#1 -- jmh}}}
\newcommand{\paa}[1]{{\textcolor{blue}{#1 -- paa}}}
\newcommand{\rcs}[1]{{\textcolor{green}{#1 -- rcs}}}
\newcommand{\nrc}[1]{{\textcolor{magenta}{#1 -- nrc}}}
\newcommand{\wrm}[1]{{\color{BurntOrange}{#1 -- wrm}}}
\newcommand{\smallurl}[1]{{\small \url{#1}}}

%dedalus environment for code
\newenvironment{Dedalus}{
\vspace{0.5em}\begin{minipage}{0.95\textwidth}%\linespread{1.3}
\begin{alltt}\fontsize{9pt}{9pt}\selectfont}
{\end{alltt}\end{minipage}\vspace{0.5em}}

\newcommand{\dedalus}[1]{\texttt{\fontsize{9pt}{9pt}\selectfont #1}}


\begin{document}


We take as our foundation language an augmented version of \linebreak
$\lnot$Datalog~\cite{ullmanbook} with aggregate function
symbols.  In general, we are interested in the classes of statically
stratifiable and locally stratifiable programs~\cite{prz}.  An exception is our
use of the \emph{choice} construct~\cite{greedychoice, eventchoice} to model
nondeterministic selection of an element from a set.  We use this construct to
model both the nondeterminism of message delay, and the semantics of key
maintenance in prior deductive update models like Overlog~\cite{boon}.

We consider an infinite universe of constants \emph{C}, in which
$C_{1}, C_{2}, [...], C_{n}$ are representations of individual constants, and
an infinite universe of variable symbols \emph{A} which may take on the values
of any constants.   We also consider the set of positive integers $\mathbb{Z}$,
which represents the set of possible times, its obvious total order
\dedalus{successor} and a symbol that represents ``never''.

\section{Syntactic Restrictions}
%%\jmh{I wonder if it wouldn't be better to do a totally syntactic definition of Dedalus as a restricted subclass of Datalog+stratification+successor, with some convenience %%notation that falls out of the restrictions.  It would ensure that we don't skip steps, and allow us to fall back on proofs about Datalog without being sloppy.  The intro %%paragraph before is only halfway formal and might be better off with a firm basis in citeable Datalog papers.}

%%A Dedalus program is a Datalog program in which every predicate is annotated with a time suffix.  \jmh{Already some slop ... you want to define it via Datalog+strat
%%+succ.  You could start by using Datalog notation but requiring the last attribute of each predicate to range over $\mathbb{Z}$, and then introduce the @-sign notation.}  
%%A Dedalus predicate has the following form:

%%$p(A_{1}, A_{2}, [...], A_{n})@S$

We make the restriction that the final attribute of every predicate be of an
integer type \wrm{we really want an inclusion constraint not just in the set of integers, but in the set of all possible times, in case time is finite}.  We will refer to this final attribute, common to all predicates,
as the \emph{time suffix}.  Facts are defined just as in Datalog, thus a fact
will have a constant integer value for its time suffix: e.g.


$p(C_{1},C_{2},[...],C_{n}, i) |  i \in \mathbb{Z}$


We further consider only \emph{well-formed} rules defined as follows.  Every
subgoal of a rule's body is required to use a common variable, perhaps
represented by symbol $N$, for its time suffix.  $N$ must not be otherwise
constrained (e.g. it must not occur in the rule body except as a time suffix).


The head of a well-formed rule similarly contains a time suffix $S$, which must
be constrained in exactly one of three ways:

\begin{enumerate}

\item The rule is said to be \emph{deductive} or {\em atemporal} if $S$ is
bound to the value of $N$.  That is, the body contains a subgoal of the form:
\dedalus{S := N}.

\item The rule is said to be {\em inductive} if $S$ is the successor
of $N$.  That is, the body contains a subgoal of the form:
\dedalus{successor(N, S)}.

\item The rule is said to be {\em asynchronous} if $S$ is unrelated to the
value of $N$ in the body.  We express this independence by adding two subgoals
to the body: \dedalus{successor(\_, S), choose((\_), (S))}.  The
\dedalus{choice} subgoal ensures that the $S$ value projected into the head of
the rule is some arbitrary $S$-value of \emph{successor}. \wrm{Why can't we
select the initial time?  What we should do instead is have some unary relation
time(T) that captures all possible times, and choose from this relation
instead.  We can assume an inclusion constraint forcing successor's arguments
to both come from this relation.}

\end{enumerate}

We collectively refer to the latter two types of rules as {\em temporal} rules,
as their derivations may exist in a distinct timestep from that of their
inputs.

\subsection{Abbreviated Syntax and Intuition}

Dedalus comprises the subset of Datalog defined above, along with some syntactic sugar.  The body predicates of all well-formed rule have a 
variable $N$ in the time suffix unbound in the rest of the rule: we may therefore omit this attribute from the syntax.  The inclusion of the \emph{successor}
and \emph{choice} predicates is functionally determined by the rule type (inductive or asynchronous), so we omit also these predicates
from the body.  The rule type is then indicated by a special suffix of the rule head, in the form:

$r(A_{1},A_{2},[...],A_{n})@S$

Where $S$ is one of the following:
\begin{enumerate}
\item \emph{now}: a deductive rule, in which all predicates share the same time suffix.
\item \emph{next}: an inductive rule, in which \emph{successor} is included as described above, and the time suffix of the head predicate
is the successor of those of the body predicates. 
\item \emph{async}: an asynchronous rule, in which the time suffix of the head predicate is chosen nondeterministically from the \emph{successor} 
relation.
\end{enumerate}


A Datalog fact is simply a rule head with an empty body and all ground terms for its attributes.  To accommodate this in the abbreviated syntax,
we allow a fourth suffix for the special case of empty bodies: a constant integer indicating the time at which the fact is true.  A Dedalus fact thus has the form:

$r(C_1, C_2, [...], C_n)@CI$

where $CI$ is an integer constant.


%Finally, we define the following shorthand for referring to the special IDB relations defined above.  Recall that for every EDB predicate $r$
%we have a uniquely defined pair of IDB predicates $r\_pos$ and $r\_neg$.  In a Dedalus program, we use $r$ as shorthand for $r\_pos$ 
%(recall that the true EDB predicate $r$ cannot be referenced by any rules) and $delete$ $r$ as shorthand for $r\_neg$.
%%A deductive rule as defined above will hold for any assignment of a constant integer to the $N$-value in the suffix of each predicate.

\subsection{Events}

\wrm{bunch of random definitions}

\newdef{definition}{Definition}
 \begin{definition}
%
A {\em Dedalus program} is a set of Dedalus rules, partitioned by location.
%
\end{definition}

%%\newdef{definition}{Definition} 
\begin{definition} 
%
An \emph{extensional} relation in a Dedalus program is a relation that does not
appear in the head of any rule in the program.
%
\end{definition}

%%\newdef{definition}{Definition} 
\begin{definition}
%
A \emph{modifiable} relation in a Dedalus program is a relation that appears in
the head of one or more asynchronous rules in the program.
%
\end{definition}

%%\newdef{definition}{Definition}
 \begin{definition}
%
An \emph{intensional} relation in a Dedalus program is a relation that appears
in the head of one or more deductive or atemporal rules in the program, and
appears in no head of an asynchronous rule in the program.
%
\end{definition}

We refer to the sets of facts in extensional, modifiable, and intensional
predicates respectively as the EDB, MDB, and IDB.

The EDB, MDB, and IDB are all pairwise disjoint.  Intuitively, the distinction
between the MDB and IDB is that the MDB is determined nondeterministically from
the IDB, EDB and MDB, while the IDB is determined deterministically from the
IDB, EDB and MDB.  Thus, given an EDB, and a distributed system, all IDB
predicates that do not transitively depend on MDB predicates can be evaluated
deterministically.

For every EDB relation $r$ in a program $P$, we add to $P$ two relations
$r\_pos$ and $r\_neg$ with the same types, and a rule of the form:

$r\_pos(A_1, A_2, [...], A_n) \leftarrow r(A_1, A_2, [...], A_n);$

\wrm{Are we missing the time suffixes here?} That is, for every EDB predicate
$r$ there is an IDB predicate $r\_pos$ that contains at least the contents of
$r$.  We further restrict all rules in P to refer only to IDB and MDB
predicates, and to reference $r\_neg$ for any relation $r$ only in the head of
a rule, and never in the body \wrm{then, how do we write persistence rules?}.
In a Dedalus program, we use $r$ as shorthand for $r\_pos$ (as the true EDB
predicate $r$ cannot be referenced by any rules) and $delete$ $r$ as shorthand
for $r\_neg$.

%%\newdef{definition}{Definition} 
\begin{definition}
%
An \emph{event} in Dedalus is an EDB fact.
%
\end{definition}

Since an EDB relation may not appear in a rule's head, events come from sources
external to the Dedalus program, and serve as ground for the distributed
computaion.

%\paa{careful.  messages to myself? if they are given, \emph{when} are they given?}
\subsection{Simple Persistence}

A fact in predicate $p$ at time $T$ may provide ground for deductive rules
at time $T$, as well as ground for deductive rules in later timesteps,
provided there exists a rule of the form:

$p_pos(A_1,A_2,[...],A_n)@next \leftarrow 
p_pos(A_1,A_2,[...],A_n);$

\begin{definition}
%
A rule of the above form is known as a {\em simple persistence rule}.
%
\end{definition}

A simple inductive persistence rule ensures that a $p$ fact true at time $i$ will
be true $\forall j \in \mathbb{Z} | j >= i$.

\subsection{Mutable State}

To model deletions and updates of a fact, it is useful to break the induction
in a simple persistence rule.  Adding a {\em p\_neg} subgoal to the body of a
simple persistence rule accomplishes this:

$p\_pos(A_1,A_2,[...],A_n)@next \leftarrow \\
p\_pos(A_1,A_2,[...],A_n), \\
\lnot p\_neg(A_1,A_2,[...],A_n);
$

\begin{definition}
%
A rule of the above form is known as a {\em mutable persistence rule}.
%
\end{definition}

If, at any time $k$, we have a fact $p\_neg(C_1,C_2,[...],C_n)@k$, then we do
not deduce a $p\_pos(C_1,C_2,[...],C_n)@k+1$ fact.  By induction, we do not
deduce a $p\_pos(C_1,C_2,[...],C_n)@l$ for any $l > k$, unless this $p_pos$
fact is re-derived at some timestep $l > k$ by another rule.

\begin{definition}
%
For some time $i$, an {\em update} is any pair of facts:

$p\_neg(C_{1},C_{2},[...],C_{n})@i$ \\ $p\_pos(D_{1},D_{2},[...],D_{n})@i+1$
%
\end{definition}

Intuitively, an update represents replacing an old value of a tuple with a
newer value.  We say the update is {\em atomic across timesteps}, meaning that
the old value ceases to exist at the same timestep in which the new value
exists -- timestep $i+1$ in the above definition.

\section{Stratifiability of Dedalus Programs}

\newtheorem{lemma}{Lemma} 

\begin{lemma} 
%
A Dedalus program without negation, aggregation, and choice has a unique
minimal model.
%
\end{lemma}

\begin{proof} 
%
A Dedalus program without negation, aggregation, and choice is a pure Datalog
program.  Every Datalog program has a unique minimal model. \wrm{cite?  or the
audience knows this}
%
\end{proof}

We define syntactic stratification of a Dedalus program the same way it is
defined for a Datalog program:

\begin{definition}
%
A Dedalus program without choice is \emph{syntactically stratifiable} if there
exists no cycle with a negative edge or an aggregation edge in the program's
predicate dependency graph.
%
\end{definition}

We evaluate such a program by evaluating each strongly connected component of
its predicate dependency graph under a closed-world assumption.  We may
evaluate in any order returned by a topological sort on the predicate
dependency graph with each strongly connected component collapsed to a single
node. \wrm{XXX: is this right?}

\begin{definition}
%
A {\em Dedalus instance} $(P,E)$ is a Dedalus program $P$ along with an EDB
$E$.
%
\end{definition}

\begin{lemma}
%
A syntactically stratifiable Dedalus instance without choice has a unique
minimal model.  That is, there exists a function $D$ from syntactically
stratifiable Dedalus instances without choice to their minimal models.
%
\end{lemma}

\begin{proof}
%
We know that there exists a function $B$ from syntactically stratifiable
Datalog instances to their minimal models.  Earlier, we introduced \wrm{XXX:
where?} a bijection \wrm{XXX: probably not a bijection} $A$ from the set of
Dedalus instances without choice to the set of Datalog instances, and a
bijection $C$ between minimal models of Datalog instances and minimal models of
Dedalus instances without choice.  We will show that $D = C \circ B \circ A$.

Thus, we need only prove that the codomain of $A$ restricted to the set of
syntactically stratifiable Dedalus instances without choice is a subset of
syntactically stratifiable Datalog instance.  We will show this by proving that
$M$ does not add any negated cycles to the instance's predicate dependency
graph.

Since $M$ does not add any rules to the instance, and may introduce only the
non-negated EDB {\em successor} relation to the body of an existing rule, it
does not add any new cycles to, or add negation to any existing cycles in the
instance's predicate dependency graph.
%
\end{proof}

\begin{definition}
%
\wrm{Def of locally stratifiable}
%
\end{definition}

\begin{lemma}
%
A locally stratifiable Dedalus instance without choice has a unique
minimal model.  That is, there exists a function $E$ from locally
stratifiable Dedalus instances without choice to their minimal models.
%
\end{lemma}

\begin{proof}
%
\wrm{TODO}
%
\end{proof}


\begin{definition}
%
A \emph{deductive reduction} of a Dedalus program $P$ is the subset of $P$
consisting of exactly those deductive rules in $P$.
%
\end{definition}

\begin{definition} 
%
A Dedalus program is \emph{temporally stratifiable} if its deductive
reduction is syntactically stratifiable.
%
\end{definition}

%%\newtheorem{theorem}{Theorem}
\begin{lemma}
%
Any temporally stratifiable Dedalus instance $P$ without asynchronous rules has
a unique minimal model
%
\end{lemma} 

\begin{proof}
%
\bf{Case 1:} $P$ consists of only deductive rules.  In this case, $P$'s
deductive reduction is $P$ itself.  We know $P$ is syntactically stratifiable,
thus it has a unique minimal model.

\bf{Case 2:} $P$ consists of only deductive and inductive rules.  Assume $P$
does not have a unique minimal model.  This implies that $P$ is not
syntactically stratifiable, thus there must exist some cycle through at least
one predicate $q$ involving a negation or aggregation edge in $P$'s predicate
dependency graph, and furthermore this cycle must include at least one
inductive rule.  Since an inductive rule has a time suffix $S := N+1$, where
$N$ is the timestamp of its body, and $P$'s deductive reduction is
syntactically stratifiable, we know that the aggregate or negation of $q$ must
always occur in a strictly earlier or later timestamp than that of the positive
$q$ atom.  Since the timestep in the cycle increases monotonically with each
iteration, $q$ will never, in practice, depend on a negation or aggregate of
itself.  Thus, $P$ is locally stratifiable, and by Lemma XXX above, $P$ has a
unique minimal model.  This contradicts our assumption that $P$ does not have a
unique minimal model.  Thus, $P$ has a unique minimal model.
%
\end{proof}

\paa{I don't think we can show that programs with async rules are locally stratifiable, actually}
\wrm{Why not?  What if we have that "causality constraint" we were talking about?}

\section{Traces}

\wrm{I don't know what you mean by ground atoms, so I changed "ground atom" to fact}

%Consider a non-empty EDB $E$, an empty MBD $M$ and IDB $I$ and a program $P$.  Evaluating $P$ against $E$ may derive facts in $M$ and $I$.

%\begin{definition}
%A \emph{trace} is any set of facts from the EDB, MDB or IDB of a Dedalus program evaluation.
%\end{definition}

%\wrm{lol, why do we need the notion of an incomplete trace?}

\begin{definition}
%
A \emph{complete trace} of an evaluation of a Dedalus instance is the union of
the given EDB with the derived IDB and MDB.
%
\end{definition}

\begin{lemma}
%
A complete trace of a Dedalus instance $(P,E)$ is its unique minimal model.
%
\end{lemma}

\wrm{===stopped here due to wanting some sleep.  i'll look at this again tomorrow===}

If we evaluate E given P, and P is stratifiable, the resulting set of ground atoms is a minimal model.
In our case, however, successor causes our EDB to be infinite, so the minimal model of any Dedalus program 
with temporal rules is potentially infinite.  \paa{but we'd like to show that a weaker property holds: that for any value $N$
in the \emph{successor} relation, the resulting program has a minimal model.}

\begin{definition}
A \emph{minimal trace} is a subset of a complete trace that excludes any IDB ground atoms derived through an inductive
rule.
\end{definition}

A minimal trace is equivalent to the complete trace of which is is a subset: the latter may be derived from the former by repeated
applications of inductive rules.  A minimal trace records the nondeterminism caused by the delay or reordering of async rules, and
is equivalent to the original program execution.

\begin{definition}
A \emph{reduced trace} is a minimal trace with normalized time suffixes starting with 0 and increasing by 1 at each step.
\end{definition}

show a (trivial) procedure for reduction and make some claims about equivalences without entanglement.

\begin{definition}
A \emph{event trace} is a Dedalus EDB.
\end{definition}

An event trace and program P may be used to generate a new IDB and MDB.  The MDB is virtually certain to differ from that of another
execution, while the IDB may differ, depending on its dependency on the MDB.  The union of these three databases is of course a
mimimal model, but probably not the same minimal model from another execution.  \paa{but can we say that it will often be true that if we project 
out the time attribute from every predicate, the minimal models will be the same? it won't always be true...}

\section{Cost Model}
 

\end{document}
