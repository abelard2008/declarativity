\documentclass{acm_proc_article-sp-sigmod09}

%%\usepackage{amsthm}


\usepackage[usenames, dvipsnames]{color}
\usepackage{times}
%%\usepackage{url}
%%\usepackage{graphicx}
%%\usepackage{boxedminipage}
\usepackage{xspace}
\usepackage{textcomp}
\usepackage{wrapfig}
\usepackage{url}
%%\usepackage{verbatim}
%%\usepackage{latexsym}
\usepackage{amsmath, amssymb}
%%\usepackage{amsthm}

\usepackage{alltt}
\usepackage{appendix}


\newcommand{\jmh}[1]{{\textcolor{red}{#1 -- jmh}}}
\newcommand{\paa}[1]{{\textcolor{blue}{#1 -- paa}}}
\newcommand{\rcs}[1]{{\textcolor{green}{#1 -- rcs}}}
\newcommand{\nrc}[1]{{\textcolor{magenta}{#1 -- nrc}}}
\newcommand{\wrm}[1]{{\color{BurntOrange}{#1 -- wrm}}}
\newcommand{\smallurl}[1]{{\small \url{#1}}}

%dedalus environment for code
\newenvironment{Dedalus}{
\vspace{0.5em}\begin{minipage}{0.95\textwidth}%\linespread{1.3}
\begin{alltt}\fontsize{9pt}{9pt}\selectfont}
{\end{alltt}\end{minipage}\vspace{0.5em}}

\newcommand{\dedalus}[1]{\texttt{\fontsize{9pt}{9pt}\selectfont #1}}


\begin{document}


We take as our foundation language an augmented version of \linebreak
$\lnot$Datalog~\cite{ullmanbook} with aggregate function
symbols.  In general, we are interested in the classes of statically
stratifiable and locally stratifiable programs~\cite{prz}.  An exception is our
use of the \emph{choice} construct~\cite{greedychoice, eventchoice} to model
nondeterministic selection of an element from a set.  We use this construct to
model both the nondeterminism of message delay, and the semantics of key
maintenance in prior deductive update models like Overlog~\cite{boon}.

We consider an infinite universe of constants \emph{C}, in which
$C_{1}, C_{2}, [...], C_{n}$ are representations of individual constants, and
an infinite universe of variable symbols \emph{A} which may take on the values
of any constants.   We also consider the set of positive integers $\mathbb{Z}$,
which represents the set of possible times, its obvious total order
\dedalus{successor} and a symbol that represents ``never''.

\section{Syntactic Restrictions}
%%\jmh{I wonder if it wouldn't be better to do a totally syntactic definition of Dedalus as a restricted subclass of Datalog+stratification+successor, with some convenience %%notation that falls out of the restrictions.  It would ensure that we don't skip steps, and allow us to fall back on proofs about Datalog without being sloppy.  The intro %%paragraph before is only halfway formal and might be better off with a firm basis in citeable Datalog papers.}

%%A Dedalus program is a Datalog program in which every predicate is annotated with a time suffix.  \jmh{Already some slop ... you want to define it via Datalog+strat
%%+succ.  You could start by using Datalog notation but requiring the last attribute of each predicate to range over $\mathbb{Z}$, and then introduce the @-sign notation.}  
%%A Dedalus predicate has the following form:

%%$p(A_{1}, A_{2}, [...], A_{n})@S$

We make the restriction that the final attribute of every predicate be of an
integer type \wrm{we really want an inclusion constraint not just in the set of integers, but in the set of all possible times, in case time is finite}.  We will refer to this final attribute, common to all predicates,
as the \emph{time suffix}.  Facts are defined just as in Datalog, thus a fact
will have a constant integer value for its time suffix: e.g.


$p(C_{1},C_{2},[...],C_{n}, i) |  i \in \mathbb{Z}$


We further consider only \emph{well-formed} rules defined as follows.  Every
subgoal of a rule's body is required to use a common variable, perhaps
represented by symbol $N$, for its time suffix.  $N$ must not be otherwise
constrained (e.g. it must not occur in the rule body except as a time suffix).


The head of a well-formed rule similarly contains a time suffix $S$, which must
be constrained in exactly one of three ways:

\begin{enumerate}

\item The rule is said to be \emph{deductive} or {\em atemporal} if $S$ is
bound to the value of $N$.  That is, the body contains a subgoal of the form:
\dedalus{S := N}.

\item The rule is said to be {\em inductive} if $S$ is the successor
of $N$.  That is, the body contains a subgoal of the form:
\dedalus{successor(N, S)}.

\item The rule is said to be {\em asynchronous} if $S$ is unrelated to the
value of $N$ in the body.  We express this independence by adding two subgoals
to the body: \dedalus{successor(\_, S), choose((\_), (S))}.  The
\dedalus{choice} subgoal ensures that the $S$ value projected into the head of
the rule is some arbitrary $S$-value of \emph{successor}. \wrm{Why can't we
select the initial time?  What we should do instead is have some unary relation
time(T) that captures all possible times, and choose from this relation
instead.  We can assume an inclusion constraint forcing successor's arguments
to both come from this relation.}

\end{enumerate}

We collectively refer to the latter two types of rules as {\em temporal} rules,
as their derivations may exist in a distinct timestep from that of their
inputs.

\subsection{Abbreviated Syntax and Intuition}

Dedalus comprises the subset of Datalog defined above, along with some syntactic sugar.  The body predicates of all well-formed rule have a 
variable $N$ in the time suffix unbound in the rest of the rule: we may therefore omit this attribute from the syntax.  The inclusion of the \emph{successor}
and \emph{choice} predicates is functionally determined by the rule type (inductive or asynchronous), so we omit also these predicates
from the body.  The rule type is then indicated by a special suffix of the rule head, in the form:

$r(A_{1},A_{2},[...],A_{n})@S$

Where $S$ is one of the following:
\begin{enumerate}
\item \emph{now}: a deductive rule, in which all predicates share the same time suffix.
\item \emph{next}: an inductive rule, in which \emph{successor} is included as described above, and the time suffix of the head predicate
is the successor of those of the body predicates. 
\item \emph{async}: an asynchronous rule, in which the time suffix of the head predicate is chosen nondeterministically from the \emph{successor} 
relation.
\end{enumerate}


A Datalog fact is simply a rule head with an empty body and all ground terms for its attributes.  To accommodate this in the abbreviated syntax,
we allow a fourth suffix for the special case of empty bodies: a constant integer indicating the time at which the fact is true.  A Dedalus fact thus has the form:

$r(C_1, C_2, [...], C_n)@CI$

where $CI$ is an integer constant.


%Finally, we define the following shorthand for referring to the special IDB relations defined above.  Recall that for every EDB predicate $r$
%we have a uniquely defined pair of IDB predicates $r\_pos$ and $r\_neg$.  In a Dedalus program, we use $r$ as shorthand for $r\_pos$ 
%(recall that the true EDB predicate $r$ cannot be referenced by any rules) and $delete$ $r$ as shorthand for $r\_neg$.
%%A deductive rule as defined above will hold for any assignment of a constant integer to the $N$-value in the suffix of each predicate.

\subsection{Events}

\wrm{bunch of random definitions}

\newdef{definition}{Definition} \begin{definition}
%
A {\em Dedalus program} is a set of Dedalus rules, partitioned by location.
%
\end{definition}

\newdef{definition}{Definition} \begin{definition} 
%
An \emph{extensional} relation in a Dedalus program is a relation that does not
appear in the head of any rule in the program.
%
\end{definition}

\newdef{definition}{Definition} \begin{definition}
%
A \emph{modifiable} relation in a Dedalus program is a relation that appears in
the head of one or more asynchronous rules in the program.
%
\end{definition}

\newdef{definition}{Definition} \begin{definition}
%
An \emph{intensional} relation in a Dedalus program is a relation that appears
in the head of one or more deductive or atemporal rules in the program, and
appears in no asynchronous rules in the program.
%
\end{definition}

We refer to the sets of facts in extensional, modifiable, and intensional
predicates respectively as the EDB, MDB, and IDB.

The EDB, MDB, and IDB are all pairwise disjoint.  Intuitively, the distinction
between the MDB and IDB is that the MDB is determined nondeterministically from
the IDB, EDB and MDB, while the IDB is determined deterministically from the
IDB, EDB and MDB.  Thus, given an EDB, and a distributed system, all IDB
predicates that do not transitively depend on MDB predicates can be evaluated
deterministically.

For every EDB relation $r$ in a program $P$, we add to $P$ two relations
$r\_pos$ and $r\_neg$ with the same types, and a rule of the form:

$r\_pos(A_1, A_2, [...], A_n) \leftarrow r(A_1, A_2, [...], A_n);$

\wrm{Are we missing the time suffixes here?} That is, for every EDB predicate
$r$ there is an IDB predicate $r\_pos$ that contains at least the contents of
$r$.  We further restrict all rules in P to refer only to IDB and MDB
predicates, and to reference $r\_neg$ for any relation $r$ only in the head of
a rule, and never in the body \wrm{then, how do we write persistence rules?}.
In a Dedalus program, we use $r$ as shorthand for $r\_pos$ (as the true EDB
predicate $r$ cannot be referenced by any rules) and $delete$ $r$ as shorthand
for $r\_neg$.

\newdef{definition}{Definition} \begin{definition}
%
An \emph{event} in Dedalus is an EDB fact.
%
\end{definition}

Since an EDB relation may not appear in a rule's head, events come from sources
external to the Dedalus program, and serve as ground for the distributed
computaion.

%\paa{careful.  messages to myself? if they are given, \emph{when} are they given?}
\subsection{Simple Persistence}

append-only first

\subsection{Mutable State}

introduce del\_p.

\end{document}
