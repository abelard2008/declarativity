\documentclass{acm_proc_article-sp-sigmod09}

%%\usepackage{amsthm}


\usepackage[usenames, dvipsnames]{color}
\usepackage{times}
%%\usepackage{url}
%%\usepackage{graphicx}
%%\usepackage{boxedminipage}
\usepackage{xspace}
\usepackage{textcomp}
\usepackage{wrapfig}
\usepackage{url}
%%\usepackage{verbatim}
%%\usepackage{latexsym}
\usepackage{amsmath, amssymb}
%%\usepackage{amsthm}

\usepackage{alltt}
\usepackage{appendix}


\newcommand{\jmh}[1]{{\textcolor{red}{#1 -- jmh}}}
\newcommand{\paa}[1]{{\textcolor{blue}{#1 -- paa}}}
\newcommand{\rcs}[1]{{\textcolor{green}{#1 -- rcs}}}
\newcommand{\nrc}[1]{{\textcolor{magenta}{#1 -- nrc}}}
\newcommand{\wrm}[1]{{\color{BurntOrange}{#1 -- wrm}}}
\newcommand{\smallurl}[1]{{\small \url{#1}}}

%dedalus environment for code
\newenvironment{Dedalus}{
\vspace{0.5em}\begin{minipage}{0.95\textwidth}%\linespread{1.3}
\begin{alltt}\fontsize{9pt}{9pt}\selectfont}
{\end{alltt}\end{minipage}\vspace{0.5em}}

\newcommand{\dedalus}[1]{\texttt{\fontsize{9pt}{9pt}\selectfont #1}}


\begin{document}


We take as our foundation language an augmented version of \linebreak
$\lnot$Datalog~\cite{ullmanbook} with aggregate function
symbols.  In general, we are interested in the classes of statically
stratifiable and locally stratifiable programs~\cite{prz}.  An exception is our
use of the \emph{choice} construct~\cite{greedychoice, eventchoice} to model
nondeterministic selection of an element from a set.  We use this construct to
model both the nondeterminism of message delay, and the semantics of key
maintenance in prior deductive update models like Overlog~\cite{boon}.

We consider an infinite universe of constants \emph{C}, in which
$C_{1}, C_{2}, [...], C_{n}$ are representations of individual constants, and
an infinite universe of variable symbols \emph{A} which may take on the values
of any constants.   We also consider the set of positive integers $\mathbb{Z}$,
which represents the set of possible times, its obvious total order
\dedalus{successor} and a symbol that represents ``never''.

\section{Syntactic Restrictions}
%%\jmh{I wonder if it wouldn't be better to do a totally syntactic definition of Dedalus as a restricted subclass of Datalog+stratification+successor, with some convenience %%notation that falls out of the restrictions.  It would ensure that we don't skip steps, and allow us to fall back on proofs about Datalog without being sloppy.  The intro %%paragraph before is only halfway formal and might be better off with a firm basis in citeable Datalog papers.}

%%A Dedalus program is a Datalog program in which every predicate is annotated with a time suffix.  \jmh{Already some slop ... you want to define it via Datalog+strat
%%+succ.  You could start by using Datalog notation but requiring the last attribute of each predicate to range over $\mathbb{Z}$, and then introduce the @-sign notation.}  
%%A Dedalus predicate has the following form:

%%$p(A_{1}, A_{2}, [...], A_{n})@S$

We make the restriction that the final attribute of every predicate be of an
integer type \wrm{we really want an inclusion constraint not just in the set of integers, but in the set of all possible times, in case time is finite}.  We will refer to this final attribute, common to all predicates,
as the \emph{time suffix}.  Facts are defined just as in Datalog, thus a fact
will have a constant integer value for its time suffix: e.g.


$p(C_{1},C_{2},[...],C_{n}, i) |  i \in \mathbb{Z}$


We further consider only \emph{well-formed} rules defined as follows.  Every
subgoal of a rule's body is required to use a common variable, perhaps
represented by symbol $N$, for its time suffix.  $N$ must not be otherwise
constrained (e.g. it must not occur in the rule body except as a time suffix).


The head of a well-formed rule similarly contains a time suffix $S$, which must
be constrained in exactly one of three ways:

\begin{enumerate}

\item The rule is said to be \emph{deductive} or {\em atemporal} if $S$ is
bound to the value of $N$.  That is, the body contains a subgoal of the form:
\dedalus{S := N}.

\item The rule is said to be {\em inductive} if $S$ is the successor
of $N$.  That is, the body contains a subgoal of the form:
\dedalus{successor(N, S)}.

\item The rule is said to be {\em asynchronous} if $S$ is unrelated to the
value of $N$ in the body.  We express this independence by adding two subgoals
to the body: \dedalus{successor(\_, S), choose((\_), (S))}.  The
\dedalus{choice} subgoal ensures that the $S$ value projected into the head of
the rule is some arbitrary $S$-value of \emph{successor}. \wrm{Why can't we
select the initial time?  What we should do instead is have some unary relation
time(T) that captures all possible times, and choose from this relation
instead.  We can assume an inclusion constraint forcing successor's arguments
to both come from this relation.}

\end{enumerate}

We collectively refer to the latter two types of rules as {\em temporal} rules,
as their derivations may exist in a distinct timestep from that of their
inputs.

\subsection{Abbreviated Syntax and Intuition}

Dedalus comprises the subset of Datalog defined above, along with some syntactic sugar.  The body predicates of all well-formed rule have a 
variable $N$ in the time suffix unbound in the rest of the rule: we may therefore omit this attribute from the syntax.  The inclusion of the \emph{successor}
and \emph{choice} predicates is functionally determined by the rule type (inductive or asynchronous), so we omit also these predicates
from the body.  The rule type is then indicated by a special suffix of the rule head, in the form:

$r(A_{1},A_{2},[...],A_{n})@S$

Where $S$ is one of the following:
\begin{enumerate}
\item \emph{now}: a deductive rule, in which all predicates share the same time suffix.
\item \emph{next}: an inductive rule, in which \emph{successor} is included as described above, and the time suffix of the head predicate
is the successor of those of the body predicates. 
\item \emph{async}: an asynchronous rule, in which the time suffix of the head predicate is chosen nondeterministically from the \emph{successor} 
relation.
\end{enumerate}


A Datalog fact is simply a rule head with an empty body and all ground terms for its attributes.  To accommodate this in the abbreviated syntax,
we allow a fourth suffix for the special case of empty bodies: a constant integer indicating the time at which the fact is true.  A Dedalus fact thus has the form:

$r(C_1, C_2, [...], C_n)@CI$

where $CI$ is an integer constant.


%Finally, we define the following shorthand for referring to the special IDB relations defined above.  Recall that for every EDB predicate $r$
%we have a uniquely defined pair of IDB predicates $r\_pos$ and $r\_neg$.  In a Dedalus program, we use $r$ as shorthand for $r\_pos$ 
%(recall that the true EDB predicate $r$ cannot be referenced by any rules) and $delete$ $r$ as shorthand for $r\_neg$.
%%A deductive rule as defined above will hold for any assignment of a constant integer to the $N$-value in the suffix of each predicate.

\subsection{Events}

\wrm{bunch of random definitions}

\newdef{definition}{Definition}
 \begin{definition}
%
A {\em Dedalus program} is a set of Dedalus rules, partitioned by location.
%
\end{definition}

%%\newdef{definition}{Definition} 
\begin{definition} 
%
An \emph{extensional} relation in a Dedalus program is a relation that does not
appear in the head of any rule in the program.
%
\end{definition}

%%\newdef{definition}{Definition} 
\begin{definition}
%
A \emph{modifiable} relation in a Dedalus program is a relation that appears in
the head of one or more asynchronous rules in the program.
%
\end{definition}

%%\newdef{definition}{Definition}
 \begin{definition}
%
An \emph{intensional} relation in a Dedalus program is a relation that appears
in the head of one or more deductive or atemporal rules in the program, and
appears in no asynchronous rules in the program.
%
\end{definition}

We refer to the sets of facts in extensional, modifiable, and intensional
predicates respectively as the EDB, MDB, and IDB.

The EDB, MDB, and IDB are all pairwise disjoint.  Intuitively, the distinction
between the MDB and IDB is that the MDB is determined nondeterministically from
the IDB, EDB and MDB, while the IDB is determined deterministically from the
IDB, EDB and MDB.  Thus, given an EDB, and a distributed system, all IDB
predicates that do not transitively depend on MDB predicates can be evaluated
deterministically.

For every EDB relation $r$ in a program $P$, we add to $P$ two relations
$r\_pos$ and $r\_neg$ with the same types, and a rule of the form:

$r\_pos(A_1, A_2, [...], A_n) \leftarrow r(A_1, A_2, [...], A_n);$

\wrm{Are we missing the time suffixes here?} That is, for every EDB predicate
$r$ there is an IDB predicate $r\_pos$ that contains at least the contents of
$r$.  We further restrict all rules in P to refer only to IDB and MDB
predicates, and to reference $r\_neg$ for any relation $r$ only in the head of
a rule, and never in the body \wrm{then, how do we write persistence rules?}.
In a Dedalus program, we use $r$ as shorthand for $r\_pos$ (as the true EDB
predicate $r$ cannot be referenced by any rules) and $delete$ $r$ as shorthand
for $r\_neg$.

%%\newdef{definition}{Definition} 
\begin{definition}
%
An \emph{event} in Dedalus is an EDB fact.
%
\end{definition}

Since an EDB relation may not appear in a rule's head, events come from sources
external to the Dedalus program, and serve as ground for the distributed
computaion.

%\paa{careful.  messages to myself? if they are given, \emph{when} are they given?}
\subsection{Simple Persistence}

A fact for a predice $p$ may provide ground for deductive rules for which the other body predicates have 
tuples that have the same constant value for the time suffix.  It may also provide 
ground for deductive rules whose body predicates have tuples in higher timesteps, provided 
that an inductive persistence rule exists for $p$ in the form 

$p_pos(A_1,A_2,[...],A_n)@next \leftarrow 
p_pos(A_1,A_2,[...],A_n);$

If we are given a fact 

$p(C_1, C_2,[...],C_n)@i |   i \in \mathbb{Z}$


and the basic persistence rule above, we know that the ground atom

$p\_pos(C_1, C_2,[...],C_n)@j | j \in \mathbb{Z}$

will also be true, if $j >= i$.

\subsection{Mutable State}

The tuple defined above is true for all $j > i$ no matter what other deductions may occur.  It will be more useful
to allow the deletion or modification of tuples across time (as defined by the \emph{successor} relation).  An
event for the special predicate \emph{p\_neg} breaks the induction defined by the persistence rule:

$p\_pos(A_1,A_2,[...],A_n)@next \leftarrow \\
p\_pos(A_1,A_2,[...],A_n), \\
\lnot p\_neg(A_1,A_2,[...],A_n);
$

If, at any $k$, we have a fact $p\_neg(C_1,C_2,[...],C_n)@k$ with $k \in \mathbb{Z}$,  then in $k$
we do not induce any ground atom $p\_pos(C_1,C_2,[...],C_n)@k+1$ from any ground atom
$p\_pos(C_1,C_2,[...],C_n)@k$.  Nor are any inductions done for any $l > k$ due to this rule.

A database update is an atomic (due to the adjacent timestamps)
pair of events with a deletion of the old value and assertion of the new, in
the form:

$p(C_{1},C_{2},[...],C_{n})@i+1$
\\
$del\_p(D_{1},D_{2},[...],D_{n})@i$

with $C, D \in \textbf{C}$ and with some $D_{i} \neq C_{i} | i < n$.

\section{Stratifiability of Dedalus Programs}

\newtheorem{lemma}{Lemma}
\begin{lemma}
All Dedalus programs without negation have a unique minimal model.
\end{lemma}

\begin{proof}
A Dedalus program without negation is a Datalog program without negation: all such programs have a
unique minimal model.
\end{proof}

We define syntactic stratification of a Dedalus program in the usual way: 

\begin{definition}
A Dedalus program is \emph{syntactically stratifiable} if there exists no cycle with a negative edge in a dependency graph of the program's predicates.
\end{definition}

Such a program may be divided into strongly connected components that are evaluated in the reverse order of the depends-on
relation.

\begin{lemma}
A syntactically stratifiable Dedalus program has a unique minimal model.
\end{lemma}

\begin{proof}
We need to show that converting a Dedalus program to Datalog will not introduce any cycles with negation.  To do so, we would need to either
introduce a cycle where there wasn't one before, or to introduce negation to an existing cycle.  Our rewrite to Datalog adds an attribute
to every predicate, and in some cases adds the predicates \emph{successor} and \emph{choose}.  These built-in predicates may not appear 
in the head of any rule, so we cannot have introduced a cycle.  Nor did we negate any subgoals.  The resulting Datalog program is therefore
stratifiable.  All stratifiable Datalog programs have a unique minimal model.
\end{proof}


\begin{definition}
A \emph{deductive reduction} of a Dedalus program P is a Dedalus program P' in which only the deductive rules from P occur.
\end{definition}

\begin{definition}
A Dedalus program is \emph{temporally stratifiable} if there exists no cycle with a negative edge in a dependency graph of
its deductive reduction.
\end{definition}

%%\newtheorem{theorem}{Theorem}
\begin{lemma}
Any temporally stratifiable Dedalus program without asynchronous rules has a unique minimal model
\end{lemma}
\begin{proof}
We will first consider the case of programs with only deductive and inductive rules.  We know that there is no recursion
through negation in the deductive rules alone, because in that case the Dedalus program would not be temporally 
stratifiable.  So every cycle through negation must at some point pass through an inductive rule, in which the time suffix $S$ in
the head $p$ is strictly one greater than the suffix $N$ in all the predicates of the body.  At least one of these body predicates is mutually recursive
with $p$, because $p$ is a node in a dependency cycle.  Any true ground atom in any such predicate $r$
was derived either via a series of deductive rules derived from $p$ or via an inductive rule referencing $p$.  In the former case, we can
easily see that all of the deductive rules were derived from ground atoms with a time suffix $N < S$.  In the latter, the ground is clearly at 
least $M < N$.  In either case, it is not possible for a cycle to exist among the ground atoms, such that a derived atom depends negatively upon itself.
We may therefore eliminate this node from the cycle.  We proceed in this fashion until there are no cycles with negation in the graph: the program is 
therefore locally stratified.  All locally stratified Datalog programs have a unique minimal model.


\end{proof}

\paa{I don't think we can show that programs with async rules are locally stratifiable, actually}



\section{Traces}

Consider a non-empty EDB E, an empty MBD M and IDB I and a program P.  Evaluating P against E may cause 
ground atoms to appear in M and I.

\begin{definition}
A \emph{trace} is any set of ground atoms from the EDB, MDB or IDB of a Dedalus program evaluation.
\end{definition}

\begin{definition}
A \emph{complete trace} is the union of the given EDB, and the given IDB and MDB.  
\end{definition}

\begin{lemma}
A complete trace of a program P and EDB E is a minimal model for that program and EDB.
\end{lemma}

If we evaluate E given P, and P is stratifiable, the resulting set of ground atoms is a minimal model.
In our case, however, successor causes our EDB to be infinite, so the minimal model of any Dedalus program 
with temporal rules is potentially infinite.  \paa{but we'd like to show that a weaker property holds: that for any value $N$
in the \emph{successor} relation, the resulting program has a minimal model.}

\begin{definition}
A \emph{minimal trace} is a subset of a complete trace that excludes any IDB ground atoms derived through an inductive
rule.
\end{definition}

A minimal trace is equivalent to the complete trace of which is is a subset: the latter may be derived from the former by repeated
applications of inductive rules.  A minimal trace records the nondeterminism caused by the delay or reordering of async rules, and
is equivalent to the original program execution.

\begin{definition}
A \emph{reduced trace} is a minimal trace with normalized time suffixes starting with 0 and increasing by 1 at each step.
\end{definition}

show a (trivial) procedure for reduction and make some claims about equivalences without entanglement.

\begin{definition}
A \emph{event trace} is a Dedalus EDB.
\end{definition}

An event trace and program P may be used to generate a new IDB and MDB.  The MDB is virtually certain to differ from that of another
execution, while the IDB may differ, depending on its dependency on the MDB.  The union of these three databases is of course a
mimimal model, but probably not the same minimal model from another execution.  \paa{but can we say that it will often be true that if we project 
out the time attribute from every predicate, the minimal models will be the same? it won't always be true...}

\section{Cost Model}
 

\end{document}
