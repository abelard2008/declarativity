\documentclass{acm_proc_article-sp-sigmod09}

%%\usepackage{amsthm}


\usepackage[usenames, dvipsnames]{color}
\usepackage{times}
%%\usepackage{url}
%%\usepackage{graphicx}
%%\usepackage{boxedminipage}
\usepackage{xspace}
\usepackage{textcomp}
\usepackage{wrapfig}
\usepackage{url}
%%\usepackage{verbatim}
%%\usepackage{latexsym}
\usepackage{amsmath, amssymb}
%%\usepackage{amsthm}

\usepackage{alltt}
\usepackage{appendix}

\usepackage{txfonts}
\newcommand{\Tau}{\mathcal{T}}

\newcommand{\jmh}[1]{{\textcolor{red}{#1 -- jmh}}}
\newcommand{\paa}[1]{{\textcolor{blue}{#1 -- paa}}}
\newcommand{\rcs}[1]{{\textcolor{green}{#1 -- rcs}}}
\newcommand{\nrc}[1]{{\textcolor{magenta}{#1 -- nrc}}}
\newcommand{\wrm}[1]{{\color{BurntOrange}{#1 -- wrm}}}
\newcommand{\smallurl}[1]{{\small \url{#1}}}

%dedalus environment for code
\newenvironment{Dedalus}{
\vspace{0.5em}\begin{minipage}{0.95\textwidth}%\linespread{1.3}
\begin{alltt}\fontsize{9pt}{9pt}\selectfont}
{\end{alltt}\end{minipage}\vspace{0.5em}}

\newcommand{\dedalus}[1]{\texttt{\fontsize{9pt}{9pt}\selectfont #1}}


\begin{document}


We take as our foundation 
%language 
an augmented version of \linebreak
$\lnot$Datalog~\cite{ullmanbook} with aggregate function
symbols akin to those of SQL (min, max, avg, stdev, count).  In general, we are interested in the classes of statically
stratifiable and locally stratifiable programs~\cite{prz}.  In addition, we admit the
use of the \emph{choice} construct~\cite{greedychoice, eventchoice} to model
nondeterministic selection of an element from a set.  
\jmh{save the next sentence for later.  stay pure here.}
In \dedalus, we will use this construct to
model both the nondeterminism of message delay, and the semantics of key
maintenance in prior deductive update models like Overlog~\cite{boon}.

\jmh{Can't we borrow this from somebody else rather than define it ourselves?  ``As in Ullman, et al [FOO] we represent...''}
As a matter of notation, we refer to an infinite universe of constants \emph{C}, in which
$C_{1}, C_{2}, \ldots$ are representations of individual constants, and
an infinite universe of variable symbols $A = A_1, A_2, \ldots$, and a distinguished variable $\Tau$.
% which may take on the values
% of any constants.   
We also make use of the set of positive integers $\mathbb{Z}$,
(which we will use to represent possible times), along with its natural total order
\dedalus{successor($A_i, A_j$)} and a distinguished constant symbol $\perp$ that we will use to represent ``never''.

\section{Syntactic Restrictions}
%%\jmh{I wonder if it wouldn't be better to do a totally syntactic definition of Dedalus as a restricted subclass of Datalog+stratification+successor, with some convenience %%notation that falls out of the restrictions.  It would ensure that we don't skip steps, and allow us to fall back on proofs about Datalog without being sloppy.  The intro %%paragraph before is only halfway formal and might be better off with a firm basis in citeable Datalog papers.}

%%A Dedalus program is a Datalog program in which every predicate is annotated with a time suffix.  \jmh{Already some slop ... you want to define it via Datalog+strat
%%+succ.  You could start by using Datalog notation but requiring the last attribute of each predicate to range over $\mathbb{Z}$, and then introduce the @-sign notation.}  
%%A Dedalus predicate has the following form:

%%$p(A_{1}, A_{2}, [...], A_{n})@S$
We will define \dedalus as a restricted sublanguage of the augmented version of $\lnot$Datalog defined above, with some notational shortcuts that fall out naturally.

Our first restriction is on the admissible schemata of our language. We  require that the final attribute of every \dedalus predicate range over the set $\mathbb{Z}$.  In a typical interpretation, \dedalus programs will use this final attribute to connote ``timestamps'', so we refer to this attribute at the \emph{time suffix} of the corresponding predicate.  \wrm{we really want an inclusion constraint not just in the set of integers, but in the set of all possible times, in case time is finite}.  \jmh{I disagree, actually.  EDB facts can be sprinkled throughout time without restriction, and the rule syntax below provides the restrictions you want.  you're hinting at the reduction stuff below, but we can rewrite to that.}  

Facts are defined just as in Datalog, thus a fact
will have a constant integer value for its time suffix: e.g.


$p(C_{1},C_{2},[...],C_{n}, i) |  i \in \mathbb{Z}$

Our second restriction is on rules.  A {\em well-formed }\dedalus rule is a Datalog rule that adheres to the following constraints on body and head.  
In the rule body, every
subgoal is required to use the distinguished variable $\Tau$ as its time suffix.  
\jmh{I would not introduce the following constraint -- can't we have rules that fire at a particular timestep?  It may slightly complicate your reductions later, but it seems manageable.}
$\Tau$ must not be otherwise
constrained (e.g. it must not occur in the rule body except as a time suffix).
The head of a well-formed rule similarly contains a time suffix $S$, which must
be constrained in exactly one of the following three ways:

\begin{enumerate}

\item The rule is said to be \emph{deductive} if $S$ is
bound to the value $\Tau$.  That is, the body contains a subgoal of the form:
\dedalus{S = $\Tau$}.

\item The rule is said to be {\em inductive} if $S$ is the successor
of $\Tau$.  That is, the body contains a subgoal of the form:
\dedalus{successor($\Tau$, S)}.

\item The rule is said to be {\em asynchronous} if $S$ results from a non-deterministic choice function, which may be independent of $\Tau$.  We express this by adding two subgoals
to the body: \dedalus{successor(\_, $\Tau$), choose((\_), ($\Tau$))}.  The
\dedalus{choice} subgoal ensures that the $\Tau$ value projected into the head of
the rule is some arbitrary $\Tau$-value of \emph{successor}. \wrm{Why can't we
select the initial time?  What we should do instead is have some unary relation
time(T) that captures all possible times, and choose from this relation
instead.  We can assume an inclusion constraint forcing successor's arguments
to both come from this relation.}  \jmh{Good point.  OTOH I suspect we'll have to forbid messages into the past, in which case this will be fine (and succinct).}  \jmh{Actually, we should be able to express delays that are a function of attributes -- e.g. a sender-receiver pair may be input to a real-world delay distribution, as might be the time.}

\end{enumerate}

\jmh{Ack ... deductive rules are unsafe, and technically Datalog-neg forbids them due to the free variable in the head.  So you will need to expand your language to include an acceptable notion of per-timestep safety (as Maier suggested), at which point it's not a subset of Datalog-neg.  Would be nice to be able to say ``Dedalus is a subset of (Datalog + \{set of addons\})'' but that would require defining the acceptable saftey before defining timestamps (which are a restriction).}

\subsection{Abbreviated Syntax and Temporal Interpretation}
We have been careful to define Dedalus as a syntactic subset of a natural variant of Datalog; this allows us to take advantage of Datalog's well-known semantics and the rich literature on the language.  

However Dedalus programs are intended to capture naturally temporal semantics.  For example, a fact with some constant $C_i$ in its time suffix can be thought of as a fact that is true ``at time $C_i$''.  Deductive rules can be seen as {\em atemporal} statements: they range over all values of the time suffix, and express deductions that are ``always'' valid.
Inductive and asynchronous rules are {\em temporal}:
their consequents are defined to be true ``at a different time'' than their antecedents. 

To simplify Dedalus notation for this typical interpretation,  we introduce some natural syntactic ``sugar'' as follows:  

\begin{itemize}
	\item {\em Time-suffix notation:}  The final, time-suffix attribute of each predicate is placed after the predicate's right parenthesis, separated by the symbol `@'.   For example, the predicate $r(A_{1}, \ldots, A_{n}, S)$ is rewritten as $r(A_{1}, \ldots, A_{n})@S$.
	\item {\em Implicit time-suffixes in body predicates:} Since all body predicates of a well-formed rule have a free variable $\Tau$ in the time suffix, we omit the time suffix from body predicates and treat it as implicit. 
	\item {\em Temporal head annotation:} The inclusion of the \emph{successor}
and \emph{choice} predicates in the body is promoted to a keyword in the time suffix of the head predicate, in the form:

$r(A_{1},A_{2},[...],A_{n})@S$

where $S$ is one of the following:
\begin{enumerate}
\item \emph{now}: a deductive rule, in which all predicates implicitly share the same time suffix $\Tau$.
\item \emph{next}: an inductive rule, in which the \emph{successor($\Tau$, S)} predicate is implicitly included in the body as described above, and $S$ is implicitly the time suffix of the head
\item \emph{async}: an asynchronous rule, in which the time suffix of the head predicate is implicitly chosen nondeterministically via choice as described above.
\end{enumerate}
\end{itemize}

% \jmh{the following is redundant and can be omitted}
% Dedalus facts are just datalog facts that conform to the schema constraint:  rule heads with empty bodies, and ground terms for all attributes including the time suffix.  To accommodate this in our notation,
% we allow a fourth suffix for the special case of empty bodies: a constant integer.  A Dedalus fact thus has the form:
% 
% $r(C_1, C_2, [...], C_n)@CI$
% 
% where $CI$ is an integer constant.


%Finally, we define the following shorthand for referring to the special IDB relations defined above.  Recall that for every EDB predicate $r$
%we have a uniquely defined pair of IDB predicates $r\_pos$ and $r\_neg$.  In a Dedalus program, we use $r$ as shorthand for $r\_pos$ 
%(recall that the true EDB predicate $r$ cannot be referenced by any rules) and $delete$ $r$ as shorthand for $r\_neg$.
%%A deductive rule as defined above will hold for any assignment of a constant integer to the $N$-value in the suffix of each predicate.

\subsection{Events}

\newdef{definition}{Definition}

\begin{definition}
%
A {\em Dedalus program} is a set of Dedalus rules.
%
\end{definition}

\begin{definition} 
%
An \emph{extensional} relation in a Dedalus program is a relation that does not
appear in the head of any rule in the program.
%
\end{definition}

\begin{definition}
%
A \emph{modifiable} relation in a Dedalus program is a relation that appears in
the head of one or more asynchronous rules in the program.
%
\end{definition}

 \begin{definition}
%
An \emph{intensional} relation in a Dedalus program is a relation that appears
in the head of one or more atemporal rules in the program, but never in the head of a temporal rule.
%
\end{definition}

We refer to the sets of facts in extensional, modifiable, and intensional
predicates respectively as the EDB, MDB, and IDB.

\jmh{introduction of the MDB doesn't seem useful, actually.  I'd drop this, and if you need to define a ``mutable'' relation as one that participates in the head of a temporal rule, you can do so as needed.}
The EDB, MDB, and IDB are all pairwise disjoint.  Intuitively, the distinction
between the MDB and IDB is that the MDB is determined nondeterministically from
the IDB, EDB and MDB, while the IDB is determined deterministically from the
IDB, EDB and MDB.  Thus, given an EDB, and a distributed system, \jmh{a what??  distribution is not part of the language description!} all IDB
predicates that do not transitively depend on MDB predicates can be evaluated
deterministically.  \jmh{The only reason to worry about the MDB being non-deterministic is @sync, which you didn't in fact need to introduce yet.  Again, I don't see this discussion being useful.}

\jmh{The following needs to be part of the Datalog-oriented definition of what Dedalus is, in the previous section.  This section is supposed to be syntactic sugar and mental interpretation only.  Moreover, you don't ``introduce'' these predicates; the use of these predicates in this stylized manner is part of the constraints of a ``well-formed'' Dedalus program.}
For every EDB relation $r$ in a program $P$, we add to $P$ two relations
$r\_pos$ and $r\_neg$ with the same schema as $r$, and a rule of the form:

$r\_pos(A_1, A_2, [...], A_n) \leftarrow r(A_1, A_2, [...], A_n);$

\wrm{Are we missing the time suffixes here?} That is, for every EDB predicate
$r$ there is an IDB predicate $r\_pos$ that contains at least the contents of
$r$.  
\jmh{Why not say that you restrict the language so that the only reference to EDB predicates are in the definition of $r\_pos$ and $r\_neg$.}
We further restrict all rules in P to refer only to IDB and MDB
predicates, and to reference $r\_neg$ for any relation $r$ only in the head of
a rule, and never in the body \wrm{then, how do we write persistence rules?}.
In a Dedalus program, we use $r$ as shorthand for $r\_pos$ (as the true EDB
predicate $r$ cannot be referenced by any rules) and $delete$ $r$ as shorthand
for $r\_neg$.

%%\newdef{definition}{Definition} 
\begin{definition}
%
An \emph{event} in Dedalus is an EDB fact.
%
\end{definition}

\jmh{Isn't the following simply a restatement of Datalog's use of EDB?}
Since an extensional relation may not appear in a rule's head, events come from
sources external to the Dedalus program, and serve as ground for the
distributed computaion.  \jmh{remove mention of distribution or computation.  Logic is all syntax!}

%\paa{careful.  messages to myself? if they are given, \emph{when} are they given?}
\section{Stratifiability of Dedalus Programs}

\newtheorem{lemma}{Lemma} 

\begin{lemma} 
%
A Dedalus program without negation, aggregation, and choice has a unique
minimal model.
%
\end{lemma}

\begin{proof} 
%
A Dedalus program without negation, aggregation, and choice is a pure Datalog
program.  Every Datalog program has a unique minimal model. \wrm{cite?  or the
audience knows this}
%
\end{proof}

\jmh{Oops, you forgot that this model is countably infinite due to infinite time. So I could add countably many random consistent facts and have an equally ``small'' model. You will need a more refined definition of safety and minimality that accounts for time.}

\jmh{I'm going to stop commenting here since you'll need some more machinery to continue.}

We define syntactic stratification of a Dedalus program the same way it is
defined for a Datalog program:

\begin{definition}
%
A Dedalus program without choice is \emph{syntactically stratifiable} if there
exists no cycle with a negative edge or an aggregation edge in the program's
predicate dependency graph.
%
\end{definition}

We evaluate such a program by evaluating each strongly connected component of
its predicate dependency graph under a closed-world assumption.  We may
evaluate in any order returned by a topological sort on the predicate
dependency graph with each strongly connected component collapsed to a single
node. \wrm{XXX: is this right?}

\begin{definition}
%
A {\em Dedalus instance} $(P,E)$ is a Dedalus program $P$ along with an EDB
$E$.
%
\end{definition}

\begin{lemma}
%
A syntactically stratifiable Dedalus instance without choice has a unique
minimal model.  That is, there exists a function $D$ from syntactically
stratifiable Dedalus instances without choice to their minimal models.
%
\end{lemma}

\begin{proof}
%
We know that there exists a function $B$ from syntactically stratifiable
Datalog instances to their minimal models.  Earlier, we introduced \wrm{XXX:
where?} a bijection \wrm{XXX: probably not a bijection} $A$ from the set of
Dedalus instances without choice to the set of Datalog instances, and a
bijection $C$ between minimal models of Datalog instances and minimal models of
Dedalus instances without choice.  We will show that $D = C \circ B \circ A$.

Thus, we need only prove that the codomain of $A$ restricted to the set of
syntactically stratifiable Dedalus instances without choice is a subset of
syntactically stratifiable Datalog instance.  We will show this by proving that
$M$ does not add any negated cycles to the instance's predicate dependency
graph.

Since $M$ does not add any rules to the instance, and may introduce only the
non-negated EDB {\em successor} relation to the body of an existing rule, it
does not add any new cycles to, or add negation to any existing cycles in the
instance's predicate dependency graph.
%
\end{proof}

\begin{definition}
%
\wrm{Def of locally stratifiable}
%
\end{definition}

\begin{lemma}
%
A locally stratifiable Dedalus instance without choice has a unique
minimal model.  That is, there exists a function $E$ from locally
stratifiable Dedalus instances without choice to their minimal models.
%
\end{lemma}

\begin{proof}
%
\wrm{TODO}
%
\end{proof}


\begin{definition}
%
A \emph{deductive reduction} of a Dedalus program $P$ is the subset of $P$
consisting of exactly those deductive rules in $P$.
%
\end{definition}

\begin{definition} 
%
A Dedalus program is \emph{temporally stratifiable} if its deductive
reduction is syntactically stratifiable.
%
\end{definition}

%%\newtheorem{theorem}{Theorem}
\begin{lemma}
%
Any temporally stratifiable Dedalus instance $P$ without asynchronous rules has
a unique minimal model
%
\end{lemma} 

\begin{proof}
%
\bf{Case 1:} $P$ consists of only deductive rules.  In this case, $P$'s
deductive reduction is $P$ itself.  We know $P$ is syntactically stratifiable,
thus it has a unique minimal model.

\bf{Case 2:} $P$ consists of only deductive and inductive rules.  Assume $P$
does not have a unique minimal model.  This implies that $P$ is not
syntactically stratifiable, thus there must exist some cycle through at least
one predicate $q$ involving a negation or aggregation edge in $P$'s predicate
dependency graph, and furthermore this cycle must include at least one
inductive rule.  Since an inductive rule has a time suffix $S := N+1$, where
$N$ is the timestamp of its body, and $P$'s deductive reduction is
syntactically stratifiable, we know that the aggregate or negation of $q$ must
always occur in a strictly earlier or later timestamp than that of the positive
$q$ atom.  Since the timestep in the cycle increases monotonically with each
iteration, $q$ will never, in practice, depend on a negation or aggregate of
itself.  Thus, $P$ is locally stratifiable, and by Lemma XXX above, $P$ has a
unique minimal model.  This contradicts our assumption that $P$ does not have a
unique minimal model.  Thus, $P$ has a unique minimal model.
%
\end{proof}

\paa{I don't think we can show that programs with async rules are locally stratifiable, actually}
\wrm{Why not?  What if we have that "causality constraint" we were talking about?}

\section{Traces}

\wrm{I don't know what you mean by ground atoms, so I changed "ground atom" to fact}
\paa{a ground atom is  a predicate with all ground terms.  a fact is precisely an EDB ground atom.}

%Consider a non-empty EDB $E$, an empty MBD $M$ and IDB $I$ and a program $P$.  Evaluating $P$ against $E$ may derive facts in $M$ and $I$.

\begin{definition}
A \emph{trace} is any set of facts from the EDB, MDB or IDB of a Dedalus program evaluation.
\end{definition}

Any trace for a Dedalus instance $(P,E)$ is an interpretation of $(P,E)$.
%\wrm{lol, why do we need the notion of an incomplete trace?}

\begin{definition}
%
A \emph{complete trace} of an evaluation of a Dedalus instance is the union of
the given EDB with the derived IDB and MDB.
%
\end{definition}

\begin{lemma}
%
A complete trace of a Dedalus instance $(P,E)$ is its unique minimal model.
%
\end{lemma}

\wrm{===stopped here due to wanting some sleep.  i'll look at this again tomorrow===}

If we evaluate E given P, and P is stratifiable, the resulting set of ground atoms is a minimal model.
In our case, however, successor causes our EDB to be infinite, so the minimal model of any Dedalus program 
with temporal rules is potentially infinite.  \paa{but we'd like to show that a weaker property holds: that for any value $N$
in the \emph{successor} relation, the resulting program has a minimal model.}

\begin{definition}
A \emph{minimal trace} is a subset of a complete trace that excludes any IDB ground atoms derived through an inductive
rule.
\end{definition}

A minimal trace is equivalent to the complete trace of which is is a subset: the latter may be derived from the former by repeated
applications of inductive rules.  However, a given a Dedalus instance $(P, E)$ and a minimal trace T (where $E \subset T$), a fixpoint
computation will most likely \emph{not} yield a minimal model, because new tuples may be added to the MDB that represent a component 
of a different minimal model, and because these may affect the IDB.  The set of ground atoms $EDB \cup MDB_{old} \cup IDB_{new}$
\emph{may} may be a minimal model, iff $IDB_{new} = IDB_{old}$.  \paa{actually I am not sure if that is true}.  
$(EDB \cup MDB_{old} \cup IDB_{new} \cup IDB_{old})$ is certain to be a model, but is only minimal if $IDB_{new} \subset IDB_{old}$.

A minimal trace records the nondeterminism caused by the delay or reordering of async rules, and
is equivalent to the original program execution.  

\begin{definition}
A \emph{reduced trace} is a minimal trace with normalized time suffixes starting with 0 and increasing by 1 at each step.
\end{definition}

show a (trivial) procedure for reduction and make some claims about equivalences without entanglement.

\begin{definition}
A \emph{event trace} is a Dedalus EDB.
\end{definition}

An event trace and program P may be used to generate a new IDB and MDB.  The MDB is virtually certain to differ from that of another
execution, while the IDB may differ, depending on its dependency on the MDB.  The union of these three databases is of course a
minimal model, but probably not the same minimal model from another execution.  \paa{but can we say that it will often be true that if we project 
out the time attribute from every predicate, the minimal models will be the same? it won't always be true...}

\section{Cost Model}
 
 \section{Language Constructs}
\subsection{Simple Persistence}
\jmh{I think the flavor of this section is to map familiar notions from state manipulation to purely logical syntactic constructs grounded in Datalog.  You should motivate at a high level why one would want to do such a thing.  The discussion below is then, in effect, a set of ``design patterns'' or ``typical uses''.  You might want to highlight the logical invariants that emerge from these Dedalus statements and assert that they capture the semantic intent of state manipulation.}


%%\jmh{Your definition is not self-contained, it makes reference to prose.  The prose is not crisp even as prose -- I don't know what ``later'' means, especially given that you said that @sync could produce any time.}

The intuition behind the \emph{successor} relation is that it models the passage of (logical) time.  Without specifying how and when each stratum
of \emph{successor} is evaluated, we can see that the syntactic restrictions of Dedalus ensure that we cannot move backwards infinitely often (specifically,
we may only move backwards via \emph{choice}, and every call to \emph{choice} may move us forward.  \paa{save for later, pretend there is no async?}).


A fact in predicate $p$ at time $\Tau$ may provide ground for deductive rules
at time $\Tau$, as well as ground for deductive rules in timesteps greater than $\Tau$,
provided there exists a rule of the form:

$p\_pos(A_1,A_2,[...],A_n)@next \leftarrow 
p\_pos(A_1,A_2,[...],A_n);$

%%\begin{definition}
%%A rule of the above form is known as a {\em simple persistence rule}.
%%\end{definition}

A simple persistence rule having the above form ensures that a $p$ fact true at time $i$ will be true
$\forall j \in \mathbb{Z} | j >= i$.  This rule is informally equivalent to the temporal logic assertion
$\forall A \in p\_pos( p\_pos(A) \to \Box p\_pos(A))$.

\subsection{Mutable State}

To model deletions and updates of a fact, it is useful to break the induction
in a simple persistence rule.  Adding a {\em p\_neg} subgoal to the body of a
simple persistence rule accomplishes this:

$p\_pos(A_1,A_2,[...],A_n)@next \leftarrow \\
p\_pos(A_1,A_2,[...],A_n), \\
\lnot p\_neg(A_1,A_2,[...],A_n);
$

%%\begin{definition}
%
%%A rule of the above form is known as a {\em mutable persistence rule}.
%
%%\end{definition}

If, at any time $k$, we have a fact $p\_neg(C_1,C_2,[...],C_n)@k$, then we do
not deduce a $p\_pos(C_1,C_2,[...],C_n)@k+1$ fact.  By induction, we do not
deduce a $p\_pos(C_1,C_2,[...],C_n)@l$ for any $l > k$, unless this $p_pos$
fact is re-derived at some timestep $l > k$ by another rule.  This corresponds to 
the intuition that a persistent fact is true, once stated, is true until it is withdrawn.  

\newtheorem{example}{Example}
\begin{example}
Consider the following Dedalus program and {\em trace} of events:

\begin{Dedalus}
p_pos(A, B) \(\leftarrow\)
  p(A, B);

p_pos(A, B)@next \(\leftarrow\) 
  p_pos(A, B),
  \(\lnot\) p_neg(A, B);

p(1,2)@101;
p(1,3)@102;
p(1,?)@200;
delete p(1,2)@300;
p(1,?)@301;
\end{Dedalus}

It is easy to see that the results of the two queries are:


\begin{Dedalus}
p(1,2)@200;
p(1,3)@200;
p(1,3)@301;
\end{Dedalus}

\end{example}

%%\begin{definition}
%
For some time $\Tau$, an {\em update} is any pair of facts:

$p\_neg(C_{1},C_{2},[...],C_{n})@\Tau$ \\ $p\_pos(D_{1},D_{2},[...],D_{n})@\Tau+1$
%
%%\end{definition}

Intuitively, an update represents replacing an old value of a tuple with a
newer value.  We say the update is {\em atomic across timesteps}, meaning that
the old value ceases to exist at the same timestep in which the new value
exists -- timestep $\Tau+1$ in the above definition.

\subsection{Sequences}


\section{Distribution}


\subsection{Queues}

\subsection{Lamport Clocks}


\subsection{Trace Entanglement}

\end{document}
