 \section{Language Constructs}

%%\jmh{I think the flavor of this section is to map familiar notions from state manipulation to purely logical syntactic constructs grounded in Datalog.  You should motivate 
%%at a high level why one would want to do such a thing.  The discussion below is then, in effect, a set of ``design patterns'' or ``typical uses''.  You might want to highlight 
%%the logical invariants that emerge from these Dedalus statements and assert that they capture the semantic intent of state manipulation.}


%%\jmh{Your definition is not self-contained, it makes reference to prose.  The prose is not crisp even as prose -- I don't know what ``later'' means, especially given that you said that @sync could produce any time.}

The intuition behind the \emph{successor} relation is that it models the passage of (logical) time.  
We may say that ground atoms with lower timestamps occurred ``before" atoms with higher ones.
Without specifying how and when each stratum
of \emph{successor} is evaluated, we can see that the syntactic restrictions of Dedalus ensure that we cannot move backwards infinitely often (specifically,
we may only move backwards via \emph{choice}, and every call to \emph{choice} may move us forward.  \paa{save for later, pretend there is no async?}).
The constraints we imposed on Dedalus rules restrict how deductions may be made with respect to time.  First, rules may only refer to ground atoms that
are true at the same time.  Second, rules may specify deductions that occur concurrently with their ground facts, in the next timestep, or at some
unspecified time: therefore inductions may be specified in one direction only.

This gives us an intuitive and unambiguous way to declaratively express persistence and state changes.  In this section, we 
give examples of language constructs that capture motifs such as persistent relations, deletion and update, sequences
and queues.

\subsection{Simple Persistence}

A fact in predicate $p$ at time $\Tau$ may provide ground for deductive rules
at time $\Tau$, as well as ground for deductive rules in timesteps greater than $\Tau$,
provided there exists a rule of the form:

$p\_pos(A_1,A_2,[...],A_n)@next \leftarrow 
p\_pos(A_1,A_2,[...],A_n);$

%%\begin{definition}
%%A rule of the above form is known as a {\em simple persistence rule}.
%%\end{definition}

A simple persistence rule having the above form ensures that a $p$ fact true at time $i$ will be true
$\forall j \in \mathbb{Z} | j >= i$.  This rule is informally equivalent to the temporal logic assertion

$\forall A \in p\_pos( p\_pos(A) \to \Box p\_pos(A))$.

\subsection{Mutable State}

To model deletions and updates of a fact, it is useful to break the induction
in a simple persistence rule.  Adding a {\em p\_neg} subgoal to the body of a
simple persistence rule accomplishes this:

$p\_pos(A_1,A_2,[...],A_n)@next \leftarrow \\
p\_pos(A_1,A_2,[...],A_n), \\
\lnot p\_neg(A_1,A_2,[...],A_n);
$

%%\begin{definition}
%
%%A rule of the above form is known as a {\em mutable persistence rule}.
%
%%\end{definition}

If, at any time $k$, we have a fact $p\_neg(C_1,C_2,[...],C_n)@k$, then we do
not deduce a $p\_pos(C_1,C_2,[...],C_n)@k+1$ fact.  By induction, we do not
deduce a $p\_pos(C_1,C_2,[...],C_n)@l$ for any $l > k$, unless this $p_pos$
fact is re-derived at some timestep $l > k$ by another rule.  This corresponds to 
the intuition that a persistent fact, once stated, is true until it is withdrawn.  

%%\newtheorem{example}{Example}
\begin{example}
Consider the following Dedalus program and {\em trace} of events:

\begin{Dedalus}
p_pos(A, B) \(\leftarrow\)
  p(A, B);

p_pos(A, B)@next \(\leftarrow\) 
  p_pos(A, B),
  \(\lnot\) p_neg(A, B);

p(1,2)@101;
p(1,3)@102;
p(1,?)@200;
delete p(1,2)@300;
p(1,?)@301;
\end{Dedalus}

It is easy to see that the results of the two queries are:


\begin{Dedalus}
p(1,2)@200;
p(1,3)@200;
p(1,3)@301;
\end{Dedalus}

\end{example}

%%\begin{definition}
%
For some time $\Tau$, an {\em update} is any pair of facts:

$p\_neg(C_{1},C_{2},[...],C_{n})@\Tau$ \\ $p\_pos(D_{1},D_{2},[...],D_{n})@\Tau+1$
%
%%\end{definition}

Intuitively, an update represents replacing an old value of a tuple with a
newer value.  We say the update is {\em atomic across timesteps}, meaning that
the old value ceases to exist at the same timestep in which the new value
exists -- timestep $\Tau+1$ in the above definition.

\subsection{Sequences}

Database sequences, objects that retain and increment a counter value, can be
represented with a pair of inductive rules.  One increments the current counter value when the
trigger event is true, while the other persists the current value of the sequence only when the event is 
not true.  For example:

\begin{Dedalus}
seq(Agent, X + 1)@next \(\leftarrow\)
  seq(Agent, X), 
  event(Agent) 
  
seq(Agent, X)@next \(\leftarrow\) 
  seq(Agent, X, 
  \(\lnot\) event(Agent);
\end{Dedalus}



\section{Distribution}


\subsection{Queues}

%%Consider a trace of events to a 
Consider a predicate \emph{balance\_update} whose attributes are a string indicating the user, a floating point number
indicating the new balance and an integer indicating the order in which the updates were issued, according to some 
external clock or sequence.  

In this trace, all of the time suffixes are the same, e.g.

\begin{Dedalus}
balance\_update("bob", 100.00, 2355)@123;
balance\_update("bob", 75.00, 2358)@123;
balance\_update("alice", 0.00, 2377)@123;
balance\_update("bob", 10.00, 2455)@123;
\end{Dedalus}

Depending on the program that implements the balance update, several behaviors are possible.  We can see that in spite of their
coincidence in logical time, these events need to be processed in a data-dependent order, rather than as a set.  In-order tuple 
processing is difficult to express in Datalog generally, in part because the language has so notion of order of evaluation, except
the implicit ordering implied by stratification.

In the program below, we define a table \emph{m\_balance\_update} that we use as a queue to feed \emph{balance\_update}.  The queue must persist across
timesteps because it may take an unknown number of timesteps to drain it.  At each fixpoint, for each value of \textbf{A}, a single
tuple is projected into \emph{balance\_update} and atomically deleted from \emph{m\_balance\_update}, changing the value of the aggregate calculated at the
subsequent step:


\begin{Dedalus}

m\_balance\_update(A, B, C)@next \(\leftarrow\)
  m\_balance\_update(A, B, C),
  notin del\_m\_balance\_update(A, B, C);

omin(A, min<C>) \(\leftarrow\)
  m\_balance_update(A, _, C);

p(A, B, C)@next \(\leftarrow\)
  m\_balance\_update(A, B, C),
  omin(A, C);

del\_m\_balance\_update(A, B, C) \(\leftarrow\)
  m\_balance\_update(A, B, C),
  omin(A, C);
\end{Dedalus}

Under such a queueing discipline, deductive rules that are predicated on \emph{balance\_update} are constrained to consider only one tuple per fixpoint
per value of the variable \textbf{A}, thus implementing a per-user FIFO discipline.  To enforce a global FIFO ordering over \emph{balance\_update}, 
we may redefine \emph{omin} and any dependent rules to exclude the \textbf{A} atttribute.

A queue establishes a mapping between the local clock and the ordering domain of the input relation. By doing so, we are able to take
advantage of the natural ordering enforced by stratification over time, to enforce an ordering property over our input that is otherwise 
very difficult to express in a logic language.

\subsection{Lamport Clocks}


\subsection{Trace Entanglement}

