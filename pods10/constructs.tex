\section{State in Logic}

%%\jmh{I think the flavor of this section is to map familiar notions from state manipulation to purely logical syntactic constructs grounded in Datalog.  You should motivate 
%%at a high level why one would want to do such a thing.  The discussion below is then, in effect, a set of ``design patterns'' or ``typical uses''.  You might want to highlight 
%%the logical invariants that emerge from these \lang statements and assert that they capture the semantic intent of state manipulation.}


%%\jmh{Your definition is not self-contained, it makes reference to prose.  The prose is not crisp even as prose -- I don't know what ``later'' means, especially given that you said that @sync could produce any time.}


%%\linebreak
\begin{quote}
``Time is a device that was invented to keep everything from happening at once."~\footnote{Graffiti on a wall at Cambridge University~\cite{scheme}}
\end{quote}
Having defined \slang, we are now ready to express traditionally ``operational'' constructs in a proper declarative fashion.  In this section we focus on the notion of ``state'': the persistence and mutability of data across time.

The intuition behind the \emph{successor} relation used to define \slang is that it models the
passage of (logical) time.  In our discussion, we will say that ground atoms with lower timestamps
occur ``before" atoms with higher ones.
%%Without specifying how and when each stratum
%%of \emph{successor} is evaluated, we can see that the syntactic restrictions of \lang ensure that 
%%we cannot move backwards infinitely often (specifically,
%%we may only move backwards via \emph{choice}, and every call to \emph{choice} may move us forward.  \paa{save for later, pretend there is no async?}).
%%we may only move forward in time.
The constraints we imposed on \slang rules restrict how deductions may be made
with respect to time.  First, rules may only refer to a single timestep in
their body, they {\em cannot join across timesteps}.  Second, rules may specify
deductions that occur concurrently with their ground facts or in the next
timestep---in \slang, we rule out induction ``backwards'' in time.
%, or at some unspecified time: 
%therefore inductions may only be specified in one direction only.

With a notion of time captured in this way, we can consider the contents of the extensional database---and hence a minimal model of the intensional database---with respect to an ``instant in time'': we simply bind the free time suffixes of all rules to a constant.  Because this produces a sequence of models (one per timestep), it gives us an intuitive and unambiguous way to declaratively express persistence and state changes across timesteps.  In this section, we 
give examples of language constructs that capture motifs such as persistent relations, deletion and update, sequences
and queues.

\subsection{Simple Persistence}

A fact in predicate $p$ at time $\Tau$ may provide ground for deductive rules
at time $\Tau$, as well as ground for deductive rules in timesteps greater than $\Tau$,
provided there exists a {\em simple persistence rule} -- a rule of the form:

\dedalus{p\pos($A_1$,$A_2$,[...],$A_n$)@next $\leftarrow$
p\pos($A_1$,$A_2$,[...],$A_n$);}

%%\rcs{why do we introduce p\pos?  It came from nowhere.  We need a rule p :- p\pos, right?}
%%\begin{definition}
%%A rule of the above form is known as a {\em simple persistence rule}.
%%\end{definition}

A simple persistence rule ensures that a $p$ fact true at time $i$ will be true
$\forall j \in \mathbb{Z} : j >= i$.  It is interesting to note that we can
express this rule using a temporal logic assertion that makes use of the $\Box$
or ``henceforth'' operator:

$\forall A_1, \ldots, A_n \in C : p$\pos$(A_1, \ldots, A_n) \to \Box p$\pos$(A_1,
\ldots, A_n)$.

This assertion states that for any constants $A_1, \ldots, A_n$ in the Herbrand
Universe, $p$\pos$(A_1, \ldots, A_n)$ implies that henceforth, \linebreak
$p$\pos$(A_1, \ldots, A_n)$ will be true.\rcs{defined herbrand here?  this is the first use}

%\wrm{is there a point to this formula?  can't we just say ``a simple persistence
%rule naturally encapsulates the ``always'' operator from temporal logic.  maybe
%this should even be a footnote unless we're going to make a bigger deal about
%\lang and temporal logics?}
%\paa{umm, I just thought it was interesting.  feel free to strike it, footnote it, convert 
%it to plain english, etc}
\subsection{Mutable State}
\label{sec:mutable}

To model deletions and updates of a fact, it is necessary to break the induction
in a simple persistence rule.  Adding a {\em p\nega} subgoal to the body of a
simple persistence rule accomplishes this:

\begin{Dedalus}
p_pos(A_1,A_2,[...],A_n)@next \(\leftarrow\)
  p_pos(A_1,A_2,[...],A_n),
  \(\lnot\) p_neg(A_1,A_2,[...],A_n);
\end{Dedalus}

%%\begin{definition}
%
%%A rule of the above form is known as a {\em mutable persistence rule}.
%
%%\end{definition}

If, at any time $k$, we have a fact
\dedalus{p\nega($C_1$,$C_2$,[...],$C_n$)@k}, then we do not deduce a
\dedalus{p\pos($C_1$,$C_2$,[...],$C_n$)@k+1} fact.  By induction, we do not
deduce a \dedalus{p\pos($C_1$,$C_2$,[...],$C_n$)@l} for any $l > k$, unless
this \dedalus{p\pos} fact is re-derived at some timestep $l > k$ by another
rule.  This corresponds to the intuition that a persistent fact, once stated,
is true until it is retracted.  

%%\newtheorem{example}{Example}
\begin{example}
Consider the following \lang program and {\em trace} of events:

\begin{Dedalus}
p\pos(A, B) \(\leftarrow\) p(A, B);

p\pos(A, B)@next \(\leftarrow\) p\pos(A, B),\(\lnot\)p\nega(A, B);

p(1,2)@101;
p(1,3)@102;
p\nega(1,2)@300;
\end{Dedalus}

It is easy to see that the following are true: \dedalus{p(1,2)@200},
\dedalus{p(1,3)@200}, \dedalus{p(1,3)@300}.  However, \dedalus{p(1,2)@300} is
false because it was deleted at timestep \dedalus{300}.
\end{example}

This basic template for mutable persistence occurs so frequently that we provide a 
shorthand for the rule.  Instead of the second rule in the example above, we may
instead write: 

\begin{Dedalus}
persist[p, 2]
\end{Dedalus}

The \emph{persist} macro takes a predicate name and a number of attributes as arguments, 
and expands to an appropriately specified persistence rule.

%%\begin{definition}
%
For some time $\Tau$, an {\em update} is any pair of facts:

\begin{Dedalus}
p\nega(\(C_1\),\(C_2\),[...],\(C_n\))@\(\Tau\) 
p\pos(\(D_1\),\(D_2\),[...],\(D_n\))@\(\Tau+1\)
\end{Dedalus}
%
%%\end{definition}

Intuitively, an update represents replacing an old value of a tuple with a
newer value.  We say the update is {\em atomic across timesteps}, meaning that
the old value ceases to exist at the same timestep in which the new value
is derived -- timestep $\Tau+1$ in the above definition.



