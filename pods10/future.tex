\section{Conclusion and Future Work}

\jmh{In here, please follow up on the intro -- discuss how we built some serious shit in Overlog, and we believe that \lang is just 
as expressive because its operational semantics (cite boom-tr) are essentially the same as the behavior of Algorithm 1.  Formalizing this
a bit difficult since it entails developing a proper definition of the operational semantics of our Overlog interpreter.  Rather than trouble ourselves
with that, we are in the process of ``porting'' our Overlog code to Dedalus. }
Datalog has inspired a variety of recent applied work, which touts the benefits of declarative specifications for practical implementations.  Unfortunately, Datalog's declarative semantics make no guarantees
regarding the order in which derivations will occur; or rather, they derive all derivations in one atomic fixpoint computation.  This makes it difficult to associate natural ``side-effects'' like state update and message delivery with purely logical notions of deduction.


\lang is the result of our experience using hybrid
declarative/imperative languages such as Overlog~\cite{Loo2009-CACM}
to implement a number of networking protocols and distributed
systems~\cite{boom-techr,Alvaro2009I-Do-Declare:-C,Chu:2007,Loo2009-CACM}.
Although our experience with those languages was largely positive, the
combination of Datalog and imperative constructs hampered our
development of program analyses, and even our understanding of the
``correct'' execution of single-node programs that performed state
updates.

By mapping time to another type of data over which logical deductions
are performed, \lang allows us to express concepts such as asynchrony and state update in terms of a purely deductive logic
language, achieving the goal of a declarative language without sacrificing critically expressive features for the distributed systems domain.

\jmh{I think this paragraph says ``\lang handles state'', and the next says ``\lang handles asynchrony.''  Yes?  Let's say so than.}
At their core, state update and communication differ from logical
deductions only in terms of timing; \lang's notion of time allows us
to interleave operations and time in terms of logical deductions.
In the local case, this allows us to express state update without giving up the clean semantics of Datalog; unlike
Datalog extensions that use imperative constructs to provide such
functionality, each \lang rule expresses a logical invariant that will
hold over all program executions.  
\jmh{next sentence is lost of me.}
Our treatment of time in terms of
logical constraints allows us to model issues such as causality (and
``clever'' systems that observe causality violations) in a flexible
manner.

However, interactions with external processes, and primitives such as
asynchronous and unreliable communication introduce nondeterminism
which \lang models with \dedalus{choose}.  

Our hope is that modeling external process and events with a single
primitive will greatly simplify program analysis techniques.  Rather
than spending time and effort translating imperative code into sets of logical
invariants over program executions, analyses of \lang programs can
work directly against the invariants encoded by the program, allowing
them to focus on invocations of \dedalus{choose}, each of which
encodes some less easily avoided source of non-determinism and
ambiguity, such as a hardware failure or end-user.

\rcs{not really happy with the last paragraph; we should at least say some high-level thing about raising level of abstraction of programming, enabling more applications, etc, etc...}
