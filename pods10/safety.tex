\section{Safety in Synchronous Dedalus}

A Datalog program is safe if it produces a finite model, and hence has a finite
execution.  Safety is traditionally achieved through the following constraints:

\begin{enumerate}
%
\item No functions are allowed. \wrm{but Datalog doesn't have any functions}
%
\item Variables are \emph{range restricted}: all attributes of the head goal
appear in a non-negated body subgoal.
%
\item The EDB is finite.
%
\end{enumerate}

Any atom that may be deduced by a program may take its attributes only from the \emph{Herbrand universe} of
all constant symbols in the program and EDB.~\nrc{Don't know what this
  means, but I suspect it is fancy-pants language for no good reason.}
The set of all possible assignments of these constants to predicate attributes,
representing every possible interpretation, is itself finite. \wrm{what is a "possible assignment"?  possible given the rules of the program?}

\nrc{Seems like there ought to be more here. Why do I care about the
  preceding text? What does it have to do with the following text?}

\subsection{Temporal Safety}

Consider the \emph{successor} relation described above.  According to our intuitive interpretation, this relation models
the passage of time, in order to establish a temporal order among ground atoms.  \wrm{we're ignoring entanglement here}
Recall that {\em successor} is the standard strict total order on $\mathbb{Z}$,
and is thus an infinite relation.  Clearly, a naive interpretation of time can
lead to unsafe programs:

%%No reason to re-define a strict total order here...
%\begin{itemize}

%\item $\forall A,B \in \mathbb{Z} : successor(A, B) \Rightarrow B > A$ (i.e. whenever $successor(A,B)$ is true, then $B > A$)

%\item $\forall A \in \mathbb{Z} : \exists! B \in \mathbb{Z} : successor(A,B)$ (i.e. every integer has a successor)

%\end{itemize}

%\wrm{we'd expect a lot more properties of successor than the ones you mentioned.  so instead of trying to think of them all, i just narrowed down what you wrote.}

%This implies that successor is infinite (as we'd expect time to be), and is problematic because it leads to unsafe programs.


\begin{example}
Consider the Dedalus instance below.

\begin{Dedalus}
r1
p_pos(A, B)@next \(\leftarrow\)
  p_pos(A, B),
  \(\lnot\)p_neg(A, B);
  
r2  
p_pos(A, B)  \(\leftarrow\)
  p(A, B);
  
p(1, 2)@123;
  
\end{Dedalus}

The single ground fact will, due to \emph{r1}, cause one deduction for each
tuple in {\em successor}.  Since {\em successor} is infinite, the program is
unsafe.  

\end{example}

However, we observe that all of these deductions are uninteresting, as they are
derived deterministically from a finite EDB, and because the tuple changes at 
each deduction only in its time attribute.  To distinguish between programs that 
produce these infinite \emph{void inductions} and those that correspond 
intuitively to the Datalog notion of unsafe programs, we introduce the concept of
\emph{temporal safety}.

\begin{definition}
An intensional predicate $e$ in a program $P$ is called an \emph{event predicate} if there exist
in $P$ no rules with $e$ in their head. \wrm{how is this different from an EDB predicate??}
\end{definition}

\wrm{the following doesn't seem like a definition, seems more like a test for temporal safety}
\begin{definition}

A rule is temporally safe if:

\begin{enumerate}
\item It is a deductive rule that is function-free and range-restricted.
\item It is an inductive rule in which the head predicate occurs also in the body with the same 
assignment of variables and constants to attributes.
\item It is an inductive rule that has at least one event predicate as a positive subgoal in the body.
\end{enumerate}
\end{definition}

A Dedalus program is temporally safe if all its rules are temporally safe.
Intuitively, a temporally safe program quiesces given a finite EDB.  A
temporally unsafe program changes infinitely, even given a finite EDB.  Note
that the Dedalus program above is temporally safe because \emph{r1} corresponds
to the second rule of the definition, and \emph{r2} corresponds to the first.
Atoms deduced by the inducive rule \emph{r1} differ from existing atoms only in
their time suffix.

\begin{example}

\begin{Dedalus}
p(A, B) \(\leftarrow\)
  q(A);
\end{Dedalus}

The program above has a temporally unsafe deductive rule that corresponds to an unsafe rule in Datalog: it is not range-restricted.  
The head variable $B$ could range over an infinite set of constants.

\end{example}


\begin{example}


\begin{Dedalus}
flip\_flop(A, B)@next  \(\leftarrow\)
    flip\_flop(A, B),
    \(\lnot\)ff_neg(A, B);

p(Y)@next  \(\leftarrow\)
    p(X),
    ff(X, Y);

flip\_flop(0, 1)@1;
flip\_flop(1, 0)@1;
p(0)@2;
\end{Dedalus}

In the above program, the first rule -- a basic mutable persistent rule for
\emph{flip\_flop} -- is temporally safe.  The second rule is an example of
temporally unsafe induction.  Even though it contains no function symbols, and
all variables are range-restricted, it entails infinite oscillation of
the \emph{p} predicate.
because the \emph{p} predicate occurs in the head with
a different variable binding than in the body, and because there are no
positive event predicates in the body.  \wrm{this makes me a bit uncomfortable.
we've defined a conservative test for temporal safety.  so if something fails
the test, it's not necessariliy temporally unsafe.}

\end{example}


An inductive rule cannot cause infinite oscillation if it has a positive event predicate in its body, because we are assuming a finite EDB.

%%However, we observe that all of these deductions are uninteresting, as they are
%%deterministically related to the EDB.  To avoid performing such deductions, we
%%restrict {\em successor} to range over the subset of $\mathbb{Z}$ consisting of
%%the consecutive natural numbers between the minimum and maximum timestamp
%%specified in the (finite) EDB ($\{123, 124\}$ in this example) \wrm{this is without NDB right?}.  If we extended the EDB with the additional facts:

%But if \emph{successor} is infinite, many of these deductions may be \emph{void}in some sense, i.e. functionally determined based on the EDB. \wrm{is functionally determined a real term?}
%In effect, an EDB that is given in its totality determines a window over successor that is relevant to any computation that must be performed.  \wrm{what about NDB?}
%It is easy to see that in this example, we need only consider a successor relation that contains a single tuple \{123, 124\}.

%%\begin{Dedalus}
%%delete p(1, 2)@456;
%%p(?, ?)@789; \wrm{we're still doing queries?}
%%\end{Dedalus}

%%Evaluating the Dedalus instance would require \emph{successor} to range over the
%%subset of consecutive natural numbers $[123, 790]$.

%%\begin{definition}
%%A \emph{post-hoc} evaluation is an evaluation of a Dedalus instance where
%%{\em successor} ranges over the finite subset of $\mathbb{Z}$ described above.
%%\end{definition}

%%In a post-hoc evaluation, we can derive {\em successor} from the EDB as part of
%%the fixpoint computation.  We first define a predicate \emph{event\_time} that
%%contains the union of the time attributes from the EDB:

%%$event\_time(\Tau) \leftarrow \displaystyle\bigvee_{p \in EDB} p([...], \Tau)$

%%\wrm{I wasn't a fan of expressing a query plan in a Datalog rule...  But we can
%%talk about this}

%%We then populate \emph{successor} with Dedalus program shown below:
%with arithmetic and aggregate functions, as shown below.

%%\begin{Dedalus}
%%smax(max<N>) \(\leftarrow\) event\_time(N);
%%smin(min<N>) \(\leftarrow\) event\_time(N);

%%successor(N, N + 1) \(\leftarrow\) smin(N);

%%successor(S, S + 1) \(\leftarrow\) 
%%    successor(N, S),
%%    smax(M),
%%    N <= M;
%%\end{Dedalus}

%%\wrm{Not sure what the point of this is...}
%%Since {\em successor} is finite in a post-hoc evaluation, we may evaluate the
%%ntire Dedalus instance in a single fixpoint.

%In a post-hoc evaluation, time is in some sense ``instantaneous" in that all values of the successor relation are considered in a single
%fixpoint computation.  The complete program is safe if the EDB is finite.

\subsection{EDB Prefixes}

In general, however, an EDB can itself be infinite, and may lead to unsafe evaluations even when \emph{successor} is derived from it
as in a post-hoc evaluation.

\begin{definition}
A \emph{prefix} $\alpha_{n}$ of an EDB $\Gamma$ is the set of facts in $\Gamma$ whose timestamp is less than or equal to $n$.
\end{definition}

If the EDB is finite, then it has a maximum timestamp $\top$, and $\alpha_{\top}$ = $\Gamma$.  Because each prefix is a superset of all 
prefixes with lower indices, we also have the monotonicity property

\begin{equation}
\forall \alpha_{i}, \alpha_{j} \in \Gamma : (i < j) \to (\alpha_{i} \subseteq \alpha_{j})
\end{equation}

%\paa{to your point, bill, I switched the lemma and proof below to one of IDB equivalence in the posthoc vs. continual interpretation
%rather than an inductive proof that every model in the series is minimal.  there is probably a very similar proof of the latter
%that we could include in the next section after introducing minimal models, stratification etc}


\begin{definition}
Let $F$ be the set of all finite subsets of possible facts. \wrm{need to be
more precise.}  
\paa{I think this is the power set of the herbrand base...}
Let $P$ be the set of all finite subsets of possible rules.
Let $FP : P \times F \mapsto F$ be the function representing the
\emph{fixpoint} computation carried out by a datalog interpreter.  That is, $FP_p$ takes an EDB to its corresponding IDB.
\end{definition}


\begin{lemma}
%
Let $i \in \mathbb{Z}$.  Then, $FP_p(\alpha_{i+1} \cup FP_p(\alpha_i)) =
FP_p(\alpha_{i+1})$.
%
\end{lemma}

%%this could (with some work) lead to an inductive proof
%%that an infinite model is minimal.  we could prove the (weaker?) property that
%%the infinite series of models of increasing finite prefixes of an EDB are all 
%%minimal if one of them is.

\begin{proof}

%%Inductive step:

%%if we assume that some program P and finite prefix $\alpha_n$ of a trace $\Gamma$ produce a minimal model, 
%%then it follows that a prefix $\alpha_{n+1}$ and the IDB produced by the previous model produce a minimal model.

by contradiction. Assume $\exists i \in \mathbb{Z}$ such that:

$FP_p(\alpha_{i+1} \cup FP_p(\alpha_i)) \neq FP_p(\alpha_{i+1})$

{\bf Case 1:} $\exists A \in FP_p(\alpha_{i+1} \cup FP_p(\alpha_i)) : A \not\in FP_p(\alpha_{i+1}).$

This implies that $A$ is transitively dependent on facts in $\alpha_{i+1} \cup
FP_p(\alpha_i)$.  However, if $A$ is transitively dependent only on facts in
$\alpha_{i+1}$, then $A$ would be in $FP_p(\alpha_{i+1})$.  Thus, $A$ must be
transitively dependent on some facts in $FP_p(\alpha_{i})$.  But $\alpha_{i}
\subset \alpha_{i+1}$, so this implies that $A$ is transitively dependent on
some fact in $\alpha_{i+1}$, which means $A \in FP_p(\alpha_{i+1})$.  This
contradicts our assumption, thus no such $A$ may exist.

{\bf Case 2:} $\exists A \in FP_p(\alpha_{i+1}) : A \not\in FP_p(\alpha_{i+1} \cup FP_p(\alpha_i)).$

This implies that $A$ is transitively dependent on $\alpha_{i+1}$.  In order
for $A \not\in FP_p(\alpha_{i+1} \cup FP_p(\alpha_i))$, we need $A$ to depend
negatively on an atom $B \in FP_p(\alpha_i)$.  But $B$ transitively depends on
an fact $C \in \alpha_i$.  $C \in \alpha_{i+1}$ by definition (if $B$ is
extensional, then $C=B$), so $B \in FP_p(\alpha_{i+1})$, so $a \not\in
FP_p(\alpha_{i+1})$.  This contradicts our assumption, thus no such $A$ may
exist.

%If $I_2 \neq I_3$, it must be the case that either there exists a ground atom in $I_2$ that is not in $I_3$, or that is in
%$I_3$ and not in $I_2$.  

%Take the former case first.  This means there is an atom $A$ that is entailed by P given $FP(\alpha_{j} \cup FP(\alpha_{i}))$
%but not entailed by P given $\alpha_{j}$, so it must be in $I_1$.   The only circumstances under which an atom in
%$I_1$ would not occur in the IDB $FP(\alpha_{j})$ is if there is a fact $B$ in $\alpha_{j}$ 
%corresponding to a negated subgoal in a rule $r$ in P upon which $A$ depends.  However, for this to occur, because a ground atom 
%in $I_1$ cannot depend upon a ground atom from the ``future", that fact $B$ would need to have occurred at some time less than 
%or equal to the to timestamp of atom $A$.  But this is not possible, because all timestamps in $\alpha_{j}$ that are not in any $\alpha_{k} | k<j$
%are strictly higher than any timestamps in $\alpha_{k}$.  Hence the first case leads to contradiction.

%As for the second case...

\end{proof}

