\section{Safety in \large \bf \slang}

A Datalog program is safe if it admits a finite minimal model, and hence has
a finite execution.  Safety in logic programming is traditionally achieved
through the following constraints:

\begin{enumerate}
%
\item No functions are allowed.
%
\item Variables are \emph{range restricted}: all attributes of the head goal
appear in a non-negated body subgoal.
%
\item The EDB is finite.
%
\end{enumerate}

These constraints ensure that the Herbrand Universe is finite: any atom that
may be deduced by a program may take its attributes only from the Herbrand
Universe consisting of all constant symbols in the program and EDB.
%%~\nrc{Don't know what this means, but I suspect it is fancy-pants language for no good reason.}
%%\paa{ignoring this provocative comment.}
%%\wrm{lol.}
In fact, the set of all possible assignments of these constants to predicate
attributes, representing every possible interpretation, is itself finite. 

%\nrc{Seems like there ought to be more here. Why do I care about the
%  preceding text? What does it have to do with the following text?}

%Since the Herbrand Universe is finite, any instantiation of predicates with
%constants is finite.  Every possible interpretation (set of ground atoms) of
%a logic program comes from this finite instantiation, so any possible
%interpretation is finite
  
%\paa{the idea is: safe=finite.  herbrand universe=finite, so any instantiation of predicates with constants is finite.
%every possible interpretation (set of atoms) of a LP comes from this instantition.  so any possible interpretation is finite.
%a model is an interpretation in which all heads are true when the body is true.  all models are finite.  the minimal model
%is clearly finite.}

\subsection{Temporal Safety}

Consider the \dedalus{successor} relation described above.  According to our
intuitive interpretation, this relation models the passage of time, in order to
establish a temporal order among ground atoms. 

The \dedalus{successor} relation complicates our discussion of safety, as it
introduces the countably infinite set $\mathbb{Z}$ to our Herbrand Universe.
Clearly, a naive interpretation of time can lead to unsafe programs:

%Consider the \dedalus{successor} relation described above.  According to our
%intuitive interpretation, this relation models the passage of time, in order to
%establish a temporal order among ground atoms. 
%%\wrm{we're ignoring entanglement here}
%Recall that {\em successor} is the standard strict total order on
%$\mathbb{Z}$, lol, don't know how I accidentally wrote the above incorrect
%sentence all over the paper
%Recall that \dedalus{successor} is an infinite relation.  Clearly, a naive
%interpretation of time can lead to unsafe programs:

%%No reason to re-define a strict total order here...
%\begin{itemize}

%\item $\forall A,B \in \mathbb{Z} : successor(A, B) \Rightarrow B > A$ (i.e. whenever $successor(A,B)$ is true, then $B > A$)

%\item $\forall A \in \mathbb{Z} : \exists! B \in \mathbb{Z} : successor(A,B)$ (i.e. every integer has a successor)

%\end{itemize}

%\wrm{we'd expect a lot more properties of successor than the ones you mentioned.  so instead of trying to think of them all, i just narrowed down what you wrote.}

%This implies that successor is infinite (as we'd expect time to be), and is problematic because it leads to unsafe programs.


\begin{example}
%
A \slang instance that is unsafe due to an unbroken induction over time.

\begin{Dedalus}
r1
p_pos(A, B)@next \(\leftarrow\) p_pos(A, B), \(\lnot\)p_neg(A, B);
  
r2  
p_pos(A, B)  \(\leftarrow\) p(A, B);
  
p(1, 2)@123;  
\end{Dedalus}

The single ground fact will, due to \dedalus{r1}, cause one deduction for each
tuple in \dedalus{successor}.  Since \dedalus{successor} is infinite, the
program is unsafe. 
%
\end{example}

However, observe that each of these deductions produces a tuple that changes
only in its time suffix.  We we find it useful to distinguish from unsafe
programs those programs that, given a finite EDB, eventually derive only tuples
that change in their time suffixes.

\begin{definition}
%
A \emph{stable derivation} is a fact $\gamma'$ with time suffix $\Tau$ derived
from a fact $\gamma$ with time suffix $\Tau-1$, such that $\gamma$ differs from
$\gamma'$ only in its time suffix.
%
\end{definition}

%%To distinguish between programs that 
%%produce these infinite \emph{void inductions} and those that correspond 
%%intuitively to the Datalog notion of unsafe programs, we introduce the concept of
%%\emph{temporal safety}.

%%\begin{definition}
%%An intensional predicate $e$ in a program $P$ is called an \emph{event predicate} if there exist
%%in $P$ no rules with $e$ in their head. \wrm{how is this different from an EDB predicate??}
%%\end{definition}

We call a \slang instance is \emph{quiescent} if after some time $\Tau$, all
derivations are always stable.

\begin{definition}
%
A \slang instance with finite EDB is \emph{temporally safe} if it reaches
quiescent state after a finite number of deductions.
%
\end{definition}
%%\wrm{the following doesn't seem like a definition, seems more like a test for temporal safety}
%%\begin{definition}

\begin{definition}
%
Given the depends-on relation $\succ$ and its transitive closure $\succ^{*}$,
an intensional predicate $e$ in a program $P$ is called an \emph{atemporal
predicate} if for every predicate $p$ for which $e \succ^{*} p$, $p$ appears in
no inductive rules.
%
\end{definition}

%%A rule is temporally safe if:
We propose the following conservative test for temporal safety.  A rule is
guaranteed to be temporally safe if:

\begin{enumerate}
%
\item It is a deductive rule that is function-free and range-restricted, or
%
\item It is an inductive rule in which the head predicate occurs also in the
body with the same variable bindings for all attributes but the time suffix, or
%%occurs also in the body with the same assignment of variables and constants to attributes.
%
\item It is an inductive rule that has at least one atemporal predicate as a
positive subgoal in the body.  Since the EDB is finite, this inductive rule
may only be triggered finitely often.
%
\end{enumerate}

A \slang program is temporally safe if all its rules are temporally safe.
Intuitively, a temporally safe program quiesces given a finite EDB.  A
temporally unsafe program changes infinitely, even given a finite EDB.  Note
that the \slang program above is temporally safe because \emph{r1} corresponds
to the second rule of the definition, and \emph{r2} corresponds to the first
\wrm{which?}.  Atoms deduced by the inducive rule \emph{r1} differ from
existing atoms only in their time suffix.

\begin{example}
A \slang instance with a temporally unsafe deductive rule.

\begin{Dedalus}
p(A, B) \(\leftarrow\) q(A);
\end{Dedalus}

The program above has a temporally unsafe deductive rule that corresponds to an
unsafe rule in Datalog: it is not range-restricted.  The head variable $B$
could range over an infinite set of constants.
\end{example}


\begin{example}
A \slang instance that is unsafe due to infinite oscillation.

\begin{Dedalus}
flip\_flop(A, B)@next \(\leftarrow\) flip\_flop(A, B);

p(Y)@next \(\leftarrow\) p(X), flip\_flop(X, Y);

flip\_flop(0, 1)@1;
flip\_flop(1, 0)@1;
p(0)@2;
\end{Dedalus}

In the above program, the first rule -- a simple persistence rule for
\emph{flip\_flop} -- is temporally safe.  The second rule is an example of
temporally unsafe induction.  Even though it contains no function symbols, and
all variables are range-restricted, it entails infinite oscillation of the
\emph{p} predicate.  
%because the \emph{p} predicate occurs in the head with a
%different variable binding than in the body, and because there are no positive
%event predicates in the body.  
%%\wrm{this makes me a bit uncomfortable.
%%we've defined a conservative test for temporal safety.  so if something fails
%%the test, it's not necessariliy temporally unsafe.}
\end{example}


%An inductive rule cannot cause infinite oscillation if it has a positive event predicate in its body, because we are assuming a finite EDB.

%%However, we observe that all of these deductions are uninteresting, as they are
%%deterministically related to the EDB.  To avoid performing such deductions, we
%%restrict {\em successor} to range over the subset of $\mathbb{Z}$ consisting of
%%the consecutive natural numbers between the minimum and maximum timestamp
%%specified in the (finite) EDB ($\{123, 124\}$ in this example) \wrm{this is without NDB right?}.  If we extended the EDB with the additional facts:

%But if \emph{successor} is infinite, many of these deductions may be \emph{void}in some sense, i.e. functionally determined based on the EDB. \wrm{is functionally determined a real term?}
%In effect, an EDB that is given in its totality determines a window over successor that is relevant to any computation that must be performed.  \wrm{what about NDB?}
%It is easy to see that in this example, we need only consider a successor relation that contains a single tuple \{123, 124\}.

%%\begin{Dedalus}
%%delete p(1, 2)@456;
%%p(?, ?)@789; \wrm{we're still doing queries?}
%%\end{Dedalus}

%%Evaluating the Dedalus instance would require \emph{successor} to range over the
%%subset of consecutive natural numbers $[123, 790]$.

%%\begin{definition}
%%A \emph{post-hoc} evaluation is an evaluation of a Dedalus instance where
%%{\em successor} ranges over the finite subset of $\mathbb{Z}$ described above.
%%\end{definition}

%%In a post-hoc evaluation, we can derive {\em successor} from the EDB as part of
%%the fixpoint computation.  We first define a predicate \emph{event\_time} that
%%contains the union of the time attributes from the EDB:

%%$event\_time(\Tau) \leftarrow \displaystyle\bigvee_{p \in EDB} p([...], \Tau)$

%%\wrm{I wasn't a fan of expressing a query plan in a Datalog rule...  But we can
%%talk about this}

%%We then populate \emph{successor} with Dedalus program shown below:
%with arithmetic and aggregate functions, as shown below.

%%\begin{Dedalus}
%%smax(max<N>) \(\leftarrow\) event\_time(N);
%%smin(min<N>) \(\leftarrow\) event\_time(N);

%%successor(N, N + 1) \(\leftarrow\) smin(N);

%%successor(S, S + 1) \(\leftarrow\) 
%%    successor(N, S),
%%    smax(M),
%%    N <= M;
%%\end{Dedalus}

%%\wrm{Not sure what the point of this is...}
%%Since {\em successor} is finite in a post-hoc evaluation, we may evaluate the
%%ntire Dedalus instance in a single fixpoint.

%In a post-hoc evaluation, time is in some sense ``instantaneous" in that all values of the successor relation are considered in a single
%fixpoint computation.  The complete program is safe if the EDB is finite.

\subsection{EDB Prefixes}

A \slang instance may receive arbitrarily many external input tuples over the
course of its execution, but a sensible implementation should not wait
arbitrarily long before performing deductions.  In this section we introduce
the notion of EDB prefixes, and prove an equivalence between two types of
evaluation.

%In general, the EDB of a \slang instance may be infinite, and may lead to unsafe evaluations even when \emph{successor} is derived from it
%as in a post-hoc evaluation.

\begin{definition}
A \emph{prefix} $\alpha_{n}$ of an EDB $\Gamma$ is the set of facts in $\Gamma$ whose timestamp is less than or equal to $n$.
\end{definition}

If the EDB is finite, then it has a maximum timestamp $\top$, and $\alpha_{\top}$ = $\Gamma$.  Because each prefix is a superset of all 
prefixes with lower indices, we have the monotonicity property:

$\forall \alpha_{i}, \alpha_{j} \in \Gamma : (i < j) \to (\alpha_{i} \subseteq \alpha_{j})$

%\paa{to your point, bill, I switched the lemma and proof below to one of IDB equivalence in the posthoc vs. continual interpretation
%rather than an inductive proof that every model in the series is minimal.  there is probably a very similar proof of the latter
%that we could include in the next section after introducing minimal models, stratification etc}


\begin{definition}
Let $F$ be the set of all finite subsets of possible facts. \wrm{need to be
more precise.}  
\paa{I think this is the power set of the herbrand base...}
Let $P$ be the set of all finite subsets of possible rules.
Let $FP : P \times F \mapsto F$ be the function representing the
\emph{fixpoint} computation carried out by a datalog interpreter.  That is, $FP_p$ takes an EDB to its corresponding IDB.
\end{definition}


\begin{lemma}
\label{lem:costmodel}
%
Let $i \in \mathbb{Z}$.  Then, $FP_p(\alpha_{i+1} \cup FP_p(\alpha_i)) =
FP_p(\alpha_{i+1})$.
%
\end{lemma}

%%this could (with some work) lead to an inductive proof
%%that an infinite model is minimal.  we could prove the (weaker?) property that
%%the infinite series of models of increasing finite prefixes of an EDB are all 
%%minimal if one of them is.

\begin{proof}

%%Inductive step:

%%if we assume that some program P and finite prefix $\alpha_n$ of a trace $\Gamma$ produce a minimal model, 
%%then it follows that a prefix $\alpha_{n+1}$ and the IDB produced by the previous model produce a minimal model.

by contradiction. Assume $\exists i \in \mathbb{Z}$ such that:
$FP_p(\alpha_{i+1} \cup FP_p(\alpha_i)) \neq FP_p(\alpha_{i+1})$

{\bf Case 1:} $\exists A \in FP_p(\alpha_{i+1} \cup FP_p(\alpha_i)) : A \not\in FP_p(\alpha_{i+1}).$

This implies that $A$ is transitively dependent on facts in $\alpha_{i+1} \cup
FP_p(\alpha_i)$.  However, if $A$ is transitively dependent only on facts in
$\alpha_{i+1}$, then $A$ would be in $FP_p(\alpha_{i+1})$.  Thus, $A$ must be
transitively dependent on some facts in $FP_p(\alpha_{i})$.  But $\alpha_{i}
\subset \alpha_{i+1}$, so this implies that $A$ is transitively dependent on
some fact in $\alpha_{i+1}$, which means $A \in FP_p(\alpha_{i+1})$.  This
contradicts our assumption, thus no such $A$ may exist.

{\bf Case 2:} $\exists A \in FP_p(\alpha_{i+1}) : A \not\in FP_p(\alpha_{i+1} \cup FP_p(\alpha_i)).$

This implies that $A$ is transitively dependent on $\alpha_{i+1}$.  In order
for $A \not\in FP_p(\alpha_{i+1} \cup FP_p(\alpha_i))$, we need $A$ to depend
negatively on an atom $B \in FP_p(\alpha_i)$.  But $B$ transitively depends on
an fact $C \in \alpha_i$.  $C \in \alpha_{i+1}$ by definition (if $B$ is
extensional, then $C=B$), so $B \in FP_p(\alpha_{i+1})$, so $a \not\in
FP_p(\alpha_{i+1})$.  This contradicts our assumption, thus no such $A$ may
exist.
%If $I_2 \neq I_3$, it must be the case that either there exists a ground atom in $I_2$ that is not in $I_3$, or that is in
%$I_3$ and not in $I_2$.  
%Take the former case first.  This means there is an atom $A$ that is entailed by P given $FP(\alpha_{j} \cup FP(\alpha_{i}))$
%but not entailed by P given $\alpha_{j}$, so it must be in $I_1$.   The only circumstances under which an atom in
%$I_1$ would not occur in the IDB $FP(\alpha_{j})$ is if there is a fact $B$ in $\alpha_{j}$ 
%corresponding to a negated subgoal in a rule $r$ in P upon which $A$ depends.  However, for this to occur, because a ground atom 
%in $I_1$ cannot depend upon a ground atom from the ``future", that fact $B$ would need to have occurred at some time less than 
%or equal to the to timestamp of atom $A$.  But this is not possible, because all timestamps in $\alpha_{j}$ that are not in any $\alpha_{k} | k<j$
%are strictly higher than any timestamps in $\alpha_{k}$.  Hence the first case leads to contradiction.
%As for the second case...
\end{proof}

