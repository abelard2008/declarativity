

\section{\lang} We take as our foundation an augmented version of \linebreak
$\lnot$Datalog~\cite{ullmanbook} with aggregate function symbols akin to those
of SQL (min, max, avg, stdev, count).  Henceforth, we will refer to this
language as ``Datalog.'' In general, we are interested in the classes of
statically stratifiable and locally stratifiable programs~\cite{prz}.  In
addition, we admit the use of the \emph{choice} construct~\cite{greedychoice,
eventchoice} to model nondeterministic selection of an element from a set.  
%%\jmh{save the next sentence for later.  stay pure here.}
%%In \dedalus, we will use this construct to
%%model both the nondeterminism of message delay, and the semantics of key
%%maintenance in prior deductive update models like Overlog~\cite{boon}.

%%\jmh{Can't we borrow this from somebody else rather than define it ourselves?  ``As in Ullman, et al [FOO] we represent...''}
As a matter of notation, we refer to a countably infinite universe of constants
\emph{C}, in which $C_{1}, C_{2}, \ldots$ are representations of individual
constants, and a countably infinite universe of variable symbols $A = A_1, A_2,
\ldots$, and a distinguished variable $\Tau$. \wrm{is this any different from
regular Datalog?}
% which may take on the values of any constants.   
We represent time in \lang by the union of set of integers $\mathbb{Z}$, with a
special element $\perp$ that means ``never''.  We consider the standard strict
total order $<$, with the additional rule that $\forall i \in \mathbb{Z}: i <
\perp$.  We call this order \dedalus{successor}.


\subsection{Syntactic Restrictions}
%%\jmh{I wonder if it wouldn't be better to do a totally syntactic definition of Dedalus as a restricted subclass of Datalog+stratification+successor, with some convenience %%notation that falls out of the restrictions.  It would ensure that we don't skip steps, and allow us to fall back on proofs about Datalog without being sloppy.  The intro %%paragraph before is only halfway formal and might be better off with a firm basis in citeable Datalog papers.}

%%A Dedalus program is a Datalog program in which every predicate is annotated with a time suffix.  \jmh{Already some slop ... you want to define it via Datalog+strat
%%+succ.  You could start by using Datalog notation but requiring the last attribute of each predicate to range over $\mathbb{Z}$, and then introduce the @-sign notation.}  
%%A Dedalus predicate has the following form:

%%$p(A_{1}, A_{2}, [...], A_{n})@S$
We will define \lang as a restricted sublanguage of Datalog.  Specifically,
we restrict the admissible schemata, and the form of rules.

\noindent{\bf Schema: }We require that the final attribute of every \lang
predicate range over the set $\mathbb{Z} \cup \perp$.  In a typical
interpretation, \lang programs will use this final attribute to connote a
``timestamp'', so we refer to this attribute at the \emph{time suffix} of the
corresponding predicate.  Any fact in a \lang predicate must specify a
constant time suffix, i.e. a member of the set $\mathbb{Z} \cup \perp$.

\noindent{\bf Rules: }We restrict the bindings of the time suffixes, and
disallow {\em extensional} predicates in most rules.

%$p(C_{1},C_{2},[...],C_{n}, i) |  i \in \mathbb{Z} \cup \perp$

%The balance of our restrictions concern the well-formedness of \dedalus rules.

\begin{definition}
%
An \emph{extensional} predicate in a \lang program is a predicate
that does not appear in the head of any rule in the program.  
%
\end{definition}

%\wrm{we really want an inclusion constraint not just in the set of integers, but in the set of all possible times, in case time is finite}.  \jmh{I disagree, actually.  EDB facts can be sprinkled throughout time without restriction, and the rule syntax below provides the restrictions you want.  you're hinting at the reduction stuff below, but we can rewrite to that.}  

For every extensional predicate $r$ in a \lang program $P$, we add to $P$ two
predicates \dedalus{r\_pos} and \dedalus{r\_neg} with the same schema as $r$, as well as a rule
of the following form:

\dedalus{r\_pos($A_1$, $A_2$, [...], $A_n$) \(\leftarrow\) r($A_1$, $A_2$, [...], $A_n$);}

That is, for every extensional predicate $r$ there is an IDB predicate \dedalus{r\_pos} that
contains at least the contents of $r$.  No well-formed \lang rule may reference
an extensional predicate -- except for rules of the above form.

In a well-formed \lang rule, every subgoal is required to use the
distinguished variable $\Tau$ as its time suffix, and $\Tau$ must not be
further restricted.  A well-formed \lang rule must also have a time suffix
$S$ in its head, which must be constrained in exactly one of the following
three ways:
%%\jmh{I would not introduce the following constraint -- can't we have rules that fire at a particular timestep?  It may slightly complicate your reductions later, but it seems manageable.}
%constrained (e.g. it must not occur in the rule body except as a time suffix).

\begin{enumerate}

\item The rule is said to be \emph{deductive} if $S$ is
bound to the value $\Tau$.  That is, the body contains a subgoal of the form:
\dedalus{S = $\Tau$}.

\item The rule is said to be {\em inductive} if $S$ is the successor
of $\Tau$.  That is, the body contains a subgoal of the form:
\dedalus{successor($\Tau$, S)}.

\item The rule is said to be {\em asynchronous} if the relation of $S$ and
$\Tau$ is modeled the non-deterministic choice construct.  An asynchronous rule
has the following subgoals in its body: \dedalus{successor(\_, $\Tau$),
choose((\_), ($\Tau$))}.  The choice subgoal expresses that the rule head may
be derived at any tisme value that appears in the \dedalus{successor} relation.

%%\wrm{Why can't we
%%select the initial time?  What we should do instead is have some unary relation
%%time(T) that captures all possible times, and choose from this relation
%%instead.  We can assume an inclusion constraint forcing successor's arguments
%%to both come from this relation.}  \jmh{Good point.  OTOH I suspect we'll have to forbid messages into the past, in which case this will be fine (and succinct).}  \jmh{Actually, we should be able to express delays that are a function of attributes -- e.g. a sender-receiver pair may be input to a real-world delay distribution, as might be the time.}

\end{enumerate}


\begin{example}

The following three rules are well-formed examples of each of the three classes
listed above:

\begin{Dedalus}
deductive
p(A, B, S) \(\leftarrow\)
  e(A, B, \(\Tau\)),
  S = \(\Tau\);

inductive 
q(A, B, S) \(\leftarrow\)
  e(A, B, \(\Tau\)),
  successor(\(\Tau\), S);

asynchronous
r(A, B, S) \(\leftarrow\)
  e(A, B, \(\Tau\)),
  successor(_, S),
  choose((_), (S));
  
\end{Dedalus}
\end{example}


\subsection{Extensional, Intensional and Nondeterministic Databases}

%%\jmh{Ack ... deductive rules are unsafe, and technically Datalog-neg forbids them due to the free variable in the head.  So you will need to expand your language to include an acceptable notion of per-timestep safety (as Maier suggested), at which point it's not a subset of Datalog-neg.  Would be nice to be able to say ``Dedalus is a subset of (Datalog + \{set of addons\})'' but that would require defining the acceptable saftey before defining timestamps (which are a restriction).}

Each relation in a \lang program is of exactly one of the three kinds:
extensional, {\em intensional} or {\em nondeterministic}.

\begin{definition}
%
An \emph{intensional} relation in a \lang program is a relation that appears
in the head of one or more atemporal or inductive rules in the program, but
never in the head of an asynchronous rule.
%
\end{definition}
\begin{definition}
%
A \emph{nondeterministic} relation in a \lang program is a relation that
appears in the head of one or more asynchronous rules in the program.
%
\end{definition}
We refer to the sets of ground atoms in intensional and nondeterministic
predicates respectively as the IDB, and NDB.

%\jmh{introduction of the MDB doesn't seem useful, actually.  I'd drop this,
%and if you need to define a ``mutable'' relation as one that participates in
%the head of a temporal rule, you can do so as needed.}
The EDB, IDB, and NDB are all pairwise disjoint.  Intuitively, the distinction
between the NDB and IDB is that the NDB is determined nondeterministically from
the EDB, IDB and NDB, while the IDB is determined deterministically from the
EDB, IDB and NDB.  Thus, given a \lang instance, all IDB predicates that do
not transitively depend on NDB predicates can be evaluated deterministically.
We will refer to facts, ground atoms in the EDB, and \emph{events}
interchangeably, for reasons which will soon become clear.
%%\jmh{The only reason to worry about the MDB being non-deterministic is @sync, which you didn't in fact need to introduce yet.  Again, I don't see this discussion being useful.}


\begin{figure}[t]
  \centering
  \includegraphics[width=0.75\linewidth]{dedalus-time.pdf}
  \label{fig:dedalus-time}
  \caption{Time moves forward in three ways: across strata, to the next fixpoint, and to some future fixpoint.}
\vspace{-8pt}
\end{figure}


\subsection{Abbreviated Syntax and Temporal Interpretation}
We have been careful to define \lang as a syntactic subset of a natural variant of Datalog; this allows us to take advantage of Datalog's well-known semantics and the rich literature on the language.  

However \lang programs are intended to capture 
%naturally
temporal semantics.  For example, a fact with some constant $C_i$ in its time
suffix can be thought of as a fact that is true ``at time $C_i$''.  Deductive
rules can be seen as {\em atemporal} statements: they range over all values of
the time suffix, and express deductions that are ``always'' valid.  Inductive
and asynchronous rules are {\em temporal} -- their consequents are defined to
be true ``at a different time'' than their antecedents. 

To simplify \lang notation for this typical interpretation,  we introduce
some natural syntactic ``sugar'' as follows:  

\begin{itemize}
%
%why do we need this one??
%\item {\em Time-suffix notation:}  Each predicate's time suffix  time-suffix attribute of each
%predicate is placed after the predicate's right parenthesis, separated by the
%symbol `@'.   For example, the predicate \\ $r(A_{1}, \ldots, A_{n}, S)$ is
%rewritten as $r(A_{1}, \ldots, A_{n})@S$.
%
\item {\em Implicit time-suffixes in body predicates:} Since all body
predicates of a well-formed rule have a free variable $\Tau$ in the time
suffix, we omit the time suffix from body predicates and treat it as implicit.
\wrm{it's not a free variable unless there's only one body atom, right?  otherwise
it's restricted because it appears in multiple atoms.}
%
\item {\em Temporal head annotation:} A temporal rules contains an identifier
attached to the head predicate that indicates whether the rule is inductive or
asynchronous.  The keyword stands in for the {\em successor} and {\em choice}
predicates in the body.  Thus, a head predicate in a temporal rule is of the 
form:

\dedalus{r($A_1$,$A_2$,[...],$A_n$)@S}

where $S$ is one of the following:
%
\begin{enumerate}
%
\item \emph{next}: an inductive rule, in which the \dedalus{successor($\Tau$,
S)} predicate is implicitly included in the body as described above, and $S$ is
implicitly the time suffix of the head
%
\item \emph{async(N)}: an asynchronous rule, in which the time suffix of the
head predicate will occur some time after the time suffix of the body
predicate, or never.  N is a variable, corresponding to the time suffix $\Tau$
of all predicates in the rule body and optionally referenced in the head.
\wrm{this seems ugly to me}
%
\end{enumerate}
%
\end{itemize}

\wrm{the before stuff might be a bit to verbose and repetitive.}

\begin{example}

The following are the sugared version of the rules listed previously:

\begin{Dedalus}
deductive
p(A, B) \(\leftarrow\)
  e(A, B);
  
inductive 
q(A, B)@next \(\leftarrow\)
  e(A, B);
  
asynchronous
r(A, B)@async \(\leftarrow\) \wrm{inconsistency.  are we doing async(N)?}
  e(A, B);
    
\end{Dedalus}
\end{example}


% \jmh{the following is redundant and can be omitted}
% Dedalus facts are just datalog facts that conform to the schema constraint:  rule heads with empty bodies, and ground terms for all attributes including the time suffix.  To accommodate this in our notation,
% we allow a fourth suffix for the special case of empty bodies: a constant integer.  A Dedalus fact thus has the form:
% 
% $r(C_1, C_2, [...], C_n)@CI$
% 
% where $CI$ is an integer constant.


%Finally, we define the following shorthand for referring to the special IDB relations defined above.  Recall that for every EDB predicate $r$
%we have a uniquely defined pair of IDB predicates $r\_pos$ and $r\_neg$.  In a Dedalus program, we use $r$ as shorthand for $r\_pos$ 
%(recall that the true EDB predicate $r$ cannot be referenced by any rules) and $delete$ $r$ as shorthand for $r\_neg$.
%%A deductive rule as defined above will hold for any assignment of a constant integer to the $N$-value in the suffix of each predicate.

%%\subsection{Events}

%%\newdef{definition}{Definition} 
%%\begin{definition}
%
%%An \emph{event} in Dedalus is an EDB fact.
%
%%\end{definition}

%%\jmh{Isn't the following simply a restatement of Datalog's use of EDB?}
%%Since an extensional relation may not appear in a rule's head, events come from
%%sources external to the evaluation of the Dedalus instance.

