\section{Introduction}
%Our research is motivated by two hard problems in distributed systems.  First,


%Distributing any system introduces nondeterminism.  For example, one may
%distribute a computation over many inexpensive, but unreliable, commodity
%machines (e.g. RAID).  The status of internet links and widely distributed
%nodes is inherently more unreliable than multiple cores on a single die, or
%multiple CPUs in a single computer.  

%We present {\bf \lang{Dedalus}}, a foundation language for programming and
%reasoning about distributed systems.  

%We correct deficiencies in earlier attempts, and introduce a compelling notion
%of non-determinism in the language.  We specifically use non-determinism to
%reason about {\em when} a deduction becomes visible, including the possibility
%that the deduction will never be visible.  Programmers can constrain this
%non-determinism by using well-studied techniques in distributed systems, such as
%Lamport Clocks 



\section{\large \bf \slang}
%%We take as our foundation an augmented version of
%%$\lnot$Datalog~\cite{ullmanbook} with aggregate function symbols akin to those
%%of SQL (min, max, avg, stdev, count).  Henceforth, we will refer to this
%%language as ``Datalog.'' 
We take as our foundation the language $\lnot$Datalog~\cite{ullmanbook}, which
we will henceforth refer to as ``Datalog." In general, we are interested in the
classes of statically stratifiable 
%,locally stratifiable~\cite{prz} 
and modularly stratifiable~\cite{modular} programs.  In addition, we use
the \dedalus{choice} construct~\cite{greedychoice, eventchoice} to model
nondeterministic selection of an element from a set.  
%%\jmh{save the next sentence for later.  stay pure here.}
%%In \dedalus, we will use this construct to
%%model both the nondeterminism of message delay, and the semantics of key
%%maintenance in prior deductive update models like Overlog~\cite{boon}.

%%\jmh{Can't we borrow this from somebody else rather than define it ourselves?  ``As in Ullman, et al [FOO] we represent...''}
As a matter of notation, we refer to a countably infinite universe of constants
\emph{\textbf{C}}, in which $C_{1}, C_{2}, \ldots$ are representations of individual
constants -- and a countably infinite universe of variable symbols $\textbf{A} = A_1,
A_2, \ldots$, and a distinguished variable $\Tau$.
% which may take on the values of any constants.   
We represent time in \slang by the set of integers $\mathbb{Z}$ We consider the
standard strict total order $<$. We define the \dedalus{successor} relation,
where \dedalus{successor(i,j)} means that \dedalus{j} is the least element that
is greater than \dedalus{i}.


\subsection{Syntactic Restrictions}
\label{sec:syntaxrestrictions}

%%$p(A_{1}, A_{2}, [...], A_{n})@S$
\slang is a restricted sublanguage of Datalog.  Specifically, we restrict the
admissible schemata and the form of rules.

\noindent{\bf Schema: }We require that the final attribute of every \slang
predicate range over the set $\mathbb{Z}$.  In a typical
interpretation, \slang programs will use this final attribute to connote a
``timestamp'', so we refer to this attribute as the \emph{time suffix} of the
corresponding predicate.

\noindent{\bf Rules: }We restrict the bindings of the time suffixes, and
disallow {\em extensional} predicates in most rules.
%$p(C_{1},C_{2},[...],C_{n}, i) |  i \in \mathbb{Z} \cup \perp$
%The balance of our restrictions concern the well-formedness of \dedalus rules.
%\begin{definition}
%
%An \emph{extensional} predicate in a \slang program $P$ is a predicate
%that does not appear in the head of any rule in $P$.
%
%\end{definition}
%\wrm{we really want an inclusion constraint not just in the set of integers, but in the set of all possible times, in case time is finite}.  \jmh{I disagree, actually.  EDB facts can be sprinkled throughout time without restriction, and the rule syntax below provides the restrictions you want.  you're hinting at the reduction stuff below, but we can rewrite to that.}  
For every extensional predicate \dedalus{r} in a \slang program $P$, we add to
$P$ two predicates \dedalus{r\_pos} and \dedalus{r\_neg} with the same schema
as \dedalus{r}.  \dedalus{r\_neg} is a convenience predicate that will later
use to enable updates.  We define \dedalus{r\_pos} using the following rule:

\dedalus{r\_pos($A_1$, $A_2$, [...], $A_n$) \(\leftarrow\) r($A_1$, $A_2$,
[...], $A_n$);}

That is, for every extensional predicate \dedalus{r} there is an intensional
predicate \dedalus{r\_pos} that contains at least the contents of \dedalus{r}.
Intuitively, this rule allows extensional to serve as ground for
\dedalus{r\_pos}, while enabling other rules to derive \dedalus{r\_pos} facts.
Except for a rule of the above form, no well-formed \slang rule may reference
an extensional predicate.

In a well-formed \slang rule, every subgoal is required to use the
distinguished variable $\Tau$ as its time suffix, and $\Tau$ must not be
further restricted.  A well-formed \slang rule must also have a time suffix
\dedalus{S} in its head, which must be constrained in exactly one of the
following two ways:

\begin{enumerate}

\item The rule is said to be \emph{deductive} if \dedalus{S} is bound to the
value $\Tau$.  That is, the body contains the subgoal \dedalus{S = $\Tau$}.

\item The rule is said to be {\em inductive} if \dedalus{S} is the successor of
$\Tau$.  That is, the body contains the subgoal \dedalus{successor($\Tau$, S)}.

%%\item The rule is said to be {\em asynchronous} if the relation of $S$ and
%%$\Tau$ is modeled with the non-deterministic choice construct.  An asynchronous rule
%%has the following subgoals in its body: \dedalus{successor(\_,S),
%%choose((\_), (S))}.  The choice subgoal expresses that the rule head may
%%be derived at any time value that appears in the \dedalus{successor} relation.

%%\wrm{Why can't we
%%select the initial time?  What we should do instead is have some unary relation
%%time(T) that captures all possible times, and choose from this relation
%%instead.  We can assume an inclusion constraint forcing successor's arguments
%%to both come from this relation.}  \jmh{Good point.  OTOH I suspect we'll have to forbid messages into the past, in which case this will be fine (and succinct).}  \jmh{Actually, we should be able to express delays that are a function of attributes -- e.g. a sender-receiver pair may be input to a real-world delay distribution, as might be the time.}

\end{enumerate}

%For now, we'll confine our discussion to programs in \slang. 

Later when we consider \lang -- a superset of \slang -- we will
introduce another kind of rule.

\begin{example}
Well-formed deductive and inductive rules.

\begin{Dedalus}
deductive
p(A, B, S) \(\leftarrow\) e(A, B, \(\Tau\)), S = \(\Tau\);

inductive 
q(A, B, S) \(\leftarrow\) e(A, B, \(\Tau\)), successor(\(\Tau\), S);
\end{Dedalus}
%%asynchronous
%%r(A, B, S) \(\leftarrow\)
%%  e(A, B, \(\Tau\)),
%%  successor(_, S),
%%  choose((_), (S));
\end{example}

  


\subsection{Abbreviated Syntax and Temporal Interpretation}
\label{sec:abbrvsyntax}

We have been careful to define \slang as a syntactic subset of a natural
variant of Datalog; this allows us to take advantage of Datalog's well-known
semantics and the rich literature on the language.

However \slang programs are intended to capture 
%naturally
temporal semantics.  For example, a fact with some constant $\Tau$ in its time
suffix can be thought of as a fact that is true ``at time $\Tau$''.  Deductive
rules can be seen as {\em atemporal} statements: they range over all values of
the time suffix, and express deductions that are ``always'' valid.  Inductive
and asynchronous rules are {\em temporal} --- their consequents are defined to
be true ``at a different time'' than their antecedents. 

To simplify \slang notation for this typical interpretation,  we introduce
some natural syntactic ``sugar'' as follows:  \wrm{this might be more than sugar
in that it prevents entanglement}

\begin{itemize}
%
%why do we need this one??  \item {\em Time-suffix notation:}  Each predicate's
%time suffix  time-suffix attribute of each predicate is placed after the
%predicate's right parenthesis, separated by the symbol `@'.   For example, the
%predicate \\ $r(A_{1}, \ldots, A_{n}, S)$ is rewritten as $r(A_{1}, \ldots,
%A_{n})@S$.
%
\item {\em Implicit time-suffixes in body predicates:} Since all body
predicates of a well-formed rule have a variable $\Tau$ in the time suffix, we
omit the time suffix from body predicates and treat it as implicit.
%%\wrm{it's not a free variable unless there's only one body atom, right?  otherwise
%%it's restricted because it appears in multiple atoms.}
%
\item {\em Temporal head annotation:} Since the time suffix in a head predicate
may be either equal to $\Tau$, or equal to $\Tau$'s successor, we omit the time
suffix from the head -- and its relevant constraints from the body -- and
instead attach an identifier to all temporal rules, to indicate the change in
timestep.  A temporal rule is of the form:

\dedalus{r($A_1$,$A_2$,[...],$A_n$)@next}

The identifier \dedalus{@next} stands in for \dedalus{successor($\Tau$,S)} in
the body.

%
%\begin{enumerate}
%
%item \emph{next} implies the rule is inductive, and stands in for
%\linebreak\dedalus{successor($\Tau$,S)} in the body.
%
%\item \emph{async(N)} implies the rule is asynchronous, and stands in for
%\dedalus{successor(\_, S), choose((\_), (S))} in the body.  $N$ is a variable,
%corresponding to the time suffix $\Tau$ of all predicates in the rule body and
%optionally referenced in the head.  \wrm{this seems ugly to me}
%
%\end{enumerate}
%
\end{itemize}

%\wrm{the before stuff might be a bit to verbose and repetitive.}

\begin{example}
Sugared deductive and inductive rules.

\begin{Dedalus}
deductive
p(A, B) \(\leftarrow\) e(A, B);
  
inductive 
q(A, B)@next \(\leftarrow\) e(A, B);
\end{Dedalus}
%%asynchronous
%%r(A, B)@async \(\leftarrow\) \wrm{inconsistency.  are we doing async(N)?}
%%  e(A, B);
\end{example}


% \jmh{the following is redundant and can be omitted}
% Dedalus facts are just datalog facts that conform to the schema constraint:  rule heads with empty bodies, and ground terms for all attributes including the time suffix.  To accommodate this in our notation,
% we allow a fourth suffix for the special case of empty bodies: a constant integer.  A Dedalus fact thus has the form:
% 
% $r(C_1, C_2, [...], C_n)@CI$
% 
% where $CI$ is an integer constant.


%Finally, we define the following shorthand for referring to the special IDB relations defined above.  Recall that for every EDB predicate $r$
%we have a uniquely defined pair of IDB predicates $r\_pos$ and $r\_neg$.  In a Dedalus program, we use $r$ as shorthand for $r\_pos$ 
%(recall that the true EDB predicate $r$ cannot be referenced by any rules) and $delete$ $r$ as shorthand for $r\_neg$.
%%A deductive rule as defined above will hold for any assignment of a constant integer to the $N$-value in the suffix of each predicate.

%%\subsection{Events}

%%\newdef{definition}{Definition} 
%%\begin{definition}
%
%%An \emph{event} in Dedalus is an EDB fact.
%
%%\end{definition}

%%\jmh{Isn't the following simply a restatement of Datalog's use of EDB?}
%%Since an extensional relation may not appear in a rule's head, events come from
%%sources external to the evaluation of the Dedalus instance.

