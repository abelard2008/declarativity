\section{State Update}

\subsection{Dedalus programs are stratifiable if the equivalent Datalog program is stratifiable}

\subsubsection{Theorem 0}

\subsection{Dedalus is Datalog if we project out time}

\subsubsection{Local, Deductive Dedalus}

every local Dedalus program P with only deductive rules is equivalent to a Datalog program P'.
%%\end{theorem}

\subsubsection{L}

every local Dedalus program P with deductive and inductive rules and trace T is equivalent to a Datalog program P' with an EDB T'.

\subsubsection{Theorem 3}

some theorem about distributed programs :)

\subsection{All sequence inputs are derived from time}

Input queues are simply a mapping between the ordering domain of the queue tuples and the time relation.  Naturally, this mapping
is infinite also and cannot be expressed as EDB.  But we can instead constructively state the rules that define how the mapping 
tracks the progress of the time relation.

Take a relation $q$ defined as:

$q(A, B, \underline{O})$

The relation is persistent, and therefore is associate with the following rule:

\begin{Dedalus}
q(A, B, O)@N+1 \(\leftarrow\)
  q(A, B, O)@N, 
  \(\lnot\)del\_q(A, B, O)@N;
\end{Dedalus}

In this example, the ordering domain $O$ is already given in the schema.  Like time, this queue may be viewed as an infinite stream.
To enforce an ordering on how we dequeue from the relation, we define a mapping between the ordering domain and the logical clock
time.  This mapping is likewise infinite and therefore may not be given as EDB.  However, we may express how to continually generate 
the mapping via a set of rules.

\subsubsection{Example 1: a FIFO queue}

\begin{Dedalus}
sel\_q(N, O)@N \(\leftarrow\)
  max\_q(O)@N;

max\_q(max<O>)@N \(\leftarrow\)
  q(\_, \_, O)@N;

del\_q(A, B, O)@N \(\leftarrow\)
  deq\_q(N, O)@N,
  q(A, B, O)@N;
\end{Dedalus}

\subsubsection{Example 2: per-host FIFOs}

\begin{Dedalus}
sel\_q(N, O)@N \(\leftarrow\)
  max\_q(_, O)@N; 

max\_q(A, max<O>)@N \(\leftarrow\)
q(A, \_, O)@N;
\end{Dedalus}


\subsection{Dedalus Programs are storage-optimal}

:)

\subsubsection{We need only store the event tuple with max(Timestamp) for each projection of the other columns to query the present time}


\subsubsection{perhaps we can admit queries over the past that are bounded and pre-stated, and do GC}
