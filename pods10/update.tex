\section{State Update}

\subsection{Dedalus programs are stratifiable if the equivalent Datalog program is stratifiable}

\subsubsection{Theorem 0}

\subsection{Dedalus is Datalog if we project out time}

\subsubsection{Local, Deductive Dedalus}

every local Dedalus program P with only deductive rules is equivalent to a Datalog program P'.
%%\end{theorem}

\subsubsection{L}

every local Dedalus program P with deductive and inductive rules and trace T is equivalent to a Datalog program P' with an EDB T'.

\subsubsection{Theorem 3}

\newdef{definition}{Definition}
\begin{definition}
some definition about distributed programs :)
\end{definition}

%%\newtheorem{theorem}{Theorem}
\begin{theorem}
some theorem about distributed programs :)
\end{theorem}

\begin{proof}
some proof about distributed programs :)
\end{proof}

foo bar
\subsection{All sequence inputs are derived from time}

Input queues are simply a mapping between the ordering domain of the queue tuples and the time relation.  Naturally, this mapping
is infinite also and cannot be expressed as EDB.  But we can instead constructively state the rules that define how the mapping 
tracks the progress of the time relation.

Take a persistent relation q, associated with the following rule:

\begin{Dedalus}
q(A, B, O)@N+1 \(\leftarrow\)
  q(A, B, O)@N, 
  \(\lnot\)del\_q(A, B, O)@N;
\end{Dedalus}

In this example, the ordering domain $O$ is already given in the schema.  Like time, this queue may be viewed as an infinite stream.
To interact with a queue, we should be able to atomically dequeue an element in any timestep.  That is to say, in a given fixpoint computation,
we should be able to take an element from the queue such that in the next timestep that element is no longer there, regardless of the
underlying queue discipline.  Let's assume for a moment the existence of two helper predicates for operations on \emph{q}: \emph{sel\_q} and
\emph{deq\_q}.  


\begin{alltt}
begin_work(A, B, O) \(\leftarrow\)
  q(A, B, O)@N,
  event(A)@N, 
  sel_q(O)@N;
  
  
deq_q(O) \(\leftarrow\) 
  begin_work(_, _, O);
\end{alltt}


To enforce an ordering on how we dequeue from the relation, we define a mapping between the ordering domain and the logical clock
time.  This mapping is likewise infinite and therefore may not be given as EDB.  However, we may express how to continually generate 
the mapping via a set of rules.

\subsubsection{Example 1: a FIFO queue}

\begin{Dedalus}
sel\_q(O)@N \(\leftarrow\)
  max\_q(O)@N;

max\_q(max<O>)@N \(\leftarrow\)
  q(\_, \_, O)@N;

del\_q(A, B, O)@N \(\leftarrow\)
  deq\_q(O)@N,
  q(A, B, O)@N;
\end{Dedalus}

\subsubsection{Example 2: per-host FIFOs}

\begin{Dedalus}
sel\_q(O)@N \(\leftarrow\)
  max\_q(_, O)@N; 

max\_q(A, max<O>)@N \(\leftarrow\)
  q(A, \_, O)@N;
\end{Dedalus}


\subsection{Persistent Storage Implementations}

:)

%%\subsubsection{We need only store the event tuple with max(Timestamp) for each projection of the other columns to query the present time}
\subsubsection{Cost Model}

\begin{figure}[t]
\begin{tabular}{ll} \hline
%%Rule Pattern & Idiom & Prepare & Propose & Election \\ \hline \hline
$d$ & Cost of a deductive step \\
$s$ & Cost of storing a tuple \\
$r$ & Cost of reading a tuple \\ 
\hline
$S$ & Set of tuples inserted \\
$U$ & Set of tuples updated \\
$P$ & Set of stored tuples, with time projected out \\ 
$T$ & Set of stored tuple timestamps \\ 
$Q$ & Set of query timestamps \\ \hline 
\end{tabular}
\caption{Cost model.}
\label{fig:breakdown}
\end{figure}


\subsubsection{Naive Deductive Implementation}

$(|S|+2|U|)s + (|S|+2|U|)r + (\displaystyle\sum_{i=0}^{|Q|-1} \displaystyle\sum_{j=0}^{|T|-1} Q_{i} - T_{j})d$

\subsubsection{Naive Overwriteable Storage Implementation}

$|S| + 2|U|$

%%\subsubsection{perhaps we can admit queries over the past that are bounded and pre-stated, and do GC}
