\section{Implications for State Update}
\newdef{definition}{Definition}

\subsection{All sequence inputs are derived from time}

Input queues are simply a mapping between the ordering domain of the queue tuples and the time relation.  Naturally, this mapping
is infinite also and cannot be expressed as EDB.  But we can instead constructively state the rules that define how the mapping 
tracks the progress of the time relation.

Take a persistent relation q, associated with the following rule:

\begin{Dedalus}
q(A, B, O)@N+1 \(\leftarrow\)
  q(A, B, O)@N, 
  \(\lnot\)del\_q(A, B, O)@N;
\end{Dedalus}

In this example, the ordering domain $O$ is already given in the schema.  Like time, this queue may be viewed as an infinite stream.
To interact with a queue, we should be able to atomically dequeue an element in any timestep.  That is to say, in a given fixpoint computation,
we should be able to take an element from the queue such that in the next timestep that element is no longer there, regardless of the
underlying queue discipline.  Let's assume for a moment the existence of two helper predicates for operations on \emph{q}: \emph{sel\_q} and
\emph{deq\_q}.  


\begin{alltt}
begin_work(A, B, O)@N \(\leftarrow\)
  q(A, B, O)@N,
  event(A)@N, 
  sel_q(O)@N;
  
  
deq_q(O)@N \(\leftarrow\) 
  begin_work(_, _, O)@N;
\end{alltt}


To enforce an ordering on how we dequeue from the relation, we define a mapping between the ordering domain and the logical clock
time.  This mapping is likewise infinite and therefore may not be given as EDB.  However, we may express how to continually generate 
the mapping via a set of rules.

\subsubsection{Example 1: a FIFO queue}

\begin{Dedalus}
sel\_q(O)@N \(\leftarrow\)
  max\_q(O)@N;

max\_q(max<O>)@N \(\leftarrow\)
  q(\_, \_, O)@N;

del\_q(A, B, O)@N \(\leftarrow\)
  deq\_q(O)@N,
  q(A, B, O)@N;
\end{Dedalus}

\subsubsection{Example 2: per-host FIFOs}

\begin{Dedalus}
sel\_q(O)@N \(\leftarrow\)
  max\_q(_, O)@N; 

max\_q(A, max<O>)@N \(\leftarrow\)
  q(A, \_, O)@N;
\end{Dedalus}


\subsection{Persistent Storage Implementations}

\paa{help!}

%%\subsubsection{We need only store the event tuple with max(Timestamp) for each projection of the other columns to query the present time}
\subsubsection{Cost Model}

\begin{figure}[t]
\begin{tabular}{ll} \hline
%%Rule Pattern & Idiom & Prepare & Propose & Election \\ \hline \hline
$d$ & Cost of a deductive step \\
$s$ & Cost of storing a tuple \\
$r$ & Cost of reading a tuple \\ 
$t$ & Number of tuple derivations from deductive rules \\ 
\hline
$S$ & Set of tuples inserted \\
$U$ & Set of tuples updated \\
$P$ & Set of stored tuples, with time projected out \\ 
$T$ & Set of stored tuple timestamps \\ 
$Q$ & Set of query timestamps \\ \hline 
\end{tabular}
\caption{Cost model.}
\label{fig:breakdown}
\end{figure}


\subsubsection{Naive Deductive Implementation}

To evaluate a schedule consisting of inserts, updates and queries, the naive deductive implementation must,
at a minimum,
\begin{enumerate}
\item Write every event once.  We may think of this as sequential log appends.  An update entails two writes: one for the deletion
and one for the insertion of the new tuple.
\item Read the entire log at least once.
\item For each query, perform the necessary number of inductive steps to determine if relevant predicates hold at query time.
On the surface, this would appear to be the interval between the ground fact time and the query time, if that interval is unbroken
by a deletion predicate.
\end{enumerate}

$(|S|+2|U|)s + (|S|+2|U|)r + t + (\displaystyle\sum_{i=0}^{|Q|-1} \displaystyle\sum_{j=0}^{|T|-1} Q_{i} - T_{j})d$

\subsubsection{Naive Overwriteable Storage Implementation}

In this case, every update entails a read and then a write.

$|S|s + |U|s + |U|r + t$


%%\subsubsection{perhaps we can admit queries over the past that are bounded and pre-stated, and do GC}
