\section{Evaluation}
We have been careful to ensure that \slang manages to capture issues of persistence and updatable state without deviating from traditional Datalog semantics.  This means not only that our programs have a unique interpretation, but that they can be computed bottom-up via traditional methods like semi-naive evaluation.  

Unfortunately, the direct application of semi-naive evaluation results in a rather literal and inefficient notion of the idea of ``persistence''.  If a fact is true across a long sequence of timesteps, semi-naive evaluation will persistently ``re-derive'' that fact inductively for each timestep, and the number of derivations in a program will be infinite simply to maintain persistence in time.  Instead, we would like an incremental evaluation strategy that allows an external agent to examine the state of the database at any timestep $t$ without requiring $O(t)$ inductive derivations for persistence.  The intuitive strategy would be to use a memory device, ``storing'' a fact on first derivation and ``deleting'' it at the timestep that the induction is broken.  In this section we derive such an evaluation strategy, in the style of semi-naive evaluation.

\subsection{Temporal Evaluation Over Storage}
The traditional description of semi-naive evaluation takes a recursive Datalog program, rewrites it to a non-recursive ``delta'' program, and executes that program in a loop bracketed by state modifications.  In that spirit, we present a strategy we call ``temporal evaluation'', which takes a \slang program, rewrites it to a purely deductive Datalog program, and executes that program in a loop---once per timestep---bracketed by state modifications.  


%\subsection{Evaluation of Persistent Predicates}
%%\newdef{definition}{Definition}

\floatname{algorithm}{Algorithm}
\renewcommand{\algorithmicforall}{\textbf{foreach}}
\algsetup{indent=2em}
\newcommand{\exec}{\ensuremath{\mbox{\sf execProgram}}}
\newcommand{\add}{\ensuremath{\mbox{\sf add}}}
%\newcommand{\ids}{\ensuremath{\mbox{\sf ids}}}
\begin{algorithm}
   \caption{Temporal Evaluation}\label{alg:tsn}
   \begin{algorithmic}
   \STATE{\em // rewrite program}
   \FORALL{persistent predicate $P(A_1, \ldots, A_n)$}
	    \STATE{\em // include ``old facts'' in the current timestep}
      \STATE{\vspace{-1.2em}\begin{tabular}[t]{l l} \\ \add & $P(A_1, \ldots, A_n)@T \leftarrow P\_store(A_1, \ldots, A_n).$ \end{tabular}}
			\STATE{\em // identify ``new'' derived facts}
      \STATE{\vspace{-1.2em}\begin{tabular}[t]{l l} \\ \add & $\Delta_P^{+}(A_1, \ldots, A_n) \leftarrow$ \\ & \hspace{1.5em} $P(A_1, \ldots, A_n)@T, \lnot P(A_1, \ldots, A_n)@T-1.$ \end{tabular}}
			\STATE{\em // identify ``new'' facts that are ``to-be-deleted''}
      \STATE{\vspace{-1.2em}\begin{tabular}[t]{l l} \\ \add & $\Delta_P^{-} \leftarrow P\_neg(A_1, \ldots, A_n)@T.$ \end{tabular}}
   \ENDFOR
   \STATE{\em // evaluate program}
   \FORALL{$t \in \mathbb{Z}$}
      \STATE{compute the fixpoint of the rewritten program}
      \FORALL{persistent predicate $P(A_1, \ldots, A_n)$}
         \STATE{$P\_store(A_1, \ldots, A_n) :=$ \\ \hspace{1.5em} $P\_store(A_1, \ldots, A_n) \cup \Delta_P^{+}(A_1, \ldots, A_n)$}
         \STATE{$P\_store(A_1, \ldots, A_n) :=$ \\ \hspace{1.5em} $P\_store(A_1, \ldots, A_n) \setminus \Delta_P^{-}(A_1, \ldots, A_n)$}
      \ENDFOR
   \ENDFOR
  \end{algorithmic}
\end{algorithm}
