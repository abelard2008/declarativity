\section{Introduction}
%Our research is motivated by two hard problems in distributed systems.  First,
\wrm{show examples of the problems (not necessarily code) -- evolving state and unreliable communication}
\wrm{bill to rewrite introduction...}

%Distributing any system introduces nondeterminism.  For example, one may
%distribute a computation over many inexpensive, but unreliable, commodity
%machines (e.g. RAID).  The status of internet links and widely distributed
%nodes is inherently more unreliable than multiple cores on a single die, or
%multiple CPUs in a single computer.  

%We present {\bf \lang}, a foundation language for programming and
%reasoning about distributed systems.  

%We correct deficiencies in earlier attempts, and introduce a compelling notion
%of non-determinism in the language.  We specifically use non-determinism to
%reason about {\em when} a deduction becomes visible, including the possibility
%that the deduction will never be visible.  Programmers can constrain this
%non-determinism by using well-studied techniques in distributed systems, such as
%Lamport Clocks 

\jmh{Here's my take on an intro outline.}
\begin{itemize}
	\item Datalog has seen a recent resurgence as the foundation for a number of applied, domain-specific languages in areas including...  These languages have been promoted for their compact and natural representations of tasks, and for their ability to fairly directly capture formal specifications (of protocols and programs) as executable code.
	\item While a number of these efforts began as ``declarative'' languages, many chose to extend Datalog with operational features natural to their application domains.  These operational aspects, while familiar, make it difficult to take advantage of the rich literature on Datalog program checks (cite safety, stratifiability, etc.) and optimizations (cite magic sets and the like).  In earlier work on declarative specifications of networking protocols and other distributed systems (cite P2, BOOM), the blend of operational and declarative constructs also led to complications in language semantics (cite MPII Overlog work).
	\item In this paper we reconsider declarative programming for distributed systems from a model-theoretic perspective, via the introduction of a fully declarative language called \lang.   \lang is a subset of Datalog enhanced with negation, aggregate functions, choice, and a successor function.  \lang provides a logical foundation for the key ``operational'' features of distributed programming, including persistence, state manipulation, asynchrony and component failure.  We show how all of these features are captured in \lang via a natural incorporation of {\em time} as an attribute of Datalog predicates.
	\item Given this foundation, we extend familiar Datalog notions such as safety and stratified negation to their temporal equivalents in \lang, and show how \lang programs can be syntactically checked to establish these properties.
	\item From an expressivity perspective, we show that \lang is Turing-complete \jmh{right?}, and demonstrate its practical utility with a number of building-block routines from classical distributed computing, including queues, Lamport clocks, and reliable broadcast.
\end{itemize}

Traditional database systems are based on declarative query languages that
specify transformations as dataflows over an updatable store.
\jmh{Not usually thought of as dataflows.  Rel Alg is kinda like dataflow but declarative Rel Calc isn't. Stick with Calc/Declarative as your reference.}
  Such query
languages are either not expressive enough to capture common programming
constructs \wrm{like what?}, or are at best awkward to use in this fashion.
\wrm{todo: transition that explains Datalog's birth from these languages... I
don't know enough to write it} The family of logic-based database languages, of
which Datalog is the progenitor, represent expressive programming languages
that produce similar dataflow representations.  Datalog is purely deductive: a
program specifies the rules by which the derived relations are populated based
on a static database, which is never updated.  Recent programming language
research has explored the use of Datalog-based languages for expressing
distributed systems.  Because the state of any complex system evolves with its
execution, these efforts were forced to extend the Datalog model by admitting
updates, additions and deletions of the EDB.  Unfortunately, these previous
attempts were plagued with ambiguities about how and when state changes occur
and become visible, putting a heavy burden on the programmer to ensure even
simple properties, such as atomicity of updates over time.

In contrast to reasoning about state change procdurally, \lang observes
that this concept is intuitively expressed as invariants over {\em time}.  In
this work, we present a formal model of Datalog augmented with time extensions.
By reifying time as data an introducing it into the logic, \lang eliminates
previous ambiguities, ensures atomicity of updates and makes it possible to
express system invariants that can guarantee liveness properties, a key
challenge in building distributed systems.
