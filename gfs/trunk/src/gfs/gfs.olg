program gfs;

import jol.types.basic.ValueList;
import gfs.Conf;
import gfs.Master;
import gfs.Shell;

// The address of the local node
define(self, keys(0), {String});
self(Conf.getSelfAddress());

gfs_global::file(Self, "Foo", Blocks) :-
    self(Self), Blocks := new ValueList();

// Node, Master node
watch(master_for_node, ae);
define(master_for_node, keys(0, 1), {String, String});

// Source node, Request ID, File name
define(cat_request, keys(0, 1), {String, Integer, String});

// Source node, Request ID, File name
define(create_request, keys(0, 1), {String, Integer, String});

// Source node, Request ID
define(ls_request, keys(0, 1), {String, Integer});

// Source node, Request ID, File name
define(rm_request, keys(0, 1), {String, Integer, String});

// Source node, Request ID, Request type, Arg1, Arg2
define(request_started, keys(0, 1), {String, Integer, String, String, String});

// Master node, Request ID, Source node, Request type, Arg1, Arg2
define(request, keys(0, 1), {String, Integer, String, String, String, String});

// Master node, Request Id, Source node, Success?, Response, ErrorMessage?
define(cat_request_done, keys(0, 1), {String, Integer, String, Boolean, ValueList, String});
define(create_request_done, keys(0, 1), {String, Integer, String, Boolean, String});
define(ls_request_done, keys(0, 1), {String, Integer, String, ValueList});
define(rm_request_done, keys(0, 1), {String, Integer, String, Boolean, String});

// New tables for indirection through paxos
define(create_request_pending, keys(0, 1), {String, Integer, String, Boolean, String});
define(rm_request_pending, keys(0, 1), {String, Integer, String, Boolean, String});

// Node, Request ID, Success, File blocks, Error message (on failure)
define(cat_response, keys(0, 1), {String, Integer, Boolean, ValueList, String});

// Node, Request ID, Success, Error message (on failure)
define(create_response, keys(0, 1), {String, Integer, Boolean, String});

// Node, Request ID, Listing contents
define(ls_response, keys(0, 1), {String, Integer, ValueList});

// Node, Request ID, Success, Error message (on failure)
define(rm_response, keys(0, 1), {String, Integer, Boolean, String});

request_started(@Source, Id, "Cat", FName, null) :-
    cat_request(@Source, Id, FName);

request_started(@Source, Id, "Create", FName, null) :-
    create_request(@Source, Id, FName);

request_started(@Source, Id, "Ls", null, null) :-
    ls_request(@Source, Id);

request_started(@Source, Id, "Rm", FName, null) :-
    rm_request(@Source, Id, FName);

request(@Master, Id, Source, RequestType, Arg1, Arg2) :-
    self(@Source), 
    master_for_node(@Source, Master),
    request_started(@Source, Id, RequestType, Arg1, Arg2);

// If we get a "cat" request for a file that exists, send back the
// contents of the file
cat_request_done(@Master, Id, Source, Success, Blocks, null) :-
    request(@Master, Id, Source, "Cat", FName, _),
    gfs_global::file(@Master, FName, Blocks), Success := true;

// If the file doesn't exist, return an error message
cat_request_done(@Master, Id, Source, Success, null, ErrMessage) :-
    request(@Master, Id, Source, "Cat", FName, _),
    notin gfs_global::file(@Master, FName, _),
    Success := false, ErrMessage := "File does not exist";

// If we got a "create" request for a file that didn't exist,
// we need to wait until we get consensus from paxos; then we
// can send back a positive ack.
// XXX: the use of "#insert" here is a hack
create_request_pending(@Master, Id, Source, true, null) :-
    request#insert(@Master, Id, Source, "Create", FName, _),
    notin gfs_global::file(@Master, FName, _);

// If we get a "create" request for a file that exists, send
// back a negative ack
// XXX: the use of "#insert" here is a hack
create_request_pending(@Master, Id, Source, false, ErrMessage) :-
    request#insert(@Master, Id, Source, "Create", FName, _),
    gfs_global::file(@Master, FName, _),
    ErrMessage := "File already exists";

// If we get an "ls" request, send back the names of all the files in
// the file system. If the file system is empty, send back an empty
// ValueList. Note that we need to do the aggregation in a sub-rule.
define(compute_ls, keys(0, 1), {String, Integer, String, ValueList});

compute_ls(@Master, Id, Source, generic<(new ValueList()).insert(FName)>) :-
    request(@Master, Id, Source, "Ls", _, _),
    gfs_global::file(@Master, FName, _);

ls_request_done(@Master, Id, Source, FileList) :-
    request(@Master, Id, Source, "Ls", _, _),
    compute_ls(@Master, Id, Source, FileList);

ls_request_done(@Master, Id, Source, FileList) :-
    request(@Master, Id, Source, "Ls", _, _),
    notin gfs_global::file(@Master, _, _),
    FileList := new ValueList();

// If we got an "rm" request and the file exists, remove it and send
// back a positive ack.
public
rm_request_pending(@Master, Id, Source, true, null) :-
    request(@Master, Id, Source, "Rm", FName, _),
    gfs_global::file(@Master, FName, _);

public
create_request_done(Master, Id, Source, Status, Error) :-
  gfs_global::create_request_done(Master, Id, Source, Status, Error);

public
rm_request_done(Master, Id, Source, Status, Error) :-
  gfs_global::rm_request_done(Master, Id, Source, Status, Error);

// If we got an "rm" request and the file doesn't exist, return a
// negative ack. NB: unlike in the "create" case, we don't need the
// "#insert" hack, since deletions are postponed the end of the
// fixpoint.
gfs_global::rm_request_done(@Master, Id, Source, false, ErrMessage) :-
    request(@Master, Id, Source, "Rm", FName, _),
    notin gfs_global::file(@Master, FName, _),
    ErrMessage := "File does not exist";

cat_response(@Source, Id, Success, Response, ErrMessage) :-
    cat_request_done(@Master, Id, Source, Success, Response, ErrMessage);

watch(create_response,ae);
create_response(@Source, Id, Success, Response) :-
    create_request_done(@Master, Id, Source, Success, Response);

ls_response(@Source, Id, Response) :-
    ls_request_done(@Master, Id, Source, Response);

rm_response(@Source, Id, Success, Response) :-
    rm_request_done(@Master, Id, Source, Success, Response);



/*****************************/
define(sendHeartBeat,keys(0,1,2),{String,String,String,Long,Long});
define(dataNodes,keys(0,1),{String,String,Long});
watch(dataNodes,ae);
watch(sendHeartBeat,ae);
timer(clock,physical,5000,5000,1000);

define(ackHeartBeat,keys(0,1,2),{String,String,Long});

ackHeartBeat(@Dnode,Master,Id) :-
    sendHeartBeat(@Master,Dnode,File,Tstamp,Id),
    Id != -1L;

dataNodes(Master,Host,max<Tstamp>) :-
    sendHeartBeat(Master,Host,File,Tstamp,Id);

define(chunks,keys(0,1,2),{String,String,String,Long});
watch(chunks,ae);
chunks(Master,Host,File,MaxTstamp) :-
    sendHeartBeat(Master,Host,File,Tstamp,Id),
    dataNodes(Master,Host,MaxTstamp),
    Ctime := java.lang.System.currentTimeMillis(),
    (Ctime - MaxTstamp) < 10000L;

delete 
chunks(Master,Host,File,Ts) :-
    chunks(Master,Host,File,Ts),
    clock(_,_,_),
    Ctime := java.lang.System.currentTimeMillis(),
    (Ctime - Ts) > 10000L;
