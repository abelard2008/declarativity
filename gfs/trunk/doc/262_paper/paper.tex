\documentclass{article}
\usepackage{fullpage}
\title{BoomFS: A Declarative Distributed Filesystem}
\author{Peter Alvaro, Neil Conway}
\date{December 20, 2008}
\begin{document}
\maketitle
\begin{abstract}
  While architectures for distributed computing are rapidly changing,
  techniques for building distributed systems have remained relatively
  stagnant. As distributed computation becomes the common case,
  traditional techniques for building distributed systems will become
  untenable, because they force programs to deal with the mundane
  boilerplate details of constructing reliable distributed
  systems. This yields programs that are difficult to construct,
  understand, modify, and port to new environments. We propose BOOM, a
  new paradigm for concisely specifying a broad class of distributed
  systems. In this paper, we describe the first application in the
  BOOM stack: BoomFS, a distributed filesystem in the style of the
  Google File System that is implemented in a combination of Java and
  declarative logic.
\end{abstract}

\section{Introduction}

With the widespread adoption of many-core processors, cloud computing,
and mobile clients, architectures for distributed computing are
experiencing a period of disruptive change. In the near future, nearly
every non-trivial software system will be physically distributed.

Traditional techniques to constructing software systems will be
sub-optimal for this new environment, because they provide
abstractions oriented toward single-computer programs. 

,
often executing in complex environments consisting of many distributed
processors, storage units, and network interconnects.

However, techniques for constructing distributed systems have not kept
up with this rapid rate of change. Distributed systems are typically
implemented with tools developed for single-machine programs, and only
superficially adapted to the challenges of a distributed setting. As a
result, programmers are forced to work at the wrong level of
abstraction. As a result, typical distributed systems are:
\begin{itemize}
\item \emph{difficult to construct}, because the programming language
  deals only with local invariants over local state, but the problem
  domain requires global invariants over global state

\item \emph{difficult to reason about}, because the essence of the
  distributed algorithm is obscured amongst a myriad of details for
  resource management, coordination, synchronization, and
  communication

\item
  \emph{fragile}, because the programming language forces programmers
  to mix policy and mechanism. For example, the distribution of data
  among the nodes of a distributed setting is essentially an assertion
  about the communication costs, available network bandwidth, the
  relative costs of communication and computation, and the
  application's data access patterns. By hard-coding the location of
  data in a distributed system, a traditional distributed program
  would be inflexible to changes in any of these parameters.
\end{itemize}

Many distributed algorithms can be concisely described,
but implemented only with great difficulty. This is because
traditional programming languages are non-distributed by default, and
force programmers to concern themselves with myriad details of
communication, synchronization, consensus, and fault tolerance.

We propose a new methodology for constructing distributed systems,
inspired by prior work on declarative networking. Inspired by the data
independence provided by the relational model, we aim to provide
\emph{network scale independence} for distributed systems: developers
should specify their intent in a high-level, declarative language. The
system will then realize their specification in the current
distributed setting --- but can subsequently change the mapping from
specification to realization as the environment changes.

\section{The BOOM Vision}
Motivating the use of declarative logic languages for implementing
distributed systems.

Approach 1:
\begin{itemize}
\item
  building distributed systems is hard

\item
  current techniques for building distributed systems are
  ineffective. Why? Because they operate at the wrong level of
  abstraction

\item
  Declarative logic languages allow the programmer to work at a more
  comfortable level of abstraction
\end{itemize}

Approach 2:
\begin{itemize}
\item
  Like distributed systems, networking protocols are traditionally
  described as finite state machines.

\item 
  Somewhat surprisingly, the declarative specification of network
  protocols yields promising results.

\item 
  We plan to apply the same techniques to a broader class of
  distributed systems
\end{itemize}

\subsection{Declarative Specification of Distributed Filesystems}
Why choose GFS to implement in a declarative language?
\begin{itemize}
\item
  Separation of control and data paths in the design.

\item
  Data centric, ``systemsy''

\item
  Existing implementations intermingle policy and mechanism
\end{itemize}

\section{System Architecture}

\section{System Realization}
\begin{itemize}
\item
  Language integration: what belongs in declarative land, and what in
  imperative land?

\item
  Representation of data

\item
  Use of Paxos as a component
\end{itemize}

\section{Performance Evaluation}
Compared with HDFS. Look at both overall throughput, and metadata ops/second.

\section{Related Work}

\section{Future Work}
\begin{itemize}
\item
  Challenges/difficulties

\item
  Some of the Lincoln vision?

\item
  Cross-layer optimizations

\item
  Continuous query optimization

\item
  Hadoop integration
\end{itemize}

\section{Conclusions}

\bibliographystyle{abbrv}
\bibliography{paper}  % sigproc.bib is the name of the Bibliography in this case
\appendix
\section{Paxos in Overlog}
\end{document}
