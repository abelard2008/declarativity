\documentclass{article}
\usepackage{fullpage}
\title{BoomFS: A Declarative Distributed Filesystem}
\author{Peter Alvaro, Neil Conway}
\date{December 20, 2008}
\begin{document}
\maketitle
\begin{abstract}
  While architectures for distributed computing are rapidly changing,
  techniques for building distributed systems have remained
  stagnant. As distributed computation becomes the common case,
  traditional techniques for building distributed systems will become
  untenable, because they force programs to deal with the mundane
  boilerplate details of constructing reliable distributed
  systems. This yields programs that are difficult to construct,
  understand, modify, and port to new environments. We propose BOOM, a
  new paradigm for concisely specifying a broad class of distributed
  systems. In this paper, we describe the first application in the
  BOOM stack: BoomFS, a distributed filesystem similar to the Google
  File System\cite{gfs} that is implemented in a mixture of Java and
  declarative logic.
\end{abstract}

\section{Introduction}

With the widespread adoption of cloud computing, pervasive mobile
clients, and many-core processors, computing architectures are
undergoing a period of disruptive change. In the near future, nearly
every non-trivial software system will be physically
distributed. Distributed programming will be the common case, rather
than the exception.

Traditional techniques for building distributed systems are ill-suited
to this new environment. Developing fault-tolerant distributed systems
remains enormously difficult and expensive, and is typically only
attempted by the experienced programmers with extensive training in
the field. As more journeyman developers must deal with the challenges
of distributed computing as a matter of course, this situation will
become untenable. Better techniques for constructing distributed
systems are urgently needed.

The fundamental problem with traditional techniques for building
distributed systems is that they provide the wrong abstractions to the
programmer. Distributed systems are typically implemented with tools
developed for single-machine programs, and only superficially adapted
to the challenges of a distributed setting. Programmers are forced to
deal with the mundane details of communication, synchronization, and
consensus. As a result, the essence of the distributed computation is
obscured by a forest of boilerplate details. Evidence for this can be
seen in the fact that distributed algorithms such as Paxos can be
stated in a page of pseudocode, but typically require many thousands
of lines of code to implement using standard
tools\cite{paxosmadelive}.

Traditional tools operate at a low level of abstraction because they
force programmers to intermingle the specification of \emph{what} a
distributed program should do with \emph{how} it can be done. This
results in fragile programs that fail to adapt to changes in their
environments. For example, consider a client program that wants to
compute a function over data stored in a compute cloud. Should the
function code be sent to the server, or should the data be sent to the
client? The optimal policy depends on factors including the relative
costs of network bandwidth, server-side computation and client-side
computation, as well as how much data is required, how expensive the
function is, and the frequency with which the function is invoked or
the input data is modified. All of these variables are likely to
fluctuate in a distributed system, so encoding a particular decision
into the application program results in a fragile design. This
fragility results in programs that cannot easily be modified, or
ported to distributed systems with varying performance
characteristics.

Inspired by the data independence provided by the relational model, we
aim to provide \emph{network scale independence} for distributed
systems by separating the programmer's intent from its concrete
realization. In BOOM, a distributed system is composed of two types of
components:
\begin{itemize}
\item
  \emph{imperative} components that implement the basic units of
  functionality of a distributed system. For example, in BoomFS,
  imperative components are used to transfer data chunks between
  hosts, and to read and write data from the native file system.

\item
  \emph{declarative} components that specify ``what''

\end{itemize}

Because traditional tools force programmers to specify distributed
systems at such a low level of abstraction, 

As distributed systems become the common case, traditional software
engineering techniques will become increasingly untenable. Building a
reliable, efficient distributed system with the present generation of
programming tools 

However, traditional techniques for constructing distributed systems
are 

Traditional techniques for 

Traditional techniques to constructing software systems will be
sub-optimal for this new environment, because they provide
abstractions oriented toward single-computer programs. 

,
often executing in complex environments consisting of many distributed
processors, storage units, and network interconnects.

However, techniques for constructing distributed systems have not kept
up with this rapid rate of change. Distributed systems are typically
implemented with tools developed for single-machine programs, and only
superficially adapted to the challenges of a distributed setting. As a
result, programmers are forced to work at the wrong level of
abstraction. As a result, typical distributed systems are:
\begin{itemize}
\item \emph{difficult to construct}, because the programming language
  deals only with local invariants over local state, but the problem
  domain requires global invariants over global state

\item \emph{difficult to reason about}, because the essence of the
  distributed algorithm is obscured amongst a myriad of details for
  resource management, coordination, synchronization, and
  communication

\item
  \emph{fragile}, because the programming language forces programmers
  to mix policy and mechanism. For example, the distribution of data
  among the nodes of a distributed setting is essentially an assertion
  about the communication costs, available network bandwidth, the
  relative costs of communication and computation, and the
  application's data access patterns. By hard-coding the location of
  data in a distributed system, a traditional distributed program
  would be inflexible to changes in any of these parameters.
\end{itemize}

Many distributed algorithms can be concisely described,
but implemented only with great difficulty. This is because
traditional programming languages are non-distributed by default, and
force programmers to concern themselves with myriad details of
communication, synchronization, consensus, and fault tolerance.

We propose a new methodology for constructing distributed systems,
inspired by prior work on declarative networking. Inspired by the data
independence provided by the relational model, we aim to provide
\emph{network scale independence} for distributed systems: developers
should specify their intent in a high-level, declarative language. The
system will then realize their specification in the current
distributed setting --- but can subsequently change the mapping from
specification to realization as the environment changes.

\section{The BOOM Vision}
Motivating the use of declarative logic languages for implementing
distributed systems.

Approach 1:
\begin{itemize}
\item
  building distributed systems is hard

\item
  current techniques for building distributed systems are
  ineffective. Why? Because they operate at the wrong level of
  abstraction

\item
  Declarative logic languages allow the programmer to work at a more
  comfortable level of abstraction
\end{itemize}

Approach 2:
\begin{itemize}
\item
  Like distributed systems, networking protocols are traditionally
  described as finite state machines.

\item 
  Somewhat surprisingly, the declarative specification of network
  protocols yields promising results.

\item 
  We plan to apply the same techniques to a broader class of
  distributed systems
\end{itemize}

\subsection{Declarative Specification of Distributed Filesystems}
Why choose GFS to implement in a declarative language?
\begin{itemize}
\item
  Separation of control and data paths in the design.

\item
  Data centric, ``systemsy''

\item
  Existing implementations intermingle policy and mechanism
\end{itemize}

\section{System Architecture}

\section{System Realization}
\begin{itemize}
\item
  Language integration: what belongs in declarative land, and what in
  imperative land?

\item
  Representation of data

\item
  Use of Paxos as a component
\end{itemize}

\section{Performance Evaluation}
Compared with HDFS. Look at both overall throughput, and metadata ops/second.

\section{Related Work}

\section{Future Work}
\begin{itemize}
\item
  Challenges/difficulties

\item
  Some of the Lincoln vision?

\item
  Cross-layer optimizations

\item
  Continuous query optimization

\item
  Hadoop integration
\end{itemize}

\section{Conclusions}

\bibliographystyle{abbrv}
\bibliography{paper}
\appendix
\section{Paxos in Overlog}
\end{document}
