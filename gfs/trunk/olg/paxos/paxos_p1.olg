program paxos;
	
import java.lang.String;
import java.lang.Integer;
	
import java.lang.System;
import jol.core.Runtime;

timer(periodic,logical,1,1,1);
	
define(decreeRequest,{String,String,String});
define(storedDecreeRequest,keys(0,1,2,3),{String,String,String,Long});
define(lastTried,keys(0),{String,Integer});
define(prevVote,keys(0),{String,Integer,String});
define(nextBal,keys(0),{String,Integer});
define(node,keys(0),{String});
define(parliament,keys(0,1),{String,String});
define(prepare,keys(0,1),{String,Integer,String});
define(sendPrepare,keys(0,1,3),{String,Integer,String,String});
define(lastPromise,keys(0,1,4),{String,Integer,Integer,String,String});
define(sendPromise,keys(0,1,4),{String,Integer,Integer,String,String});
	
define(maxPrevRound,keys(0),{String,Integer});
define(priestCnt,keys(0),{String,Integer});
define(lastPromiseCnt,keys(0,1),{String,Integer,Integer});
define(quorum,keys(0,1),{String,Integer});
	
define(tick,keys(0,1),{String,String,Integer});

//define(instance,keys(0),{String,Integer});

watch(quorum,ae);
watch(prepare,ae);
watch(lastPromise,ae);
watch(lastPromiseCnt,ae);

/*******************************************************************
nomenclature mappings between "parliamentary paxos" and "simple paxos"

part time parliament --> paxos made simple
-------------------------------------------
Agent         Agent
Ballot        Round
NextBallot    Prepare
LastVote      Promise
Vote          Accept


PAXOS global invariants:

  let B be a set of ballots with the following components:

    B.dec - A decree (the one being voted on).
    B.qrm - A nonempty set of priests (the ballotÕs quorum).
    B.vot - A set of priests (the ones who cast votes for the decree).
    B.bal - A ballot number.


  Consistency is guaranteed and progress is possible if:

  B1(B) - Each ballot in B has a unique ballot number.
  B2(B) - The quorums of any two ballots in B have at least one priest in common.
  B3(B) - For every ballot B in B, if any priest in BÕs quorum voted in an earlier
      ballot in B, then the decree of B equals the decree of the latest of those
      earlier ballots.
*/
	

public
parliament(A,B) :- getopt::parliament(A,B),periodic(_,_,_);
	
lastTried(Master,-1) :- parliament(Master,Agent);
prevVote(Master,-1,"none") :- parliament(Master,Agent);
nextBal(Master,-1) :- parliament(Master,Agent);
//instance(Master,-1) :- parliament(Master,Agent);

/**************************************************************************************
r1. Priest p chooses a new ballot number b greater than lastTried [p], sets lastTried[p]
to b, and sends a NextBallot (b) message to some set of priests.
***************************************************************************************/

r1_a
lastTried(Agent,Bnum) :- lastTried(Agent,Old),
	prepare#insert(Agent,Bnum,Decree),
	Bnum > Old;
	
storedDecreeRequest(A,B,C,Id) :- 
  decreeRequest#insert(A,B,C), 
  Id := Runtime.idgen();
//instance(Master,I+1) :- instance(Master,I), storedDecreeRequest#insert(Master,B,C);
	
r1_b
prepare(Agent,Round,Decree) :- 
	storedDecreeRequest#insert(Agent,Decree,From),
	lastTried(Agent,Old),
	// if we don't already have a quorum 
  notin quorum(Agent,_),
  //instance#insert(Agent,0),
	Round := Old + 1;

// 
public r1_b2
prepare(Agent,Round,Decree) :-
  // current instance
  lastTried(Agent,Old),
  //notin quorum(Agent,_),
  paxos_global::decreeRequestBuffer#insert(Master,Decree,Client),
  Round := Old + 1;

	
r1_c
sendPrepare(@Peer,Round,Decree,Agent) :-prepare(@Agent,Round,Decree),
	parliament(@Agent,Peer);

/**************************************************************************************
2. Upon receipt of a NextBallot (b) message from p with b > nextBal [q], priest q
sets nextBal [q] to b and sends a LastVote (b, v) message to p, where v equals
prevVote [q]. (A NextBallot (b) message is ignored if b ² nextBal [q].)
***************************************************************************************/


r2_a
nextBal(Agent,Round) :-nextBal(Agent,Old),
	lastPromise#insert(Agent,Round,OldRound,Decree),
	Round > Old;


r2_b
lastPromise(Agent,Round,OldRound,OldDecree,Peer) :- 
  sendPrepare#insert(Agent,Round,Decree,Peer),
	prevVote(Agent,OldRound,OldDecree),
	Round >= OldRound;

r2_c	
sendPromise(@Master,Round,OldRound,Decree,Agent) :-
	lastPromise(@Agent,Round,OldRound,Decree,Master);	


/* for quorum handling, aggregates are difficult to avoid... */
priestCnt(Master,count<*>) :- parliament(Master,Agent);
lastPromiseCnt(Master,Round,count<Agent>) :- sendPromise#insert(Master,Round,Foo,Bar,Agent);
maxPrevRound(Master,max<OldRound>) :- sendPromise(Master,Round,OldRound,Decree,Agent);
	
/**************************************************************************************
3.  After receiving a LastVote (b, v) message from every priest in some majority
set Q, where b = lastTried [p], priest p initiates a new ballot with number b,
quorum Q, and decree d, where d is chosen to satisfy B3. He then sends a
BeginBallot (b, d) message to every priest in Q.
***************************************************************************************/

define(quorumEvent,{String,Integer});
r3_a	
quorumEvent(Master,Round) :- 
  priestCnt(Master,Pcnt),
	lastPromiseCnt(Master,Round,Vcnt),
	Vcnt > ( Pcnt / 2 );

quorum(M,R) :- quorumEvent#insert(M,R);
	
