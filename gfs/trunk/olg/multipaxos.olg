program paxos;
	
import java.lang.String;
import java.lang.Integer;
	
import java.lang.System;
import jol.core.Runtime;
	
	//define(decreeRequest,keys(0,1,2),{String,String,String});
define(decreeRequest,{String,String,String});
define(storedDecreeRequest,keys(0,1,2,3),{String,String,String,Long});
define(lastTried,keys(0,1),{String,Integer,Integer});
define(prevVote,keys(0,1),{String,Integer,Integer,String});
define(nextBal,keys(0,1),{String,Integer,Integer});
define(node,keys(0),{String});
define(parliament,keys(0,1),{String,String});
define(prepare,keys(0,1,2),{String,Integer,Integer,String});
define(sendPrepare,keys(0,1,2,4),{String,Integer,Integer,String,String});
define(lastPromise,keys(0,1,2,5),{String,Integer,Integer,Integer,String,String});
define(sendPromise,keys(0,1,2,5),{String,Integer,Integer,Integer,String,String});
define(receivedPromise,keys(0,1,2,5),{String,Integer,Integer,Integer,String,String});
define(acceptRequest,keys(0,1,2),{String,Integer, Integer,String,Integer});
define(sendBeginRound,keys(0,1,2),{String,Integer, Integer,String,String});
define(accept,keys(0,1,2),{String,Integer, Integer,String});
define(sendAccept,keys(0,1,2,4),{String,Integer, Integer,String,String});
define(decree,keys(0,1,2),{String, Integer,Integer,String});
define(success,keys(0,1,2),{String,Integer, Integer,String,String});
	
define(maxPrevRound,keys(0,1),{String,Integer,Integer});
define(priestCnt,keys(0),{String,Integer});
define(lastPromiseCnt,keys(0,1,2),{String,Integer,Integer,Integer});
define(quorum,keys(0,1,2),{String,Integer,Integer});
define(acceptCnt,keys(0,1,2),{String,Integer,Integer,Integer});
	
define(reply,keys(0,1),{String,String,String});
//define(tick,keys(0,1),{String,String,Integer});
define(instance,keys(0),{String,Integer});

//define(timeError,keys(0,1,2,3),{String,String,String,Long});
//watch(timeError,aedir);


public
parliament(A,B) :- getopt::parliament(A,B),periodic(Id,3L,3L);
	
lastTried(Master,-1,-1) :- parliament(Master,Agent);
prevVote(Master,-1,-1,"none") :- parliament(Master,Agent);
nextBal(Master,-1,-1) :- parliament(Master,Agent);
instance(Master,-1) :- parliament(Master,Agent);


/**
good morning, Mr. Van Winkle
**/
// round, instance, decree
define(ledger,keys(0,1),{Integer,Integer,String});
// give everyone 5 seconds to settle
timer(wakeup,5000,0);


//prepare(Agent,Round,Decree) :-
//  wakeup(_,_,_),
//  ledger(Round,Instance,Decree);


/**************************************************************************************
r1. Priest p chooses a new ballot number b greater than lastTried [p], sets lastTried[p]
to b, and sends a NextBallot (b) message to some set of priests.
***************************************************************************************/

r1_a
lastTried(Agent,Instance,Bnum) :- lastTried(Agent,I,Old),
	prepare#insert(Agent,Instance,Bnum,Decree),
	Bnum > Old,
  Instance >= I;
	
storedDecreeRequest(A,B,C,Id) :- decreeRequest#insert(A,B,C), Id := Runtime.idgen();
storedDecreeRequest(A,B,C,Id) :- paxos_global::decreeRequestBuffer#insert(A,B,C), Id := Runtime.idgen();

instance(Master,I+1) :- instance(Master,I), storedDecreeRequest#insert(Master,B,C,_);
	
r1_b
prepare(Agent,Instance,Round,Decree) :- 
	storedDecreeRequest#insert(Agent,Decree,From),
	lastTried(Agent,I,Old),
  Instance >= I,
  instance(Agent,Instance),
	// if we don't already have a quorum
  //instance#insert(Agent,0),
	Round := Old + 1;
	
r1_c
sendPrepare(@Peer,Instance,Round,Decree,Agent) :-
  prepare(@Agent,Instance,Round,Decree),
	parliament(@Agent,Peer);

/**************************************************************************************
2. Upon receipt of a NextBallot (b) message from p with b > nextBal [q], priest q
sets nextBal [q] to b and sends a LastVote (b, v) message to p, where v equals
prevVote [q]. (A NextBallot (b) message is ignored if b Â² nextBal [q].)
***************************************************************************************/


r2_a
nextBal(Agent,Instance,Round) :-
  nextBal(Agent,I,Old),
	lastPromise#insert(Agent,Instance,Round,OldRound,Decree),
  Instance >= I,
	Round > Old;


r2_b
lastPromise(Agent,Instance,Round,OldRound,OldDecree,Peer) :- 
  sendPrepare#insert(Agent,Instance,Round,Decree,Peer),
	prevVote(Agent,I,OldRound,OldDecree),
  Instance == I,
	Round >= OldRound;

lastPromise(Agent,Instance,Round,-1,"none",Peer) :- 
  sendPrepare#insert(Agent,Instance,Round,Decree,Peer),
	prevVote(Agent,I,OldRound,OldDecree),
  Instance > I,
	Round >= OldRound;


r2_c	
sendPromise(@Master,Instance,Round,OldRound,Decree,Agent) :-
	lastPromise(@Agent,Instance,Round,OldRound,Decree,Master);	


/* for quorum handling, aggregates are difficult to avoid... */
priestCnt(Master,count<*>) :- parliament(Master,Agent);
lastPromiseCnt(Master,Instance,Round,count<Agent>) :- sendPromise#insert(Master,Instance,Round,Foo,Bar,Agent);
maxPrevRound(Master,Instance,max<OldRound>) :- sendPromise(Master,Instance,Round,OldRound,Decree,Agent);
	
/**************************************************************************************
3.  After receiving a LastVote (b, v) message from every priest in some majority
set Q, where b = lastTried [p], priest p initiates a new ballot with number b,
quorum Q, and decree d, where d is chosen to satisfy B3. He then sends a
BeginBallot (b, d) message to every priest in Q.
***************************************************************************************/

define(quorumEvent,{String,Integer,Integer});
r3_a	
quorumEvent(Master,Instance,Round) :- priestCnt(Master,Pcnt),
	lastPromiseCnt(Master,Instance,Round,Vcnt),
	Vcnt > ( Pcnt / 2 );

quorum(M,I,R) :- quorumEvent#insert(M,I,R);
	
r3_b
acceptRequest(Master,Instance,Round,OldDecree,MaxB) :- 
  quorum(Master,Instance,Round),
	maxPrevRound(Master,Instance,MaxB),
	prepare(Master,Instace,Round,Decree),
	sendPromise(Master,Instance,Round,MaxB,OldDecree,Agent),
	MaxB != -1;

r3_c	
acceptRequest(Master,Instance,Round,Decree,-1) :- 
  quorum(Master,Instance,Round),
	maxPrevRound(Master,Instance,MaxB),
	sendPromise(Master,Instance,Round,MaxB,OldDecree,Agent),
	MaxB == -1,
	prepare(Master,Instance,Round,Decree);
	
	// or in the multi-paxos case:
	/*
acceptRequest(Master,OldB+1,Decree,OldB) :- 
	storedDecreeRequest(Master,Decree,From,_),
	quorum(Master,OldB);
	*/

acceptRequest(Master,Instance,-1,Decree,-1) :-
  storedDecreeRequest(Master,Decree,From,_),
  quorum(Master,Instance,OldB),
  instance(Master,Instance),
  Instance > -1;

r3_e
sendBeginRound(@Agent,Instance,Round,Decree,Master) :- 
  acceptRequest(@Master,Instance,Round,Decree,Kind),
	parliament(@Master,Agent);

/**************************************************************************************
r4. Upon receipt of a BeginBallot (b,d) message with b = nextBal [q], priest q casts
his vote in ballot number b, sets prevVote [q] to this vote, and sends a Voted (b, q)
message to p. (A BeginBallot (b, d) message is ignored if b = nextBal [q].)
***************************************************************************************/
r4_a
accept(Agent,Instance,Round,Decree) :- 
  sendBeginRound(Agent,Instance,Round,Decree,Master),
	nextBal(Agent,Instance,OldB),
	Round == OldB;

// we are locked in quorum
//accept(Agent,Instance,Round,Decree) :- 
//  sendBeginRound(Agent,Round,Decree,Master),
//  Round == -1;
	
r4_b	
prevVote(Agent,Instance,Round,Decree) :- 
  prevVote(Agent,I,Old,OD),
	lastPromise(Agent,Instance,Round,OldRound,OldDecree),
	accept#insert(Agent,Instance,Round,Decree),
	Round >= Old,
  Instance >= I;

r4_c	
sendAccept(@Master,Instance,Round,Decree,Agent) :- 
  accept(@Agent,Instance,Round,Decree),
	sendBeginRound(@Agent,Instance,Round,Decree,Master);
	
acceptCnt(Master,Instance,Round,count<Agent>) :- sendAccept(Master,Instance,Round,Decree,Agent);

/**************************************************************************************
r5. If p has received a Voted (b, q) message from every priest q in Q (the quorum
for ballot number b), where b = lastTried [p], then he writes d (the decree of
that ballot) in his ledger and sends a Success (d) message to every priest.
***************************************************************************************/
r5_a	
decree(Master,Instance,Round,Decree) :- 
  lastTried(Master,Instance,Round),
	acceptCnt#insert(Master,Instance,Round,Votes),
	// this is |quorum| 
	lastPromiseCnt(Master,Instance,Round,Votes),
	acceptRequest(Master,Instance,Round,Decree);

r5_b	
success(@Agent,Instance,Round,Decree,From) :-decree#insert(@Master,Instance,Round,Decree),
	// this might be a mistake. 
	storedDecreeRequest(@Master,Decree,From,_),
	// we interpret "every" to mean a broadcast.
	parliament(@Master,Agent);
	
	// any learner can reply to the client.or set-wise, they all can...
watch(reply,aid);
//reply(@Client,Decree,"passed") :- success(@Me,Instance,Round,Decree,Client);

public
paxos_global::requestStatus(Me,Client,Decree,"passed") :-
  success(Me,Instance,Round,Decree,Client);

public
reply(@Client,Decree,Message) :-
  paxos_global::requestStatus(@Master,Client,Decree,Message);


/*
reply(@Client,Decree,"timed out") :-
  timeError(@Master,Client,Decree,Id);
*/
	




/***
  subroutine, really, for figuring out cohort membership from the environment.
	I'd like to have this in a separate file, but that isn't working... 
***/
/*
define(ident,keys(0),{Integer,Integer});
	
ident(A,P) :- A := new Integer(System.getenv("ME")),
	P := new Integer(System.getenv("PROC")),
	periodic(Id,1L,1L,1L);
	
define(fake,keys(0,1),{Integer,Integer});
	
fake(A,0) :- ident(A,P),B := A;
fake(A,O+1) :- ident(A,P),
	fake(A,O),
	O < P;
	
parliament(Me,Him) :- fake(A,B),
	Left := A + 10000,
	Right := B + 10000,
	Me := "tcp:localhost:" + Left.toString(),
	Him := "tcp:localhost:" + Right.toString();
*/
	/* end sub-thing */


	/**/
//watch(tick,ie);
watch(prepare,ae);
watch(sendPrepare,ae);
watch(lastTried,ae);
watch(parliament,ae);
watch(sendPromise,ae);
watch(priestCnt,ar);
watch(lastPromiseCnt,ae);
watch(lastPromise,ae);
	/**/
watch(quorum,ae);
watch(decree,ae);
watch(acceptCnt,ae);
watch(sendAccept,ae);
watch(accept,ae);
watch(success,ae);
watch(decreeRequest,ae);
	
//watch(maxPrevRound,ae);
watch(acceptRequest,ae);
//watch(receivedPromise,ae);
	
watch(prevVote,ae);	
watch(instance,ae);
	
	
